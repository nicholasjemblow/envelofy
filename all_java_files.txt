===== ./src/main/java/org/emblow/envelopify/ui/components/UnusualSpendingChart.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.littemplate.LitTemplate;
import com.vaadin.flow.component.Tag;
import com.vaadin.flow.component.dependency.JsModule;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.service.ml.SpendingInsight;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.emblow.envelopify.service.ml.SpendingInsightType;

import java.util.List;
import java.util.stream.Collectors;

@Tag("unusual-spending-chart")
@JsModule("./unusual-spending-chart.js")
@AnonymousAllowed
public class UnusualSpendingChart extends LitTemplate {
    
    private final SpendingInsightService insightService;
    private final String envelopeName;

    public UnusualSpendingChart(SpendingInsightService insightService, Envelope envelope) {
        this.insightService = insightService;
        this.envelopeName = envelope.getName();
        
        // Set sizing via style
        getElement().getStyle().set("display", "block");
        getElement().getStyle().set("height", "400px");
        getElement().getStyle().set("width", "100%");
        
        refreshData();
    }

    private void refreshData() {
        // Get unusual spending insights for this envelope
        List<SpendingInsight> insights = insightService.generateInsights().stream()
            .filter(i -> i.getType() == SpendingInsightType.UNUSUAL_SPENDING 
                && i.getMessage().contains(envelopeName))
            .collect(Collectors.toList());

        // Build labels and data arrays using valid JSON (double quotes for strings)
        StringBuilder labels = new StringBuilder("[");
        StringBuilder data = new StringBuilder("[");

        for (int i = 0; i < insights.size(); i++) {
            if (i > 0) {
                labels.append(",");
                data.append(",");
            }

            // Use double quotes so that JSON.parse will succeed in JS.
            labels.append("\"Event ").append(i + 1).append("\"");
            data.append(String.format("%.2f", insights.get(i).getConfidence() * 100));
        }

        labels.append("]");
        data.append("]");

        // Update the chart properties
        getElement().setProperty("labels", labels.toString());
        getElement().setProperty("data", data.toString());
    }

}
===== ./src/main/java/org/emblow/envelopify/ui/components/InsightsPanel.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import org.emblow.envelopify.service.ml.SpendingInsight;
import org.emblow.envelopify.service.ml.SpendingInsightType;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class InsightsPanel extends VerticalLayout {
    
    public InsightsPanel() {
        addClassName("insights-panel");
        setSpacing(true);
        setPadding(true);
        
        getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("box-shadow", "var(--lumo-box-shadow-s)");
    }
    
    public void setInsights(List<SpendingInsight> insights) {
        removeAll();
        
        add(new H3("Smart Insights"));
        
        if (insights.isEmpty()) {
            add(new Span("No insights available yet. Add more transactions to get personalized insights."));
            return;
        }

        // Group insights by type
        Map<SpendingInsightType, List<SpendingInsight>> groupedInsights = insights.stream()
            .collect(Collectors.groupingBy(SpendingInsight::getType));

        // Add insights by type in a specific order
        addInsightGroup(groupedInsights, SpendingInsightType.UNUSUAL_SPENDING, 
            VaadinIcon.EXCLAMATION_CIRCLE, "var(--lumo-error-color)");
        addInsightGroup(groupedInsights, SpendingInsightType.RECURRING_PAYMENT, 
            VaadinIcon.CLOCK, "var(--lumo-primary-color)");
        addInsightGroup(groupedInsights, SpendingInsightType.PREDICTED_EXPENSE, 
            VaadinIcon.CHART_TIMELINE, "var(--lumo-success-color)");
        addInsightGroup(groupedInsights, SpendingInsightType.BUDGET_SUGGESTION, 
            VaadinIcon.PIGGY_BANK, "var(--lumo-primary-color)");
        addInsightGroup(groupedInsights, SpendingInsightType.SEASONAL_PATTERN, 
            VaadinIcon.CALENDAR, "var(--lumo-contrast-color)");
        addInsightGroup(groupedInsights, SpendingInsightType.REALLOCATION_SUGGESTION, 
            VaadinIcon.EXCHANGE, "var(--lumo-primary-color)");
    }
    
    private void addInsightGroup(
        Map<SpendingInsightType, List<SpendingInsight>> groupedInsights,
        SpendingInsightType type,
        VaadinIcon icon,
        String color
    ) {
        List<SpendingInsight> insights = groupedInsights.get(type);
        if (insights != null && !insights.isEmpty()) {
            insights.forEach(insight -> {
                Div card = createInsightCard(insight, icon, color);
                add(card);
            });
        }
    }
    
    private Div createInsightCard(SpendingInsight insight, VaadinIcon iconType, String color) {
        Div card = new Div();
        card.addClassName("insight-card");
        card.getStyle()
            .set("padding", "var(--lumo-space-m)")
            .set("border-radius", "var(--lumo-border-radius-m)")
            .set("background-color", "var(--lumo-base-color)")
            .set("border-left", "4px solid " + color)
            .set("margin-bottom", "var(--lumo-space-m)")
            .set("box-shadow", "var(--lumo-box-shadow-xs)");
        
        Icon icon = iconType.create();
        icon.setColor(color);
        icon.getStyle().set("margin-right", "var(--lumo-space-s)");
        
        Span message = new Span(insight.getMessage());
        message.getStyle()
            .set("color", "var(--lumo-body-text-color)")
            .set("font-size", "var(--lumo-font-size-s)");
        
        Div confidenceIndicator = new Div();
        confidenceIndicator.getStyle()
            .set("height", "4px")
            .set("background-color", color)
            .set("margin-top", "var(--lumo-space-s)")
            .set("border-radius", "var(--lumo-border-radius-s)")
            .set("opacity", String.valueOf(insight.getConfidence()));
        
        card.add(icon, message, confidenceIndicator);
        return card;
    }
}
===== ./src/main/java/org/emblow/envelopify/ui/components/CSVImportDialog.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Paragraph;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.upload.Upload;
import com.vaadin.flow.component.upload.receivers.MemoryBuffer;
import com.vaadin.flow.component.textfield.NumberField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.select.Select;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.service.CSVImportService;
import org.emblow.envelopify.service.CSVImportService.CSVMapping;
import org.emblow.envelopify.service.EnvelopeService;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.AccountService;



public class CSVImportDialog extends Dialog {
    private final CSVImportService csvImportService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final Runnable onSuccess;

    private final MemoryBuffer buffer;
    private final Upload upload;
    private final ComboBox<Envelope> defaultEnvelopeField;
    private final ComboBox<Account> accountField;
    private final Select<String> presetMappingField;
    private final TextField delimiterField;
    private final NumberField dateColumnField;
    private final TextField dateFormatField;
    private final NumberField descriptionColumnField;
    private final NumberField amountColumnField;
    private final NumberField amountMultiplierField;

    public CSVImportDialog(
        CSVImportService csvImportService,
        EnvelopeService envelopeService,
        AccountService accountService,
        Runnable onSuccess
    ) {
        this.csvImportService = csvImportService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.onSuccess = onSuccess;

        setModal(true);
        setDraggable(true);
        setResizable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);

        // Title
        H3 title = new H3("Import Transactions from CSV");
        layout.add(title);

        // File upload
        buffer = new MemoryBuffer();
        upload = new Upload(buffer);
        upload.setAcceptedFileTypes(".csv");
        upload.addSucceededListener(event -> {
            Notification.show(
                "File uploaded successfully: " + event.getFileName(),
                3000,
                Notification.Position.MIDDLE
            );
        });
        layout.add(upload);

        // Account selection
        accountField = new ComboBox<>("Account");
        accountField.setItemLabelGenerator(account -> 
            String.format("%s (%s)", 
                account.getName(),
                account.getType().getDisplayName()
            )
        );
        accountField.setItems(accountService.getAllAccounts());
        accountField.setRequired(true);
        accountField.setWidthFull();
        layout.add(accountField);

        // Preset mappings dropdown
        presetMappingField = new Select<>();
        presetMappingField.setLabel("Preset Format");
        presetMappingField.setItems("Custom", "Chase", "Bank of America");
        presetMappingField.setValue("Custom");
        presetMappingField.addValueChangeListener(e -> updateMappingFields(e.getValue()));
        layout.add(presetMappingField);

        // CSV mapping fields
        delimiterField = new TextField("Delimiter");
        delimiterField.setValue(",");

        dateColumnField = new NumberField("Date Column Index");
        dateColumnField.setValue(0.0);
        dateColumnField.setStep(1.0);
        dateColumnField.setMin(0);

        dateFormatField = new TextField("Date Format");
        dateFormatField.setValue("MM/dd/yyyy");

        descriptionColumnField = new NumberField("Description Column Index");
        descriptionColumnField.setValue(1.0);
        descriptionColumnField.setStep(1.0);
        descriptionColumnField.setMin(0);

        amountColumnField = new NumberField("Amount Column Index");
        amountColumnField.setValue(2.0);
        amountColumnField.setStep(1.0);
        amountColumnField.setMin(0);

        amountMultiplierField = new NumberField("Amount Multiplier");
        amountMultiplierField.setValue(1.0);
        amountMultiplierField.setHelperText("Use -1 if amounts need to be reversed");

        layout.add(
            delimiterField,
            dateColumnField,
            dateFormatField,
            descriptionColumnField,
            amountColumnField,
            amountMultiplierField
        );

        // Default envelope selector
        defaultEnvelopeField = new ComboBox<>("Default Envelope");
        defaultEnvelopeField.setItemLabelGenerator(Envelope::getName);
        defaultEnvelopeField.setItems(envelopeService.getAllEnvelopes());
        defaultEnvelopeField.setRequired(true);
        layout.add(defaultEnvelopeField);

        // Help text
        Paragraph help = new Paragraph(
            "Column indices start at 0. Date format should match the pattern in your CSV file."
        );
        layout.add(help);

        // Buttons
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> close());

        Button importButton = new Button("Import", e -> importData());
        importButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        buttons.add(cancelButton, importButton);
        layout.add(buttons);

        add(layout);
    }

    private void updateMappingFields(String preset) {
        switch (preset) {
            case "Chase" -> {
                delimiterField.setValue(",");
                dateColumnField.setValue(0.0);
                dateFormatField.setValue("MM/dd/yyyy");
                descriptionColumnField.setValue(2.0);
                amountColumnField.setValue(3.0);
                amountMultiplierField.setValue(1.0);
            }
            case "Bank of America" -> {
                delimiterField.setValue(",");
                dateColumnField.setValue(0.0);
                dateFormatField.setValue("MM/dd/yyyy");
                descriptionColumnField.setValue(1.0);
                amountColumnField.setValue(2.0);
                amountMultiplierField.setValue(1.0);
            }
            // Add more presets as needed
        }
    }

    private void importData() {
        try {
            if (defaultEnvelopeField.isEmpty()) {
                throw new IllegalArgumentException("Please select a default envelope");
            }
            if (accountField.isEmpty()) {
                throw new IllegalArgumentException("Please select an account");
            }

            // Read file content
            InputStream is = buffer.getInputStream();
            String content = new Scanner(is, StandardCharsets.UTF_8)
                .useDelimiter("\\A")
                .next();

            // Create mapping from form fields
            CSVMapping mapping = new CSVMapping(
                true, // Assume headers for now
                delimiterField.getValue(),
                dateColumnField.getValue().intValue(),
                dateFormatField.getValue(),
                descriptionColumnField.getValue().intValue(),
                amountColumnField.getValue().intValue(),
                amountMultiplierField.getValue()
            );

            // Import data
            CSVImportService.ImportResult result = csvImportService.importTransactions(
                content,
                mapping,
                defaultEnvelopeField.getValue().getId(),
                accountField.getValue().getId()
            );

            // Show results
            String message = String.format(
                "Imported %d transactions successfully. %d failed.",
                result.getSuccessful(),
                result.getFailed()
            );

            if (result.getFailed() > 0) {
                message += "\nErrors:\n" + String.join("\n", result.getErrors());
            }

            Notification notification = Notification.show(
                message,
                5000,
                Notification.Position.MIDDLE
            );

            if (result.getFailed() > 0) {
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            } else {
                notification.addThemeVariants(NotificationVariant.LUMO_SUCCESS);
            }

            // Close dialog and refresh parent view
            close();
            onSuccess.run();

        } catch (IllegalArgumentException ex) {
            Notification notification = Notification.show(
                "Error importing data: " + ex.getMessage(),
                5000,
                Notification.Position.MIDDLE
            );
            notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
        }
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/TransactionManagementDialogs.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

import com.vaadin.flow.component.ClickEvent;
import com.vaadin.flow.component.ComponentEventListener;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import com.vaadin.flow.component.textfield.BigDecimalField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.datepicker.DatePicker;
import com.vaadin.flow.component.timepicker.TimePicker;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.confirmdialog.ConfirmDialog;
import com.vaadin.flow.spring.annotation.SpringComponent;
import com.vaadin.flow.spring.annotation.UIScope;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.service.PatternService;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@SpringComponent
@UIScope
public class TransactionManagementDialogs {

    private final TransactionService transactionService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final PatternService patternService;

    public TransactionManagementDialogs(
        TransactionService transactionService,
        EnvelopeService envelopeService,
        AccountService accountService,
        PatternService patternService
    ) {
        this.transactionService = transactionService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.patternService = patternService;
    }

    public void showNewTransactionDialog(Runnable onSuccess) {
        showTransactionDialog(null, onSuccess);
    }

    public void showEditTransactionDialog(Transaction transaction, Runnable onSuccess) {
        showTransactionDialog(transaction, onSuccess);
    }
    public void showNewTransactionDialog(Runnable onSuccess, Account preselectedAccount) {
        // Create a new (empty) transaction and preselect the account.
        Transaction newTransaction = new Transaction();
        newTransaction.setAccount(preselectedAccount);
        showTransactionDialog(newTransaction, onSuccess);
    }

    private void showTransactionDialog(Transaction transaction, Runnable onSuccess) {
        boolean isEdit = transaction != null;
        
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);

        H3 title = new H3(isEdit ? "Edit Transaction" : "New Transaction");

        // Date and time pickers
        DatePicker datePicker = new DatePicker("Date");
        TimePicker timePicker = new TimePicker("Time");
        
        if (isEdit) {
            datePicker.setValue(transaction.getDate().toLocalDate());
            timePicker.setValue(transaction.getDate().toLocalTime());
        } else {
            datePicker.setValue(java.time.LocalDate.now());
            timePicker.setValue(java.time.LocalTime.now());
        }

        // Description field
        TextField descriptionField = new TextField("Description");
        descriptionField.setWidthFull();
        descriptionField.setRequired(true);
        if (isEdit) {
            descriptionField.setValue(transaction.getDescription());
        }

        // Amount field
        BigDecimalField amountField = new BigDecimalField("Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setWidthFull();
        if (isEdit) {
            amountField.setValue(transaction.getAmount());
        } else {
            amountField.setValue(BigDecimal.ZERO);
        }

        // Transaction Type selector
        ComboBox<TransactionType> typeField = new ComboBox<>("Transaction Type");
        typeField.setItems(TransactionType.values());
        typeField.setItemLabelGenerator(tt -> tt == TransactionType.INCOME ? "Income" : "Expense");
        typeField.setWidthFull();
        typeField.setRequired(true);
        if (isEdit) {
            typeField.setValue(transaction.getType());
        } else {
            // Default to Expense for new transactions
            typeField.setValue(TransactionType.EXPENSE);
        }

        // Account selector
        ComboBox<Account> accountField = new ComboBox<>("Account");
        accountField.setItemLabelGenerator(account -> 
            String.format("%s (%s) - Balance: $%.2f", 
                account.getName(),
                account.getType().getDisplayName(),
                account.getBalance()
            )
        );
        accountField.setItems(accountService.getAllAccounts());
        accountField.setRequired(true);
        accountField.setWidthFull();
        if (isEdit) {
            accountField.setValue(transaction.getAccount());
        } else if (transaction.getAccount() != null) {
            accountField.setValue(transaction.getAccount());
        }


        // Envelope selector
        ComboBox<Envelope> envelopeField = new ComboBox<>("Envelope");
        envelopeField.setItemLabelGenerator(env -> 
            String.format("%s - Available: $%.2f", 
                env.getName(),
                env.getAvailable()
            )
        );
        envelopeField.setItems(envelopeService.getAllEnvelopes());
        envelopeField.setWidthFull();
        envelopeField.setRequired(true);
        if (isEdit) {
            envelopeField.setValue(transaction.getEnvelope());
        }

        // Add envelope suggestions
        EnvelopeSuggestions suggestions = new EnvelopeSuggestions(envelopeField, patternService);

        // Update suggestions when description changes
        descriptionField.addValueChangeListener(e -> {
            Transaction temp = new Transaction();
            temp.setDescription(e.getValue());
            temp.setAmount(amountField.getValue());
            temp.setDate(LocalDateTime.of(datePicker.getValue(), timePicker.getValue()));
            temp.setAccount(accountField.getValue());
            suggestions.updateSuggestions(temp);
        });

        // Buttons
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button saveButton = new Button(isEdit ? "Save" : "Create", new ComponentEventListener<ClickEvent<Button>>() {
            @Override
            public void onComponentEvent(ClickEvent<Button> e) {
                try {
                    String description = descriptionField.getValue();
                    BigDecimal amount = amountField.getValue();
                    TransactionType type = typeField.getValue();
                    Envelope envelope = envelopeField.getValue();
                    Account account = accountField.getValue();
                    LocalDateTime dateTime = LocalDateTime.of(
                            datePicker.getValue(),
                            timePicker.getValue()
                    );
                    
                    // Validation
                    if (description == null || description.trim().isEmpty()) {
                        throw new IllegalArgumentException("Please enter a description");
                    }
                    if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                        throw new IllegalArgumentException("Please enter a non-zero amount");
                    }
                    if (envelope == null) {
                        throw new IllegalArgumentException("Please select an envelope");
                    }
                    if (account == null) {
                        throw new IllegalArgumentException("Please select an account");
                    }
                    if (type == null) {
                        throw new IllegalArgumentException("Please select a transaction type");
                    }
                    
                    if (isEdit) {
                        transactionService.updateTransaction(
                                transaction.getId(),
                                envelope.getId(),
                                account.getId(),
                                dateTime,
                                description.trim(),
                                amount,
                                type
                        );
                    } else {
                        transactionService.recordTransaction(
                                envelope.getId(),
                                account.getId(),
                                dateTime,
                                description.trim(),
                                amount,
                                type
                        );
                    }
                    
                    dialog.close();
                    onSuccess.run();
                    
                    Notification.show(
                            isEdit ? "Transaction updated" : "Transaction recorded",
                            3000,
                            Notification.Position.MIDDLE
                    );
                } catch (IllegalArgumentException ex) {
                    Notification notification = Notification.show(
                            "Error: " + ex.getMessage(),
                            3000,
                            Notification.Position.MIDDLE
                    );
                    notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
                }
            }
        });
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        Button deleteButton = null;
        if (isEdit) {
            deleteButton = new Button("Delete", e -> {
                ConfirmDialog confirmDialog = new ConfirmDialog();
                confirmDialog.setHeader("Delete Transaction");
                confirmDialog.setText("Are you sure you want to delete this transaction? This cannot be undone.");
                
                confirmDialog.setCancelable(true);
                confirmDialog.setConfirmText("Delete");
                confirmDialog.setConfirmButtonTheme("error");
                
                confirmDialog.addConfirmListener(event -> {
                    try {
                        transactionService.deleteTransaction(transaction.getId());
                        dialog.close();
                        onSuccess.run();
                        Notification.show("Transaction deleted", 3000, Notification.Position.MIDDLE);
                    } catch (Exception ex) {
                        Notification.show(
                            "Error deleting transaction: " + ex.getMessage(),
                            3000,
                            Notification.Position.MIDDLE
                        );
                    }
                });
                
                confirmDialog.open();
            });
            deleteButton.addThemeVariants(ButtonVariant.LUMO_ERROR);
            buttons.add(deleteButton);
        }

        buttons.add(cancelButton, saveButton);

        layout.add(
            title,
            new HorizontalLayout(datePicker, timePicker),
            accountField,
            descriptionField,
            amountField,
            typeField,
            envelopeField,
            suggestions,
            buttons
        );

        dialog.add(layout);
        dialog.open();
    }
}
===== ./src/main/java/org/emblow/envelopify/ui/components/AccountDialog.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.ClickEvent;
import com.vaadin.flow.component.ComponentEventListener;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import com.vaadin.flow.data.binder.Binder;
import com.vaadin.flow.data.validator.RegexpValidator;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.exception.AccountException;
import org.emblow.envelopify.exception.ValidationException;
import org.emblow.envelopify.service.AccountService;

import java.util.Map;

public class AccountDialog extends Dialog {
    private final AccountService accountService;
    private final Runnable onSuccess;
    private final Account existingAccount;
    private final Binder<Account> binder;

    public AccountDialog(AccountService accountService, Runnable onSuccess) {
        this(accountService, onSuccess, null);
    }

    public AccountDialog(AccountService accountService, Runnable onSuccess, Account existingAccount) {
        this.accountService = accountService;
        this.onSuccess = onSuccess;
        this.existingAccount = existingAccount;
        this.binder = new Binder<>(Account.class);

        setModal(true);
        setDraggable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);

        H3 title = new H3(existingAccount == null ? "Add New Account" : "Edit Account");

        // Create form fields with validation
        TextField nameField = new TextField("Account Name");
        nameField.setRequired(true);
        nameField.setWidthFull();
        binder.forField(nameField)
            .asRequired("Name is required")
            .withValidator(name -> name.length() <= 100, "Name must be less than 100 characters")
            .bind(Account::getName, Account::setName);

        ComboBox<Account.AccountType> typeField = new ComboBox<>("Account Type");
        typeField.setItems(Account.AccountType.values());
        typeField.setItemLabelGenerator(Account.AccountType::getDisplayName);
        typeField.setRequired(true);
        binder.forField(typeField)
            .asRequired("Account type is required")
            .bind(Account::getType, Account::setType);

        TextField institutionField = new TextField("Financial Institution");
        institutionField.setWidthFull();
        binder.forField(institutionField)
            .bind(Account::getInstitution, Account::setInstitution);

        TextField accountNumberField = new TextField("Last 4 Digits");
        accountNumberField.setHelperText("For reference only");
        binder.forField(accountNumberField)
            .withValidator(new RegexpValidator(
                "Account number must be exactly 4 digits", "\\d{4}"))
            .bind(Account::getAccountNumber, Account::setAccountNumber);

        // Set existing values if editing
        if (existingAccount != null) {
            binder.readBean(existingAccount);
        }

        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> close());

        Button saveButton = new Button(existingAccount == null ? "Create" : "Save", new ComponentEventListener<ClickEvent<Button>>() {
            @Override
            public void onComponentEvent(ClickEvent<Button> e) {
                try {
                    Account account = existingAccount != null ?
                            existingAccount : new Account();
                    
                    // Validate and write field values to the account object
                    binder.writeBean(account);
                    
                    if (existingAccount == null) {
                        accountService.createAccount(
                                account.getName(),
                                account.getType(),
                                account.getInstitution(),
                                account.getAccountNumber()
                        );
                    } else {
                        accountService.save(account);
                    }
                    
                    close();
                    onSuccess.run();
                    showSuccess(existingAccount == null ? "Account created" : "Account updated");
                    
                } catch (AccountException ex) {
                    showError(ex.getMessage());
                } catch (ValidationException ex) {
                    handleValidationErrors((Map<String, String>) ex.getDetails().get("violations"));
                } catch (com.vaadin.flow.data.binder.ValidationException ex) {
                    showError("An unexpected error occurred: " + ex.getMessage());
                }
            }
        });
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        buttons.add(cancelButton, saveButton);
        layout.add(title, nameField, typeField, institutionField, accountNumberField, buttons);
        add(layout);
    }

    private void showSuccess(String message) {
        Notification.show(message, 3000, Notification.Position.MIDDLE)
            .addThemeVariants(NotificationVariant.LUMO_SUCCESS);
    }

    private void showError(String message) {
        Notification.show(message, 5000, Notification.Position.MIDDLE)
            .addThemeVariants(NotificationVariant.LUMO_ERROR);
    }

    private void handleValidationErrors(Map<String, String> violations) {
        if (violations == null) return;
        
        StringBuilder errorMessage = new StringBuilder("Please correct the following errors:\n");
        violations.forEach((field, error) -> 
            errorMessage.append("â€¢ ").append(error).append("\n"));
        
        showError(errorMessage.toString());
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/RecurringTransactionDialog.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.textfield.BigDecimalField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import org.emblow.envelopify.domain.RecurringTransaction;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.RecurringTransactionService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.AccountService;

import java.math.BigDecimal;

public class RecurringTransactionDialog extends Dialog {
    private final RecurringTransactionService recurringTransactionService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final Runnable onSuccess;
    private final RecurringTransaction existingTransaction;

    public RecurringTransactionDialog(
        RecurringTransactionService recurringTransactionService,
        EnvelopeService envelopeService,
        AccountService accountService,
        Runnable onSuccess
    ) {
        this(recurringTransactionService, envelopeService, accountService, onSuccess, null);
    }

    public RecurringTransactionDialog(
        RecurringTransactionService recurringTransactionService,
        EnvelopeService envelopeService,
        AccountService accountService,
        Runnable onSuccess,
        RecurringTransaction existingTransaction
    ) {
        this.recurringTransactionService = recurringTransactionService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.onSuccess = onSuccess;
        this.existingTransaction = existingTransaction;

        setModal(true);
        setDraggable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);

        H3 title = new H3(existingTransaction == null ? 
            "New Recurring Transaction" : "Edit Recurring Transaction");

        TextField descriptionField = new TextField("Description");
        descriptionField.setRequired(true);
        descriptionField.setWidthFull();

        BigDecimalField amountField = new BigDecimalField("Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setWidthFull();

        ComboBox<RecurringTransaction.RecurrencePattern> patternField = 
            new ComboBox<>("Recurrence Pattern");
        patternField.setItems(RecurringTransaction.RecurrencePattern.values());
        patternField.setRequired(true);

        // Account selector
        ComboBox<Account> accountField = new ComboBox<>("Account");
        accountField.setItemLabelGenerator(account -> 
            String.format("%s (%s) - Balance: $%.2f", 
                account.getName(),
                account.getType().getDisplayName(),
                account.getBalance()
            )
        );
        accountField.setItems(accountService.getAllAccounts());
        accountField.setRequired(true);
        accountField.setWidthFull();

        ComboBox<Envelope> envelopeField = new ComboBox<>("Envelope");
        envelopeField.setItemLabelGenerator(Envelope::getName);
        envelopeField.setItems(envelopeService.getAllEnvelopes());
        envelopeField.setRequired(true);

        // Set existing values if editing
        if (existingTransaction != null) {
            descriptionField.setValue(existingTransaction.getDescription());
            amountField.setValue(existingTransaction.getAmount());
            patternField.setValue(existingTransaction.getPattern());
            accountField.setValue(existingTransaction.getAccount());
            envelopeField.setValue(existingTransaction.getEnvelope());
        }

        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> close());

        Button saveButton = new Button(
            existingTransaction == null ? "Create" : "Save", 
            e -> {
                try {
                    String description = descriptionField.getValue();
                    BigDecimal amount = amountField.getValue();
                    RecurringTransaction.RecurrencePattern pattern = patternField.getValue();
                    Account account = accountField.getValue();
                    Envelope envelope = envelopeField.getValue();

                    // Validation
                    if (description == null || description.trim().isEmpty()) {
                        throw new IllegalArgumentException("Please enter a description");
                    }
                    if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                        throw new IllegalArgumentException("Please enter a valid amount");
                    }
                    if (pattern == null) {
                        throw new IllegalArgumentException("Please select a recurrence pattern");
                    }
                    if (account == null) {
                        throw new IllegalArgumentException("Please select an account");
                    }
                    if (envelope == null) {
                        throw new IllegalArgumentException("Please select an envelope");
                    }

                    RecurringTransaction transaction = existingTransaction != null ? 
                        existingTransaction : new RecurringTransaction();
                    transaction.setDescription(description.trim());
                    transaction.setAmount(amount);
                    transaction.setPattern(pattern);
                    transaction.setAccount(account);
                    transaction.setEnvelope(envelope);

                    if (existingTransaction != null) {
                        recurringTransactionService.update(
                            existingTransaction.getId(), 
                            transaction, 
                            account.getId()
                        );
                    } else {
                        recurringTransactionService.create(transaction, account.getId());
                    }

                    close();
                    onSuccess.run();
                    
                    Notification.show(
                        existingTransaction == null ? 
                            "Recurring transaction created" : 
                            "Recurring transaction updated",
                        3000,
                        Notification.Position.MIDDLE
                    );

                } catch (Exception ex) {
                    Notification notification = Notification.show(
                        "Error: " + ex.getMessage(),
                        3000,
                        Notification.Position.MIDDLE
                    );
                    notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
                }
            }
        );
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        buttons.add(cancelButton, saveButton);
        layout.add(title, descriptionField, amountField, patternField, 
                  accountField, envelopeField, buttons);
        add(layout);
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/AccountCard.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

import com.vaadin.flow.component.ClickEvent;
import com.vaadin.flow.component.ComponentEventListener;
import com.vaadin.flow.component.UI;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.confirmdialog.ConfirmDialog;
import com.vaadin.flow.component.contextmenu.MenuItem;
import com.vaadin.flow.component.contextmenu.SubMenu;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.html.H4;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.menubar.MenuBar;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.orderedlayout.FlexComponent;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.ui.views.AccountView;

public class AccountCard extends Div {
    private final AccountService accountService;
    private final Runnable onModified;

    public AccountCard(Account account, AccountService accountService, Runnable onModified) {
        this.accountService = accountService;
        this.onModified = onModified;

        initializeCard(account);
    }

    private void initializeCard(Account account) {
        addClassName("account-card");
        getStyle()
            .set("background", "var(--card-background, linear-gradient(to bottom, #ffffff, #f9f9f9))")
            .set("border-radius", "12px")
            .set("box-shadow", "var(--card-shadow, 0 4px 8px rgba(0,0,0,0.1))")
            .set("padding", "var(--lumo-space-l)")
            .set("max-width", "320px")
            .set("width", "100%")
            .set("transition", "transform 0.2s, box-shadow 0.2s");

        // Hover effect
        getElement().addEventListener("mouseenter", e ->
            getStyle()
                .set("transform", "scale(1.03)")
                .set("box-shadow", "var(--card-shadow-hover, 0 6px 12px rgba(0,0,0,0.15))")
        );
        getElement().addEventListener("mouseleave", e ->
            getStyle()
                .set("transform", "scale(1)")
                .set("box-shadow", "var(--card-shadow, 0 4px 8px rgba(0,0,0,0.1))")
        );

        VerticalLayout content = new VerticalLayout();
        content.setPadding(false);
        content.setSpacing(true);

        // Header with name
        H4 name = new H4(account.getName());
        name.getStyle()
            .set("margin", "0")
            .set("font-size", "1.2em")
            .set("color", "var(--lumo-primary-text-color)");

        // Type as a badge
        Span type = new Span(account.getType().getDisplayName());
        type.getStyle()
            .set("background", "var(--type-bg, var(--lumo-contrast-10pct))")
            .set("color", "var(--type-text, var(--lumo-secondary-text-color))")
            .set("font-size", "var(--lumo-font-size-s)")
            .set("padding", "2px 8px")
            .set("border-radius", "12px");

        // Balance with highlight
        Span balance = new Span(String.format("$%.2f", account.getBalance()));
        balance.getStyle()
            .set("font-size", "1.5em")
            .set("font-weight", "bold")
            .set("color", "var(--balance-text, white)")
            .set("background", account.getBalance().signum() >= 0 ? "var(--balance-positive, #27ae60)" : "var(--balance-negative, #e74c3c)")
            .set("padding", "4px 12px")
            .set("border-radius", "8px");

        // Quick actions toolbar
        HorizontalLayout actions = new HorizontalLayout();
        actions.setWidthFull();
        actions.setJustifyContentMode(FlexComponent.JustifyContentMode.END);
        actions.setSpacing(false);
        actions.getStyle().set("gap", "var(--lumo-space-s)");

        Button viewButton = createActionButton(VaadinIcon.LIST, "View transactions",
            e -> onViewClicked(account));
        MenuBar menuBar = createMenuBar(account);

        actions.add(viewButton, menuBar);

        // Institution and account number
        if (account.getInstitution() != null && !account.getInstitution().isEmpty()) {
            Span institution = new Span(account.getInstitution());
            institution.getStyle()
                .set("color", "var(--institution-text, var(--lumo-secondary-text-color))")
                .set("font-size", "var(--lumo-font-size-s)");
            content.add(name, type, institution, balance, actions);
        } else {
            content.add(name, type, balance, actions);
        }

        if (account.getAccountNumber() != null && !account.getAccountNumber().isEmpty()) {
            Span accountNumber = new Span("****" + account.getAccountNumber());
            accountNumber.getStyle()
                .set("color", "var(--account-number-text, var(--lumo-tertiary-text-color))")
                .set("font-size", "var(--lumo-font-size-xs)");
            content.add(accountNumber);
        }

        add(content);

        // Apply theme styles for dark mode
        applyThemeStyles();
    }

    private Button createActionButton(VaadinIcon icon, String tooltip,
                                     ComponentEventListener<ClickEvent<Button>> listener) {
        Button button = new Button(new Icon(icon), listener);
        button.addThemeVariants(ButtonVariant.LUMO_TERTIARY, ButtonVariant.LUMO_SMALL);
        button.getStyle()
            .set("border-radius", "50%")
            .set("padding", "var(--lumo-space-s)")
            .set("background", "var(--button-bg, var(--lumo-contrast-5pct))")
            .set("transition", "background 0.2s");
        button.getElement().setAttribute("title", tooltip);
        button.getElement().addEventListener("mouseover", e ->
            button.getStyle().set("background", "var(--button-bg-hover, var(--lumo-contrast-10pct))")
        );
        button.getElement().addEventListener("mouseout", e ->
            button.getStyle().set("background", "var(--button-bg, var(--lumo-contrast-5pct))")
        );

        return button;
    }

    private MenuBar createMenuBar(Account account) {
        MenuBar menuBar = new MenuBar();
        menuBar.getStyle()
            .set("min-width", "var(--lumo-button-size)")
            .set("min-height", "var(--lumo-button-size)");
        MenuItem menuItem = menuBar.addItem(new Icon(VaadinIcon.ELLIPSIS_DOTS_V));
        menuItem.getStyle().set("padding", "var(--lumo-space-s)");
        SubMenu subMenu = menuItem.getSubMenu();
        subMenu.addItem("Edit", e -> showEditDialog(account));
        subMenu.addItem("Delete", e -> showDeleteDialog(account));
        return menuBar;
    }

    private void applyThemeStyles() {
        // Inject custom CSS to handle light/dark mode using the root html's theme attribute.
        UI.getCurrent().getPage().executeJs(
            "var style = document.createElement('style');" +
            "style.textContent = `" +
            "html[theme='dark'] .account-card {" +
            "  --card-background: linear-gradient(to bottom, #2d3748, #1a202c);" +
            "  --card-shadow: 0 4px 8px rgba(0,0,0,0.3);" +
            "  --card-shadow-hover: 0 6px 12px rgba(0,0,0,0.4);" +
            "  --type-bg: #4a5568;" +
            "  --type-text: #e2e8f0;" +
            "  --balance-positive: #48bb78;" +
            "  --balance-negative: #f56565;" +
            "  --balance-text: #ffffff;" +
            "  --institution-text: #a0aec0;" +
            "  --account-number-text: #718096;" +
            "  --button-bg: #4a5568;" +
            "  --button-bg-hover: #718096;" +
            "}`;" +
            "document.head.appendChild(style);"
        );
    }


    private void onViewClicked(Account account) {
        if (account.getId() != null) {
            UI.getCurrent().navigate(AccountView.class, account.getId());
        } else {
            Notification.show("Account not saved yet. Please save the account before viewing details.",
                3000, Notification.Position.MIDDLE);
        }
    }

    private void showEditDialog(Account account) {
        new AccountDialog(accountService, onModified, account).open();
    }

    private void showDeleteDialog(Account account) {
        ConfirmDialog dialog = new ConfirmDialog();
        dialog.setHeader("Delete Account");
        dialog.setText(
            "Are you sure you want to delete this account? " +
            "This will affect all transactions associated with it."
        );

        dialog.setCancelable(true);
        dialog.setConfirmText("Delete");
        dialog.setConfirmButtonTheme("error");

        dialog.addConfirmListener(event -> {
            try {
                accountService.deleteAccount(account.getId());
                onModified.run();
                Notification.show("Account deleted", 3000, Notification.Position.MIDDLE);
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error deleting account: " + ex.getMessage(),
                    3000, Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });

        dialog.open();
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/EnvelopeSchedulePanel.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.grid.Grid;
import org.emblow.envelopify.domain.RecurringTransaction;
import org.emblow.envelopify.domain.BillReminder;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.service.RecurringTransactionService;
import org.emblow.envelopify.service.BillReminderService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.AccountService;
import com.vaadin.flow.component.grid.contextmenu.GridContextMenu;
import java.time.format.DateTimeFormatter;
import java.util.List;

public class EnvelopeSchedulePanel extends VerticalLayout {
    private final RecurringTransactionService recurringTransactionService;
    private final BillReminderService billReminderService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final Grid<RecurringTransaction> recurringGrid;
    private final Grid<BillReminder> billGrid;
    private final Envelope envelope;

    public EnvelopeSchedulePanel(
        Envelope envelope,
        RecurringTransactionService recurringTransactionService,
        BillReminderService billReminderService,
        EnvelopeService envelopeService,
        AccountService accountService
    ) {
        this.envelope = envelope;
        this.recurringTransactionService = recurringTransactionService;
        this.billReminderService = billReminderService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;

        setPadding(true);
        setSpacing(true);

        // Recurring Transactions section
        H3 recurringTitle = new H3("Recurring Transactions");
        Button addRecurringButton = new Button(
            "Add Recurring",
            new Icon(VaadinIcon.PLUS),
            e -> showAddRecurringDialog()
        );
        addRecurringButton.addThemeVariants(ButtonVariant.LUMO_SUCCESS);

        recurringGrid = new Grid<>();
        configureRecurringGrid();
        
        // Bills section
        H3 billsTitle = new H3("Bills");
        Button addBillButton = new Button(
            "Add Bill",
            new Icon(VaadinIcon.PLUS),
            e -> showAddBillDialog()
        );
        addBillButton.addThemeVariants(ButtonVariant.LUMO_SUCCESS);

        billGrid = new Grid<>();
        configureBillGrid();

        add(
            recurringTitle,
            addRecurringButton,
            recurringGrid,
            billsTitle,
            addBillButton,
            billGrid
        );

        refreshData();
    }

    private void configureRecurringGrid() {
        recurringGrid.addColumn(RecurringTransaction::getDescription)
            .setHeader("Description")
            .setAutoWidth(true);
            
        recurringGrid.addColumn(tx -> 
            String.format("$%.2f", tx.getAmount()))
            .setHeader("Amount")
            .setAutoWidth(true);

        // Add account column
        recurringGrid.addColumn(tx -> 
            String.format("%s (%s)", 
                tx.getAccount().getName(),
                tx.getAccount().getType().getDisplayName()))
            .setHeader("Account")
            .setAutoWidth(true);
            
        recurringGrid.addColumn(tx -> tx.getPattern().toString())
            .setHeader("Pattern")
            .setAutoWidth(true);
            
        recurringGrid.addColumn(tx -> 
            tx.getNextDueDate().format(DateTimeFormatter.ofPattern("MM/dd/yyyy")))
            .setHeader("Next Due")
            .setAutoWidth(true);

        // Add edit/delete context menu
        GridContextMenu<RecurringTransaction> menu = new GridContextMenu<>(recurringGrid);
        menu.addItem("Edit", event -> {
            if (event.getItem().isPresent()) {
                showEditRecurringDialog(event.getItem().get());
            }
        });
        menu.addItem("Delete", event -> {
            if (event.getItem().isPresent()) {
                recurringTransactionService.delete(event.getItem().get().getId());
                refreshData();
            }
        });

        recurringGrid.setWidthFull();
    }

    private void configureBillGrid() {
        billGrid.addColumn(BillReminder::getDescription)
            .setHeader("Description")
            .setAutoWidth(true);
            
        billGrid.addColumn(bill -> 
            String.format("$%.2f", bill.getAmount()))
            .setHeader("Amount")
            .setAutoWidth(true);

        // Add account column
        billGrid.addColumn(bill -> 
            String.format("%s (%s)", 
                bill.getAccount().getName(),
                bill.getAccount().getType().getDisplayName()))
            .setHeader("Account")
            .setAutoWidth(true);
            
        billGrid.addColumn(bill -> 
            bill.getDueDate().format(DateTimeFormatter.ofPattern("MM/dd/yyyy")))
            .setHeader("Due Date")
            .setAutoWidth(true);
            
        billGrid.addColumn(BillReminder::isPaid)
            .setHeader("Paid")
            .setAutoWidth(true);

        // Add status color
        billGrid.setClassNameGenerator(bill -> {
            if (bill.isOverdue()) return "overdue";
            if (bill.needsReminder()) return "upcoming";
            if (bill.isPaid()) return "paid";
            return null;
        });

        // Add edit/delete context menu
        GridContextMenu<BillReminder> menu = new GridContextMenu<>(billGrid);
        menu.addItem("Edit", event -> {
            if (event.getItem().isPresent()) {
                showEditBillDialog(event.getItem().get());
            }
        });
        menu.addItem("Mark Paid", event -> {
            if (event.getItem().isPresent()) {
                billReminderService.markAsPaid(event.getItem().get().getId());
                refreshData();
            }
        });
        menu.addItem("Delete", event -> {
            if (event.getItem().isPresent()) {
                billReminderService.delete(event.getItem().get().getId());
                refreshData();
            }
        });

        billGrid.setWidthFull();
    }

    private void showAddRecurringDialog() {
        new RecurringTransactionDialog(
            recurringTransactionService,
            envelopeService,
            accountService,
            this::refreshData
        ).open();
    }

    private void showEditRecurringDialog(RecurringTransaction transaction) {
        new RecurringTransactionDialog(
            recurringTransactionService,
            envelopeService,
            accountService,
            this::refreshData,
            transaction
        ).open();
    }

    private void showAddBillDialog() {
        new BillReminderDialog(
            billReminderService,
            envelopeService,
            accountService,
            this::refreshData
        ).open();
    }

    private void showEditBillDialog(BillReminder bill) {
        new BillReminderDialog(
            billReminderService,
            envelopeService,
            accountService,
            this::refreshData,
            bill
        ).open();
    }

    private void refreshData() {
        List<RecurringTransaction> recurringTransactions = 
            recurringTransactionService.getAllForEnvelope(envelope.getId());
        recurringGrid.setItems(recurringTransactions);

        List<BillReminder> bills = 
            billReminderService.getAllForEnvelope(envelope.getId());
        billGrid.setItems(bills);
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/AccountBalanceChart.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.littemplate.LitTemplate;
import com.vaadin.flow.component.Tag;
import com.vaadin.flow.component.dependency.JsModule;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

@Tag("account-balance-chart")
@JsModule("./account-balance-chart.js")
public class AccountBalanceChart extends LitTemplate {

    private final Account account;

    public AccountBalanceChart(Account account) {
        this.account = account;
        // Set sizing via style
        getElement().getStyle().set("display", "block");
        getElement().getStyle().set("height", "400px");
        getElement().getStyle().set("width", "100%");
        refreshData();
    }

    public void refreshData() {
        // Get all transactions for this account in ascending order.
        List<Transaction> transactions = account.getTransactions().stream()
            .sorted(Comparator.comparing(Transaction::getDate))
            .collect(Collectors.toList());

        // We assume account.getBalance() returns the current balance (after all transactions).
        // To compute the balance history, we first compute the â€œinitial balanceâ€ before the first transaction.
        BigDecimal currentBalance = account.getBalance();
        BigDecimal totalEffect = transactions.stream()
            .map(tx -> tx.getType() == TransactionType.INCOME ? tx.getAmount() : tx.getAmount().negate())
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        // Thus, initialBalance = currentBalance - totalEffect.
        BigDecimal initialBalance = currentBalance.subtract(totalEffect);

        // Build lists for the date labels and balance values.
        List<LocalDate> dates = new ArrayList<>();
        List<BigDecimal> balances = new ArrayList<>();

        if (transactions.isEmpty()) {
            // If there are no transactions, simply use today's date and current balance.
            LocalDate today = LocalDate.now();
            dates.add(today);
            balances.add(currentBalance);
        } else {
            // Add an initial point at the date of the first transaction.
            LocalDate startDate = transactions.get(0).getDate().toLocalDate();
            dates.add(startDate);
            balances.add(initialBalance);
            BigDecimal runningBalance = initialBalance;
            for (Transaction tx : transactions) {
                LocalDate date = tx.getDate().toLocalDate();
                BigDecimal effect = tx.getType() == TransactionType.INCOME ? tx.getAmount() : tx.getAmount().negate();
                runningBalance = runningBalance.add(effect);
                dates.add(date);
                balances.add(runningBalance);
            }
        }

        // Build a JSON array for the labels (formatted dates).
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd");
        StringBuilder labels = new StringBuilder("[");
        for (int i = 0; i < dates.size(); i++) {
            if (i > 0) {
                labels.append(",");
            }
            labels.append("\"").append(dates.get(i).format(formatter)).append("\"");
        }
        labels.append("]");

        // Build a JSON array for the balance values.
        StringBuilder data = new StringBuilder("[");
        for (int i = 0; i < balances.size(); i++) {
            if (i > 0) {
                data.append(",");
            }
            data.append(balances.get(i).toPlainString());
        }
        data.append("]");

        // Pass the JSON arrays as properties to the client-side component.
        getElement().setProperty("labels", labels.toString());
        getElement().setProperty("data", data.toString());
    }
}
===== ./src/main/java/org/emblow/envelopify/ui/components/EnvelopeCard.java =====
/*
    Copyright (C) 2025 Nicholas J Emblow
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see http://www.gnu.org/licenses/.
*/
package org.emblow.envelopify.ui.components;

import com.vaadin.flow.component.ClickEvent;
import com.vaadin.flow.component.ComponentEventListener;
import com.vaadin.flow.component.UI;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.contextmenu.MenuItem;
import com.vaadin.flow.component.contextmenu.SubMenu;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.html.H4;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.menubar.MenuBar;
import com.vaadin.flow.component.orderedlayout.FlexComponent;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.progressbar.ProgressBar;
import org.emblow.envelopify.domain.Envelope;

import java.text.NumberFormat;
import java.util.Locale;

public class EnvelopeCard extends Div {
    private final NumberFormat currencyFormat = NumberFormat.getCurrencyInstance(Locale.US);
    private final EnvelopeManagementDialogs dialogs;

    public EnvelopeCard(Envelope envelope, EnvelopeManagementDialogs dialogs) {
        this.dialogs = dialogs;
        initializeCard(envelope);
    }

    private void initializeCard(Envelope envelope) {
        addClassName("envelope-card");

        // Base styles with theme-aware variables
        getStyle()
            .set("background", "var(--card-background, linear-gradient(to bottom, #f1f8e9, #ffffff))")
            .set("border", "1px solid var(--lumo-contrast-10pct)")
            .set("border-radius", "12px")
            .set("box-shadow", "var(--card-shadow, 0 4px 8px rgba(0,0,0,0.1))")
            .set("padding", "var(--lumo-space-l)")
            .set("max-width", "320px")
            .set("width", "100%")
            .set("transition", "transform 0.2s, box-shadow 0.2s");

        // Hover effect
        getElement().addEventListener("mouseenter", e ->
            getStyle()
                .set("transform", "scale(1.03)")
                .set("box-shadow", "var(--card-shadow-hover, 0 6px 12px rgba(0,0,0,0.15))")
        );
        getElement().addEventListener("mouseleave", e ->
            getStyle()
                .set("transform", "scale(1)")
                .set("box-shadow", "var(--card-shadow, 0 4px 8px rgba(0,0,0,0.1))")
        );

        VerticalLayout content = new VerticalLayout();
        content.setPadding(false);
        content.setSpacing(true);

        // Header with name
        H4 name = new H4(envelope.getName());
        name.getStyle()
            .set("margin", "0")
            .set("font-size", "1.2em")
            .set("color", "var(--lumo-primary-text-color)");

        // Balance information with badges
        HorizontalLayout balanceLayout = new HorizontalLayout();
        balanceLayout.setWidthFull();
        balanceLayout.setJustifyContentMode(FlexComponent.JustifyContentMode.BETWEEN);

        Span available = new Span(currencyFormat.format(envelope.getAvailable()));
        available.getStyle()
            .set("background", "var(--available-bg, #2ecc71)")
            .set("color", "var(--available-text, white)")
            .set("padding", "4px 10px")
            .set("border-radius", "8px")
            .set("font-size", "var(--lumo-font-size-s)");

        Span allocated = new Span(currencyFormat.format(envelope.getAllocated()));
        allocated.getStyle()
            .set("background", "var(--allocated-bg, var(--lumo-contrast-20pct))")
            .set("color", "var(--allocated-text, var(--lumo-secondary-text-color))")
            .set("padding", "4px 10px")
            .set("border-radius", "8px")
            .set("font-size", "var(--lumo-font-size-s)");

        balanceLayout.add(available, allocated);

        // Progress bar wrapper
        Div progressWrapper = new Div();
        progressWrapper.getStyle().set("position", "relative");
        progressWrapper.setWidthFull();

        ProgressBar progress = new ProgressBar();
        progress.setMin(0);
        progress.setMax(100);
        double spent = envelope.getSpentPercentage();
        progress.setValue(spent);
        progress.setWidthFull();

        // Dynamic progress bar color
        String progressColor = spent < 70 ? "var(--progress-low, #2ecc71)"
                            : spent < 90 ? "var(--progress-mid, #f39c12)"
                            : "var(--progress-high, #e74c3c)";
        progress.getStyle().set("--lumo-primary-color", progressColor); // Use Lumo variable for progress bar color

        Span progressLabel = new Span(String.format("%.0f%%", spent));
        progressLabel.getStyle()
            .set("position", "absolute")
            .set("top", "0")
            .set("right", "var(--lumo-space-m)")
            .set("color", "var(--progress-label-text, white)")
            .set("font-size", "var(--lumo-font-size-s)");

        progressWrapper.add(progress, progressLabel);

        // Quick actions toolbar
        HorizontalLayout actions = new HorizontalLayout();
        actions.setWidthFull();
        actions.setJustifyContentMode(FlexComponent.JustifyContentMode.END);
        actions.setSpacing(false);
        actions.getStyle().set("gap", "var(--lumo-space-s)");

        Button addButton = createActionButton(VaadinIcon.PLUS, "Add funds", "var(--add-button-bg, #2ecc71)",
            e -> onAddClicked(envelope));
        Button moveButton = createActionButton(VaadinIcon.EXCHANGE, "Move funds", "var(--move-button-bg, #3498db)",
            e -> onMoveClicked(envelope));
        Button historyButton = createActionButton(VaadinIcon.LIST, "View history", "var(--history-button-bg, #9b59b6)",
            e -> onHistoryClicked(envelope));
        MenuBar menuBar = createMenuBar(envelope);

        actions.add(addButton, moveButton, historyButton, menuBar);

        content.add(name, balanceLayout, progressWrapper, actions);
        add(content);

        // Apply CSS to handle theme switching
        applyThemeStyles();
    }

    private Button createActionButton(VaadinIcon icon, String tooltip, String color,
                                     ComponentEventListener<ClickEvent<Button>> listener) {
        Button button = new Button(new Icon(icon), listener);
        button.addThemeVariants(ButtonVariant.LUMO_TERTIARY, ButtonVariant.LUMO_SMALL);
        button.getStyle()
            .set("border-radius", "50%")
            .set("padding", "var(--lumo-space-s)")
            .set("background", color)
            .set("color", "var(--button-text, white)")
            .set("transition", "opacity 0.2s");
        button.getElement().addEventListener("mouseover", e ->
            button.getStyle().set("opacity", "0.9")
        );
        button.getElement().addEventListener("mouseout", e ->
            button.getStyle().set("opacity", "1")
        );

        return button;
    }

    private MenuBar createMenuBar(Envelope envelope) {
        MenuBar menuBar = new MenuBar();
        menuBar.getStyle()
            .set("min-width", "var(--lumo-button-size)")
            .set("min-height", "var(--lumo-button-size)");
        MenuItem menuItem = menuBar.addItem(new Icon(VaadinIcon.ELLIPSIS_DOTS_V));
        menuItem.getStyle().set("padding", "var(--lumo-space-s)");
        SubMenu subMenu = menuItem.getSubMenu();
        subMenu.addItem("Edit Name", e -> dialogs.showEditNameDialog(envelope, UI.getCurrent().getPage()::reload));
        subMenu.addItem("Budget Settings", e -> dialogs.showBudgetDialog(envelope, UI.getCurrent().getPage()::reload));
        subMenu.addItem("Delete", e -> dialogs.showDeleteEnvelopeDialog(envelope, UI.getCurrent().getPage()::reload));
        return menuBar;
    }

    private void applyThemeStyles() {
        // Inject custom CSS to handle light/dark mode using the root element's attribute.
        UI.getCurrent().getPage().executeJs(
            "var style = document.createElement('style');" +
            "style.textContent = `" +
            "html[theme='dark'] .envelope-card {" +
            "  --card-background: linear-gradient(to bottom, #2d3748, #1a202c);" +
            "  --card-shadow: 0 4px 8px rgba(0,0,0,0.3);" +
            "  --card-shadow-hover: 0 6px 12px rgba(0,0,0,0.4);" +
            "  --available-bg: #48bb78;" +
            "  --available-text: #ffffff;" +
            "  --allocated-bg: #4a5568;" +
            "  --allocated-text: #e2e8f0;" +
            "  --progress-low: #48bb78;" +
            "  --progress-mid: #ed8936;" +
            "  --progress-high: #f56565;" +
            "  --progress-label-text: #ffffff;" +
            "  --add-button-bg: #48bb78;" +
            "  --move-button-bg: #4299e1;" +
            "  --history-button-bg: #9f7aea;" +
            "  --button-text: #ffffff;" +
            "}" +
            "`;" +
            "document.head.appendChild(style);"
        );
    }


    private void onAddClicked(Envelope envelope) {
        dialogs.showAddFundsDialog(envelope, () -> UI.getCurrent().getPage().reload());
    }

    private void onMoveClicked(Envelope envelope) {
        dialogs.showMoveFundsDialog(envelope, () -> UI.getCurrent().getPage().reload());
    }

    private void onHistoryClicked(Envelope envelope) {
        UI.getCurrent().navigate("envelopes/" + envelope.getId());
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/ChatComponent.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.grid.Grid;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.Key;
import com.vaadin.flow.component.UI;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.spring.annotation.SpringComponent;
import com.vaadin.flow.spring.annotation.UIScope;
import org.emblow.envelopify.domain.ChatSession;
import org.emblow.envelopify.domain.ChatMessage;
import org.emblow.envelopify.service.llm.LLMService;
import org.emblow.envelopify.service.ChatHistoryService;
import com.vladsch.flexmark.parser.Parser;
import com.vladsch.flexmark.html.HtmlRenderer;
import org.springframework.security.concurrent.DelegatingSecurityContextRunnable;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.emblow.envelopify.ui.components.DataTable;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.emblow.envelopify.domain.ChartArtifact;
import org.emblow.envelopify.exception.BusinessException;
import org.emblow.envelopify.repository.ChartArtifactRepository;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;

/**
 * A Vaadin component for handling chat interactions with an LLM service,
 * including streaming responses, rendering markdown, charts, and tables.
 */
@SpringComponent
@UIScope
public class ChatComponent extends VerticalLayout {
    private final LLMService llmService;
    private final ChatHistoryService chatHistoryService;
    private final VerticalLayout messagesLayout;
    private final VerticalLayout dataLayout;
    private final TextField inputField;
    private final Button sendButton;
    private final ComboBox<ChatSession> sessionSelector;
    private final Parser markdownParser = Parser.builder().build();
    private final HtmlRenderer htmlRenderer = HtmlRenderer.builder().build();
    private final ObjectMapper objectMapper = new ObjectMapper();
    private ChatSession currentSession;
    private Div currentAssistantMessage;
    private StringBuilder streamedResponse;
    private static final Pattern JSON_PATTERN = Pattern.compile("\\{.*\\}", Pattern.DOTALL);
    private int retryCount = 0;
    private static final int MAX_RETRIES = 2;
    private boolean isRetrying = false;
    private static final int MAX_TEXT_LENGTH = 4000;
    private static final int MAX_RESPONSE_SIZE = 1_000_000; // 1MB
    private ChartArtifactRepository chartArtifactRepository;

    public ChatComponent(LLMService llmService, ChatHistoryService chatHistoryService, ChartArtifactRepository chartArtifactRepository) {
        this.llmService = llmService;
        this.chatHistoryService = chatHistoryService;
        this.chartArtifactRepository = chartArtifactRepository;
        // Set up component styling (unchanged)
        setHeightFull();
        setWidth("100%");
        addClassName("chat-component");
        getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("box-shadow", "var(--lumo-box-shadow-m)");

        HorizontalLayout mainLayout = new HorizontalLayout();
        mainLayout.setHeightFull();
        mainLayout.setWidthFull();
        mainLayout.setSpacing(true);

        VerticalLayout chatContainer = new VerticalLayout();
        chatContainer.setHeightFull();
        chatContainer.setWidth("30%");

        HorizontalLayout sessionControls = new HorizontalLayout();
        sessionControls.setWidthFull();
        sessionControls.setJustifyContentMode(JustifyContentMode.BETWEEN);

        sessionSelector = new ComboBox<>("Chat Sessions");
        sessionSelector.setItems(chatHistoryService.getUserSessions());
        sessionSelector.setItemLabelGenerator(session ->
            session.getTitle() + " (" + session.getCreatedAt().format(DateTimeFormatter.ofPattern("MM/dd/yyyy")) + ")");
        sessionSelector.addValueChangeListener(e -> loadSession(e.getValue()));

        Button newChatButton = new Button("New Chat", new Icon(VaadinIcon.PLUS),
            e -> createNewSession());
        newChatButton.addThemeVariants(ButtonVariant.LUMO_SUCCESS);

        sessionControls.add(sessionSelector, newChatButton);

        messagesLayout = new VerticalLayout();
        messagesLayout.setSpacing(true);
        messagesLayout.setPadding(true);
        messagesLayout.setHeightFull();
        messagesLayout.getStyle()
            .set("overflow-y", "auto")
            .set("flex-grow", "1");

        HorizontalLayout inputLayout = new HorizontalLayout();
        inputLayout.setWidthFull();
        inputLayout.setPadding(true);
        inputLayout.setSpacing(true);
        inputLayout.setAlignItems(Alignment.CENTER);
        inputLayout.getStyle()
            .set("background-color", "var(--lumo-contrast-5pct)")
            .set("border-radius", "var(--lumo-border-radius-l)");

        inputField = new TextField();
        inputField.setWidthFull();
        inputField.setPlaceholder("Ask about your finances...");
        inputField.addKeyPressListener(Key.ENTER, e -> handleSend());

        sendButton = new Button(new Icon(VaadinIcon.PAPERPLANE));
        sendButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        sendButton.addClickListener(e -> handleSend());

        inputLayout.add(inputField, sendButton);
        inputLayout.setFlexGrow(1, inputField);

        chatContainer.add(sessionControls, messagesLayout, inputLayout);
        chatContainer.setFlexGrow(1, messagesLayout);

        dataLayout = new VerticalLayout();
        dataLayout.setHeightFull();
        dataLayout.setWidth("70%");
        dataLayout.getStyle()
            .set("background-color", "var(--lumo-contrast-5pct)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("padding", "var(--lumo-space-m)")
            .set("overflow-y", "auto");

        mainLayout.add(dataLayout, chatContainer);
        add(mainLayout);

        List<ChatSession> sessions = chatHistoryService.getUserSessions();
        if (!sessions.isEmpty()) {
            sessionSelector.setValue(sessions.get(0));
        } else {
            createNewSession();
        }

        getUI().ifPresent(ui -> ui.getPage().executeJs(
            "if (typeof Chart === 'undefined') {" +
            "  var script = document.createElement('script');" +
            "  script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.js';" +
            "  script.onload = function() { console.log('Chart.js loaded'); };" +
            "  script.onerror = function() { console.error('Failed to load Chart.js'); };" +
            "  document.head.appendChild(script);" +
            "}"
        ));
    }

    private void createNewSession() {
        ChatSession newSession = chatHistoryService.createNewSession("Chat " +
            LocalDateTime.now().format(DateTimeFormatter.ofPattern("MM/dd HH:mm")));
        sessionSelector.setItems(chatHistoryService.getUserSessions());
        sessionSelector.setValue(newSession);
    }

    private void loadSession(ChatSession session) {
        if (session == null) return;
        currentSession = session;
        messagesLayout.removeAll();
        dataLayout.removeAll();

        List<ChatMessage> messages = chatHistoryService.getSessionMessages(session.getId());
        for (ChatMessage msg : messages) {
            addMessage(msg.getContent(), msg.getRole().equals("user"));
        }

        loadSavedCharts(session);
    }

    private void handleSend() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        retryCount = 0;
        isRetrying = false;

        String rawMessage = inputField.getValue().trim();
        String message = sanitizeInput(rawMessage);
        if (message.isEmpty()) return;

        System.out.println("Starting handleSend with message: " + message);

        addMessage(message, true);
        chatHistoryService.addMessage(currentSession.getId(), "user", message);
        inputField.clear();
        setInputEnabled(false);

        Div thinkingIndicator = new Div();
        thinkingIndicator.addClassName("thinking-indicator");
        thinkingIndicator.getStyle()
            .set("background-color", "var(--lumo-contrast-5pct)")
            .set("color", "var(--lumo-body-text-color)")
            .set("padding", "var(--lumo-space-m)")
            .set("border-radius", "var(--lumo-border-radius-m)")
            .set("max-width", "80%")
            .set("margin", "0 auto var(--lumo-space-m) 0")
            .set("display", "flex")
            .set("align-items", "center")
            .set("gap", "var(--lumo-space-s)");
        
        Icon spinner = VaadinIcon.SPINNER.create();
        spinner.getStyle().set("animation", "spin 2s infinite linear");
        thinkingIndicator.add(spinner, new Span("Thinking..."));
        messagesLayout.add(thinkingIndicator);

        UI.getCurrent().getPage().addStyleSheet(
            "data:text/css," + 
            "@keyframes spin {" +
            "  from { transform: rotate(0deg); }" +
            "  to { transform: rotate(360deg); }" +
            "}"
        );

        streamedResponse = new StringBuilder();
        currentAssistantMessage = new Div();
        currentAssistantMessage.addClassName("assistant-message");
        currentAssistantMessage.getStyle()
            .set("background-color", "var(--lumo-contrast-5pct)")
            .set("color", "var(--lumo-body-text-color)")
            .set("padding", "var(--lumo-space-m)")
            .set("border-radius", "var(--lumo-border-radius-m)")
            .set("max-width", "80%")
            .set("margin", "0 auto var(--lumo-space-m) 0");

        Runnable task = () -> {
            try {
                System.out.println("Starting LLM query...");
                SecurityContextHolder.getContext().setAuthentication(authentication);

                llmService.streamUserQuery(message)
                    .contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication))
                    .subscribe(
                        chunk -> {
                            System.out.println("Received chunk: " + chunk);
                            getUI().ifPresent(ui -> ui.access(() -> {
                                streamedResponse.append(chunk);
                                processStreamedChunk(chunk);
                            }));
                        },
                        error -> {
                            System.out.println("Stream error: " + error.getMessage());
                            error.printStackTrace();
                            getUI().ifPresent(ui -> ui.access(() -> {
                                messagesLayout.remove(thinkingIndicator);
                                Notification.show("Error: " + error.getMessage(), 3000, Notification.Position.MIDDLE);
                                setInputEnabled(true);
                            }));
                        },
                        () -> {
                            System.out.println("Stream completed");
                            getUI().ifPresent(ui -> ui.access(() -> {
                                messagesLayout.remove(thinkingIndicator);
                                messagesLayout.add(currentAssistantMessage);
                                finalizeStreamedMessage(authentication);
                                setInputEnabled(true);
                            }));
                        }
                    );
            } catch (Exception e) {
                System.out.println("Task execution error: " + e.getMessage());
                e.printStackTrace();
                getUI().ifPresent(ui -> ui.access(() -> {
                    messagesLayout.remove(thinkingIndicator);
                    Notification.show("Unexpected error: " + e.getMessage(), 3000, Notification.Position.MIDDLE);
                    setInputEnabled(true);
                }));
            }
        };

        CompletableFuture.runAsync(new DelegatingSecurityContextRunnable(task));
    }

  private void processStreamedChunk(String chunk) {
    if (streamedResponse.length() > MAX_RESPONSE_SIZE) {
        Notification.show("Response too large. Please try a different query.", 
            3000, Notification.Position.MIDDLE);
        return;
    }
    streamedResponse.append(chunk);
}

    private void processFullResponse() {
      if (streamedResponse.length() > MAX_RESPONSE_SIZE) {
          Notification.show("Response too large. Please try a different query.", 
              3000, Notification.Position.MIDDLE);
          return;
      }

      String responseText = streamedResponse.toString();
      currentAssistantMessage.removeAll();

      Matcher matcher = JSON_PATTERN.matcher(responseText);
      if (matcher.find()) {
          String jsonPart = matcher.group();
          String beforeJson = responseText.substring(0, matcher.start()).trim();
          String afterJson = responseText.substring(matcher.end()).trim();

          StringBuilder fullText = new StringBuilder();
          if (!beforeJson.isEmpty()) {
              fullText.append(beforeJson).append("\n\n");
          }

          try {
              JsonNode response = objectMapper.readTree(jsonPart);
              String innerText = response.has("text") ? response.get("text").asText() : "";
              if (!innerText.isEmpty()) {
                  fullText.append(innerText);
              }
              if (!afterJson.isEmpty()) {
                  fullText.append("\n\n").append(afterJson);
              }

              String html = htmlRenderer.render(markdownParser.parse(fullText.toString()));
              html = html.replaceAll("(?s)<think>.*?</think>", "");
              currentAssistantMessage.getElement().setProperty("innerHTML", html);

              List<String> chartDataList = new ArrayList<>();
              if (response.has("charts") && response.get("charts").isArray()) {
                  ArrayNode charts = (ArrayNode) response.get("charts");
                  for (JsonNode chartNode : charts) {
                      chartDataList.add(chartNode.toString());
                      dataLayout.add(renderChart(chartNode));
                  }
              }

              if (response.has("tables") && response.get("tables").isArray()) {
                  ArrayNode tables = (ArrayNode) response.get("tables");
                  for (JsonNode tableNode : tables) {
                      dataLayout.add(DataTable.createFromJson(tableNode));
                  }
              }

              chatHistoryService.addMessageWithCharts(
                  currentSession.getId(),
                  "assistant",
                  fullText.toString(),
                  chartDataList
              );

          } catch (JsonProcessingException e) {
              throw new BusinessException(
                  "CHART_PROCESSING_ERROR",
                  "Failed to process chart data: " + e.getMessage()
              );
          }
      } else {
          String html = htmlRenderer.render(markdownParser.parse(responseText));
          html = html.replaceAll("(?s)<think>.*?</think>", "");
          currentAssistantMessage.getElement().setProperty("innerHTML", html);
          chatHistoryService.addMessage(currentSession.getId(), "assistant", responseText);
      }
  }

    private void handleJsonError(Exception e, String invalidJson) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (isRetrying || retryCount >= MAX_RETRIES) {
            Notification.show("Failed to fix JSON after retries. Please try again.", 3000, Notification.Position.MIDDLE);
            setInputEnabled(true);
            return;
        }

        isRetrying = true;
        streamedResponse = new StringBuilder();

        String errorMessage = "The previous response had invalid JSON: " + e.getMessage() + ". Please provide a corrected version:\n" + invalidJson;
        retryCount++;

        Notification.show("Correcting JSON response...", 1000, Notification.Position.BOTTOM_END);

        llmService.streamUserQuery(errorMessage)
            .subscribe(
                chunk -> getUI().ifPresent(ui -> ui.access(() -> {
                    streamedResponse.append(chunk);
                    processStreamedChunk(chunk);
                })),
                error -> getUI().ifPresent(ui -> ui.access(() -> {
                    System.out.println("Retry error: " + error.getMessage());
                    Notification.show("Retry failed: " + error.getMessage(), 3000, Notification.Position.MIDDLE);
                    setInputEnabled(true);
                    isRetrying = false;
                })),
                () -> getUI().ifPresent(ui -> ui.access(() -> {
                    System.out.println("Retry stream completed");
                    finalizeStreamedMessage(authentication);
                    setInputEnabled(true);
                    isRetrying = false;
                }))
            );
    }

 private void finalizeStreamedMessage(Authentication authentication) {
    SecurityContextHolder.getContext().setAuthentication(authentication);
    if (streamedResponse.length() > 0) {
        processFullResponse();
    }
    retryCount = 0;
    currentAssistantMessage = null;
    streamedResponse = null;
}

    private void addMessage(String text, boolean isUser) {
        Div messageDiv = new Div();
        messageDiv.addClassName(isUser ? "user-message" : "assistant-message");
        messageDiv.getStyle()
            .set("background-color", isUser ? "var(--lumo-primary-color)" : "var(--lumo-contrast-5pct)")
            .set("color", isUser ? "var(--lumo-primary-contrast-color)" : "var(--lumo-body-text-color)")
            .set("padding", "var(--lumo-space-m)")
            .set("border-radius", "var(--lumo-border-radius-m)")
            .set("max-width", "80%")
            .set("margin", isUser ? "0 0 var(--lumo-space-m) auto" : "0 auto var(--lumo-space-m) 0");

        if (isUser) {
            messageDiv.setText(text);
        } else {
            Matcher matcher = JSON_PATTERN.matcher(text);
            if (matcher.find()) {
                String jsonPart = matcher.group();
                String beforeJson = text.substring(0, matcher.start()).trim();
                String afterJson = text.substring(matcher.end()).trim();

                StringBuilder fullText = new StringBuilder();
                if (!beforeJson.isEmpty()) {
                    fullText.append(beforeJson).append("\n\n");
                }

                try {
                    JsonNode response = objectMapper.readTree(jsonPart);
                    String innerText = response.has("text") ? response.get("text").asText() : "";
                    if (!innerText.isEmpty()) {
                        fullText.append(innerText);
                    }

                    if (!afterJson.isEmpty()) {
                        fullText.append("\n\n").append(afterJson);
                    }

                    String html = htmlRenderer.render(markdownParser.parse(fullText.toString()));
                    html = html.replaceAll("(?s)<think>.*?</think>", "");
                    messageDiv.getElement().setProperty("innerHTML", html);

                    if (response.has("charts") && response.get("charts").isArray()) {
                        for (JsonNode chartNode : response.get("charts")) {
                            dataLayout.add(renderChart(chartNode));
                        }
                    }

                    if (response.has("tables") && response.get("tables").isArray()) {
                        for (JsonNode tableNode : response.get("tables")) {
                            dataLayout.add(renderTable(tableNode));
                        }
                    }
                } catch (Exception e) {
                    System.out.println("Failed to parse JSON in addMessage: " + e.getMessage());
                    String html = htmlRenderer.render(markdownParser.parse(fullText.toString()));
                    html = html.replaceAll("(?s)<think>.*?</think>", "");
                    messageDiv.getElement().setProperty("innerHTML", html);
                }
            } else {
                String html = htmlRenderer.render(markdownParser.parse(text));
                html = html.replaceAll("(?s)<think>.*?</think>", "");
                messageDiv.getElement().setProperty("innerHTML", html);
            }
        }

        messagesLayout.add(messageDiv);
        messagesLayout.getElement().executeJs("this.scrollTop = this.scrollHeight;");
    }

    private Div renderChart(JsonNode chartNode) {
        Div chartDiv = new Div();
        String chartId = "chart-" + UUID.randomUUID().toString();
        chartDiv.getElement().setAttribute("id", chartId);
        chartDiv.setHeight("300px");
        chartDiv.getStyle().set("width", "100%");

        chartDiv.getElement().setProperty("innerHTML", "<canvas></canvas>");

        String type = chartNode.has("type") ? chartNode.get("type").asText() : "bar";
        String title = chartNode.has("title") ? chartNode.get("title").asText() : "Chart";
        JsonNode dataNode = chartNode.has("data") ? chartNode.get("data") : null;

        StringBuilder jsCode = new StringBuilder();
        jsCode.append("if (typeof Chart === 'undefined') { console.error('Chart.js not loaded'); return; }");
        jsCode.append("var ctx = document.getElementById('").append(chartId).append("').querySelector('canvas');");
        jsCode.append("if (!ctx) { console.error('Canvas not found for ").append(chartId).append("'); return; }");
        jsCode.append("new Chart(ctx, {");
        jsCode.append("  type: '").append(type).append("',");
        jsCode.append("  data: ");
        try {
            jsCode.append(objectMapper.writeValueAsString(dataNode)).append(",");
        } catch (JsonProcessingException e) {
            jsCode.append("{ labels: [], datasets: [] },");
            System.out.println("Error serializing chart data: " + e.getMessage());
        }
        jsCode.append("  options: {");
        jsCode.append("    responsive: true,");
        jsCode.append("    maintainAspectRatio: false,");
        jsCode.append("    plugins: {");
        jsCode.append("      title: { display: true, text: '").append(title).append("' }");
        jsCode.append("    }");
        jsCode.append("  }");
        jsCode.append("});");

        chartDiv.getElement().executeJs(jsCode.toString());
        return chartDiv;
    }

    private Grid<Map<String, String>> renderTable(JsonNode tableNode) {
        Grid<Map<String, String>> grid = new Grid<>();
        List<Map<String, String>> rows = new ArrayList<>();

        JsonNode headersNode = tableNode.has("headers") ? tableNode.get("headers") : null;
        List<String> headers = new ArrayList<>();
        if (headersNode != null && headersNode.isArray()) {
            for (JsonNode header : headersNode) {
                headers.add(header.asText());
            }
            grid.setColumns(headers.toArray(String[]::new));
            grid.getColumns().forEach(column -> column.setKey(column.getKey()).setAutoWidth(true));
        }

        JsonNode rowsNode = tableNode.has("rows") ? tableNode.get("rows") : null;
        if (rowsNode != null && rowsNode.isArray()) {
            for (JsonNode row : rowsNode) {
                Map<String, String> rowData = new HashMap<>();
                if (row.isArray() && headers.size() == row.size()) {
                    for (int i = 0; i < headers.size(); i++) {
                        rowData.put(headers.get(i), row.get(i).asText());
                    }
                }
                rows.add(rowData);
            }
        }

        grid.setItems(rows);
        grid.setHeight("200px");
        grid.getStyle()
            .set("max-width", "100%")
            .set("overflow", "auto")
            .set("border", "1px solid var(--lumo-contrast-10pct)");
        return grid;
    }

    private void setInputEnabled(boolean enabled) {
        inputField.setEnabled(enabled);
        sendButton.setEnabled(enabled);
    }

    private void loadSavedCharts(ChatSession session) {
        try {
            List<ChartArtifact> charts = chatHistoryService.getChartsForSession(session);
            for (ChartArtifact chart : charts) {
                try {
                    JsonNode chartNode = objectMapper.readTree(chart.getChartData());
                    dataLayout.add(renderChart(chartNode));
                } catch (JsonProcessingException e) {
                    throw new BusinessException(
                        "CHART_PARSE_ERROR",
                        "Failed to parse saved chart data: " + e.getMessage()
                    );
                }
            }
        } catch (BusinessException e) {
            e.printStackTrace();
            Notification.show("Could not load saved charts", 3000, Notification.Position.MIDDLE);
        }
    }

    private String sanitizeInput(String input) {
        return input.replaceAll("<[^>]*>", "");
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/SpendingCategoryChart.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

import com.vaadin.flow.component.Tag;
import com.vaadin.flow.component.dependency.JsModule;
import com.vaadin.flow.component.littemplate.LitTemplate;
import elemental.json.Json;
import elemental.json.JsonArray;
import elemental.json.JsonObject;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;

@Tag("spending-category-chart")
@JsModule("./spending-category-chart.js")
public class SpendingCategoryChart extends LitTemplate {
    private final Account account;

    public SpendingCategoryChart(Account account) {
        this.account = account;
        refreshData();
    }

    public void refreshData() {
        // Group transactions by envelope and calculate totals
        Map<String, BigDecimal> spendingByCategory = account.getTransactions().stream()
            .filter(tx -> tx.getType() == TransactionType.EXPENSE)
            .filter(tx -> tx.getDate().isAfter(LocalDateTime.now().minusMonths(1)))
            .collect(Collectors.groupingBy(
                tx -> tx.getEnvelope().getName(),
                Collectors.reducing(
                    BigDecimal.ZERO,
                    Transaction::getAmount,
                    BigDecimal::add
                )
            ));

        // Convert to lists for chart data
        List<String> labels = new ArrayList<>(spendingByCategory.keySet());
        List<BigDecimal> values = labels.stream()
            .map(spendingByCategory::get)
            .collect(Collectors.toList());

        // Generate colors for pie slices
        List<String> colors = generateColors(labels.size());

        // Create dataset object
        JsonObject dataset = Json.createObject();
        dataset.put("data", convertToJsonArray(values));
        dataset.put("backgroundColor", convertToJsonArray(colors));

        JsonArray datasets = Json.createArray();
        datasets.set(0, dataset);

        // Create data object
        JsonObject data = Json.createObject();
        data.put("labels", convertToJsonArray(labels));
        data.put("datasets", datasets);

        // Set chartData to the data object directly
        getElement().setProperty("chartData", data.toJson());
    }

    private List<String> generateColors(int count) {
        List<String> colors = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            double hue = (360.0 / count) * i;
            colors.add(String.format("hsla(%f, 70%%, 60%%, 0.8)", hue));
        }
        return colors;
    }

    private JsonArray convertToJsonArray(List<?> list) {
        JsonArray array = Json.createArray();
        for (int i = 0; i < list.size(); i++) {
            Object value = list.get(i);
            if (value instanceof BigDecimal) {
                array.set(i, ((BigDecimal) value).doubleValue());
            } else {
                array.set(i, value.toString());
            }
        }
        return array;
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/BillReminderDialog.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.datepicker.DatePicker;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.textfield.BigDecimalField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.textfield.IntegerField;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import org.emblow.envelopify.domain.BillReminder;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.BillReminderService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.AccountService;

import java.math.BigDecimal;
import java.time.LocalDate;

public class BillReminderDialog extends Dialog {
    private final BillReminderService billReminderService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final Runnable onSuccess;
    private final BillReminder existingBill;

    public BillReminderDialog(
        BillReminderService billReminderService,
        EnvelopeService envelopeService,
        AccountService accountService,
        Runnable onSuccess
    ) {
        this(billReminderService, envelopeService, accountService, onSuccess, null);
    }

    public BillReminderDialog(
        BillReminderService billReminderService,
        EnvelopeService envelopeService,
        AccountService accountService,
        Runnable onSuccess,
        BillReminder existingBill
    ) {
        this.billReminderService = billReminderService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.onSuccess = onSuccess;
        this.existingBill = existingBill;

        setModal(true);
        setDraggable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);

        H3 title = new H3(existingBill == null ? "New Bill Reminder" : "Edit Bill Reminder");

        TextField descriptionField = new TextField("Description");
        descriptionField.setRequired(true);
        descriptionField.setWidthFull();

        BigDecimalField amountField = new BigDecimalField("Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setWidthFull();

        DatePicker dueDateField = new DatePicker("Due Date");
        dueDateField.setRequired(true);
        dueDateField.setMin(LocalDate.now());

        IntegerField reminderDaysField = new IntegerField("Reminder Days Before");
        reminderDaysField.setValue(7);
        reminderDaysField.setMin(0);
        reminderDaysField.setMax(60);
        reminderDaysField.setStep(1);

        // Account selector
        ComboBox<Account> accountField = new ComboBox<>("Account");
        accountField.setItemLabelGenerator(account -> 
            String.format("%s (%s) - Balance: $%.2f", 
                account.getName(),
                account.getType().getDisplayName(),
                account.getBalance()
            )
        );
        accountField.setItems(accountService.getAllAccounts());
        accountField.setRequired(true);
        accountField.setWidthFull();

        ComboBox<Envelope> envelopeField = new ComboBox<>("Envelope");
        envelopeField.setItemLabelGenerator(env -> 
            String.format("%s - Available: $%.2f", 
                env.getName(),
                env.getAvailable()
            )
        );
        envelopeField.setItems(envelopeService.getAllEnvelopes());
        envelopeField.setRequired(true);

        // Set existing values if editing
        if (existingBill != null) {
            descriptionField.setValue(existingBill.getDescription());
            amountField.setValue(existingBill.getAmount());
            dueDateField.setValue(existingBill.getDueDate());
            reminderDaysField.setValue(existingBill.getReminderDays());
            accountField.setValue(existingBill.getAccount());
            envelopeField.setValue(existingBill.getEnvelope());
        }

        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> close());

        Button saveButton = new Button(existingBill == null ? "Create" : "Save", e -> {
            try {
                String description = descriptionField.getValue();
                BigDecimal amount = amountField.getValue();
                LocalDate dueDate = dueDateField.getValue();
                int reminderDays = reminderDaysField.getValue();
                Account account = accountField.getValue();
                Envelope envelope = envelopeField.getValue();

                // Validation
                if (description == null || description.trim().isEmpty()) {
                    throw new IllegalArgumentException("Please enter a description");
                }
                if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                    throw new IllegalArgumentException("Please enter a valid amount");
                }
                if (dueDate == null) {
                    throw new IllegalArgumentException("Please select a due date");
                }
                if (account == null) {
                    throw new IllegalArgumentException("Please select an account");
                }
                if (envelope == null) {
                    throw new IllegalArgumentException("Please select an envelope");
                }

                BillReminder reminder = existingBill != null ? existingBill : new BillReminder();
                reminder.setDescription(description.trim());
                reminder.setAmount(amount);
                reminder.setDueDate(dueDate);
                reminder.setReminderDays(reminderDays);
                reminder.setAccount(account);
                reminder.setEnvelope(envelope);
                reminder.setPaid(false);

                if (existingBill != null) {
                    billReminderService.update(existingBill.getId(), reminder);
                } else {
                    billReminderService.create(reminder);
                }

                close();
                onSuccess.run();
                
                Notification.show(
                    existingBill == null ? "Bill reminder created" : "Bill reminder updated",
                    3000,
                    Notification.Position.MIDDLE
                );

            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        buttons.add(cancelButton, saveButton);
        layout.add(title, descriptionField, amountField, dueDateField, 
                  reminderDaysField, accountField, envelopeField, buttons);
        add(layout);
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/MLInsightsTable.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.grid.Grid;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.html.H3;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.service.ml.SpendingInsight;
import org.emblow.envelopify.service.ml.SpendingInsightService;

import java.util.List;
import java.util.stream.Collectors;

public class MLInsightsTable extends VerticalLayout {
    
    private final SpendingInsightService insightService;
    private final String envelopeName;
    private final Grid<SpendingInsight> grid;

    public MLInsightsTable(SpendingInsightService insightService, Envelope envelope) {
        this.insightService = insightService;
        this.envelopeName = envelope.getName();
        
        setPadding(true);
        setSpacing(true);
        
        add(new H3("ML-Generated Insights"));
        
        // Initialize grid
        grid = new Grid<>();
        grid.addColumn(insight -> insight.getType().toString())
            .setHeader("Type")
            .setAutoWidth(true);
            
        grid.addColumn(SpendingInsight::getMessage)
            .setHeader("Description")
            .setAutoWidth(true)
            .setFlexGrow(1);
            
        grid.addColumn(insight -> String.format("%.0f%%", insight.getConfidence() * 100))
            .setHeader("Confidence")
            .setAutoWidth(true);
            
        grid.setWidthFull();
        
        add(grid);
        refreshData();
    }

    public void refreshData() {
        // Get insights relevant to this envelope
        List<SpendingInsight> insights = insightService.generateInsights().stream()
            .filter(insight -> insight.getMessage().contains(envelopeName))
            .collect(Collectors.toList());
            
        grid.setItems(insights);
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/EnvelopeSuggestions.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.service.PatternService;

import java.util.Map;

public class EnvelopeSuggestions extends HorizontalLayout {
    private final ComboBox<Envelope> envelopeField;
    private final PatternService patternService;

    public EnvelopeSuggestions(
        ComboBox<Envelope> envelopeField,
        PatternService patternService
    ) {
        this.envelopeField = envelopeField;
        this.patternService = patternService;
        
        setSpacing(true);
        setAlignItems(Alignment.CENTER);
        setVisible(false);
    }

    public void updateSuggestions(Transaction transaction) {
        removeAll();
        
        if (transaction.getDescription() == null || transaction.getDescription().trim().isEmpty()) {
            setVisible(false);
            return;
        }

        Map<Envelope, Double> suggestions = patternService.suggestEnvelopes(transaction);
        if (!suggestions.isEmpty()) {
            setVisible(true);
            
            add(new Span("Suggested: "));
            
            suggestions.entrySet().stream()
                .sorted((e1, e2) -> e2.getValue().compareTo(e1.getValue()))
                .limit(3)  // Show top 3 suggestions
                .forEach(entry -> {
                    Button suggestionButton = new Button(
                        entry.getKey().getName(),
                        click -> envelopeField.setValue(entry.getKey())
                    );
                    suggestionButton.addThemeVariants(ButtonVariant.LUMO_SMALL);
                    add(suggestionButton);
                });
        } else {
            setVisible(false);
        }
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/MLSpendingPredictionChart.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.littemplate.LitTemplate;
import com.vaadin.flow.component.Tag;
import com.vaadin.flow.component.dependency.JsModule;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.service.ml.AdvancedMLService;

import java.time.YearMonth;
import java.util.List;
import java.util.ArrayList;

@Tag("ml-spending-prediction-chart")
@JsModule("./ml-spending-prediction-chart.js")
@AnonymousAllowed
public class MLSpendingPredictionChart extends LitTemplate {
    
    private final AdvancedMLService advancedMLService;
    private final Envelope envelope;

    public MLSpendingPredictionChart(AdvancedMLService advancedMLService, Envelope envelope) {
        this.advancedMLService = advancedMLService;
        this.envelope = envelope;
        
        // Set sizing via style
        getElement().getStyle().set("display", "block");
        getElement().getStyle().set("height", "400px");
        getElement().getStyle().set("width", "100%");
        
        refreshData();
    }

    private void refreshData() {
        // Get forecast data for the next 6 months
        List<AdvancedMLService.AccountAnalysis> analyses = advancedMLService.analyzeAccounts();

        // Find the relevant analysis for this envelope
        double trend = analyses.stream()
            .flatMap(a -> a.getEnvelopeMetrics().entrySet().stream())
            .filter(e -> e.getKey().getId().equals(envelope.getId()))
            .findFirst()
            .map(e -> e.getValue().spendingTrend())
            .orElse(0.0);

        // Build labels and data arrays using valid JSON (double quotes for strings)
        StringBuilder labels = new StringBuilder("[");
        StringBuilder data = new StringBuilder("[");

        YearMonth current = YearMonth.now().plusMonths(1);
        double baseAmount = envelope.getCurrentMonthSpent().doubleValue();
        if (baseAmount == 0) {
            baseAmount = envelope.getMonthlyBudget().doubleValue();
        }

        for (int i = 0; i < 6; i++) {
            if (i > 0) {
                labels.append(",");
                data.append(",");
            }

            // Use double quotes for JSON string values
            labels.append("\"")
                  .append(current.getMonth().name().substring(0, 3))
                  .append(" ").append(current.getYear())
                  .append("\"");

            // Calculate predicted amount using the trend
            double predicted = baseAmount * (1 + (trend * (i + 1)));
            data.append(String.format("%.2f", predicted));

            current = current.plusMonths(1);
        }

        labels.append("]");
        data.append("]");

        // Update the chart
        getElement().setProperty("labels", labels.toString());
        getElement().setProperty("data", data.toString());
    }

}===== ./src/main/java/org/emblow/envelopify/ui/components/SpendingTrendsChart_Accounts.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;
import com.vaadin.flow.component.Tag;
import com.vaadin.flow.component.dependency.JsModule;
import com.vaadin.flow.component.littemplate.LitTemplate;
import elemental.json.Json;
import elemental.json.JsonArray;
import elemental.json.JsonObject;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.YearMonth;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import java.util.TreeMap;
import java.util.stream.Collectors;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;


/**
 *
 * @author Nicholas J Emblow
 */
@Tag("spending-trends-chart-accounts")
@JsModule("./spending-trends-chart-accounts.js")
public class SpendingTrendsChart_Accounts extends LitTemplate {
    private final Account account;

    public SpendingTrendsChart_Accounts(Account account) {
        this.account = account;
        refreshData();
    }

    public void refreshData() {
       // Group and sum expense transactions by month for the last six months
       Map<YearMonth, BigDecimal> monthlySpending = account.getTransactions().stream()
           .filter(tx -> tx.getType() == TransactionType.EXPENSE)
           .filter(tx -> tx.getDate().isAfter(LocalDateTime.now().minusMonths(6)))
           .collect(Collectors.groupingBy(
               tx -> YearMonth.from(tx.getDate()),
               Collectors.reducing(
                   BigDecimal.ZERO,
                   Transaction::getAmount,
                   BigDecimal::add
               )
           ));

       // Sort by month
       TreeMap<YearMonth, BigDecimal> sortedSpending = new TreeMap<>(monthlySpending);

       // Prepare labels and values
       JsonArray labels = Json.createArray();
       JsonArray values = Json.createArray();

       DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MMM yyyy");
       sortedSpending.forEach((month, amount) -> {
           labels.set(labels.length(), month.format(formatter));
           values.set(values.length(), amount.doubleValue());
       });

       // Create dataset without Chart.js-specific properties
       JsonObject dataset = Json.createObject();
       dataset.put("label", "Monthly Spending");
       dataset.put("data", values);
       // Remove borderColor and tension as they are not used in ECharts
       // dataset.put("borderColor", "rgb(75, 192, 192)");
       // dataset.put("tension", 0.1);

       JsonArray datasets = Json.createArray();
       datasets.set(0, dataset);

       // Create data object
       JsonObject data = Json.createObject();
       data.put("labels", labels);
       data.put("datasets", datasets);

       // Set the chartData property to the data object
       getElement().setProperty("chartData", data.toJson());
   }
}===== ./src/main/java/org/emblow/envelopify/ui/components/DataTable.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

import com.fasterxml.jackson.databind.JsonNode;
import com.vaadin.flow.component.littemplate.LitTemplate;
import com.vaadin.flow.component.Tag;
import com.vaadin.flow.component.dependency.JsModule;
import com.vaadin.flow.server.auth.AnonymousAllowed;

@Tag("data-table")
@JsModule("./data-table.js")
@AnonymousAllowed
public class DataTable extends LitTemplate {
    
    public DataTable() {
        // Set sizing via style
        getElement().getStyle().set("display", "block");
        getElement().getStyle().set("width", "100%");
    }

    public void setTableData(String headers, String rows) {
        getElement().setProperty("headers", headers);
        getElement().setProperty("rows", rows);
        getElement().executeJs("this._updateTable()");
    }

    public static DataTable createFromJson(JsonNode tableNode) {
        DataTable table = new DataTable();
        
        try {
            if (tableNode.has("headers") && tableNode.has("rows")) {
                table.setTableData(
                    tableNode.get("headers").toString(),
                    tableNode.get("rows").toString()
                );
            }
        } catch (Exception e) {
            throw new RuntimeException("Error creating table from JSON: " + e.getMessage());
        }
        
        return table;
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/SpendingTrendsChart.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.littemplate.LitTemplate;
import com.vaadin.flow.component.Tag;
import com.vaadin.flow.component.dependency.JsModule;
import com.vaadin.flow.component.dependency.NpmPackage;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.service.TransactionService;

import java.math.BigDecimal;
import java.time.YearMonth;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.emblow.envelopify.domain.Account;

@Tag("spending-trends-chart")
@JsModule("./spending-trends-chart.js")
@NpmPackage(value = "echarts", version = "5.4.0")
@AnonymousAllowed
public class SpendingTrendsChart extends LitTemplate {
    private final TransactionService transactionService;

    public SpendingTrendsChart(TransactionService transactionService) {
        this.transactionService = transactionService;
        // Set sizing via style
        getElement().getStyle().set("display", "block");
        getElement().getStyle().set("height", "400px");
        getElement().getStyle().set("width", "100%");
        refreshData();
    }

   

    private void refreshData() {
        LocalDateTime sixMonthsAgo = LocalDateTime.now().minusMonths(6);
        List<Transaction> transactions = transactionService.getRecentTransactions(
            sixMonthsAgo, 
            LocalDateTime.now()
        );

        // Group transactions by month and envelope
        Map<YearMonth, Map<String, BigDecimal>> monthlyEnvelopeTotals = transactions.stream()
            .collect(Collectors.groupingBy(
                tx -> YearMonth.from(tx.getDate()),
                Collectors.groupingBy(
                    tx -> tx.getEnvelope().getName(),
                    Collectors.reducing(
                        BigDecimal.ZERO,
                        Transaction::getAmount,
                        BigDecimal::add
                    )
                )
            ));

        // Get all unique envelope names
        List<String> envelopes = transactions.stream()
            .map(tx -> tx.getEnvelope().getName())
            .distinct()
            .sorted()
            .collect(Collectors.toList());

        // Build labels array using double quotes
        YearMonth current = YearMonth.now().minusMonths(5);
        StringBuilder labels = new StringBuilder("[");
        for (int i = 0; i <= 5; i++) {
            if (i > 0) labels.append(",");
            labels.append("\"")
                  .append(current.format(DateTimeFormatter.ofPattern("MMM yy")))
                  .append("\"");
            current = current.plusMonths(1);
        }
        labels.append("]");


        // Build series array for each envelope
        StringBuilder series = new StringBuilder("[");
        for (int i = 0; i < envelopes.size(); i++) {
            if (i > 0) series.append(",");
            String envelope = envelopes.get(i);

            series.append("{")
                  .append("\"name\":\"").append(envelope).append("\",")
                  .append("\"type\":\"bar\",")
                  .append("\"stack\":\"total\",")
                  .append("\"data\":[");

            current = YearMonth.now().minusMonths(5);
            for (int j = 0; j <= 5; j++) {
                if (j > 0) series.append(",");
                BigDecimal amount = monthlyEnvelopeTotals
                    .getOrDefault(current, Map.of())
                    .getOrDefault(envelope, BigDecimal.ZERO);
                series.append(amount.doubleValue());
                current = current.plusMonths(1);
            }
            series.append("]}");
        }
        series.append("]");


        // Update chart properties
        getElement().setProperty("labels", labels.toString());
        getElement().setProperty("series", series.toString());
        getElement().setProperty("envelopes", envelopes.toString());
    }
}===== ./src/main/java/org/emblow/envelopify/ui/components/EnvelopeManagementDialogs.java =====
/*
* Copyright (C) 2025 Nicholas J Emblow
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
package org.emblow.envelopify.ui.components;
/**
*
* @author Nicholas J Emblow
*/
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import com.vaadin.flow.component.textfield.BigDecimalField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.service.EnvelopeService;
import java.math.BigDecimal;
import java.util.List;

public class EnvelopeManagementDialogs {
    private final EnvelopeService envelopeService;
    
    public EnvelopeManagementDialogs(EnvelopeService envelopeService) {
        this.envelopeService = envelopeService;
    }

    public void showAddFundsDialog(Envelope envelope, Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);
        
        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);
        
        H3 title = new H3("Add Funds to " + envelope.getName());
        
        BigDecimalField amountField = new BigDecimalField("Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setValue(BigDecimal.ZERO);
        amountField.setWidthFull();
        
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();
        
        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button addButton = new Button("Add Funds", e -> {
            try {
                BigDecimal amount = amountField.getValue();
                if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                    throw new IllegalArgumentException("Please enter a valid amount");
                }
                envelope.allocate(amount);
                envelopeService.save(envelope);
                dialog.close();
                onSuccess.run();
                Notification.show(
                    "Added " + amount + " to " + envelope.getName(),
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        addButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        
        buttons.add(cancelButton, addButton);
        layout.add(title, amountField, buttons);
        dialog.add(layout);
        dialog.open();
    }

    public void showMoveFundsDialog(Envelope sourceEnvelope, Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);
        
        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);
        
        H3 title = new H3("Move Funds from " + sourceEnvelope.getName());
        
        // Target envelope selector
        ComboBox<Envelope> targetEnvelopeField = new ComboBox<>("To Envelope");
        targetEnvelopeField.setItemLabelGenerator(Envelope::getName);
        List<Envelope> otherEnvelopes = envelopeService.getAllEnvelopes().stream()
            .filter(e -> !e.getId().equals(sourceEnvelope.getId()))
            .toList();
        targetEnvelopeField.setItems(otherEnvelopes);
        targetEnvelopeField.setWidthFull();
        
        // Amount field
        BigDecimalField amountField = new BigDecimalField("Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setValue(BigDecimal.ZERO);
        amountField.setWidthFull();
        
        // Available amount display
        Span availableAmount = new Span(
            "Available: $" + sourceEnvelope.getAvailable()
        );
        
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();
        
        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button moveButton = new Button("Move Funds", e -> {
            try {
                Envelope targetEnvelope = targetEnvelopeField.getValue();
                BigDecimal amount = amountField.getValue();
                
                if (targetEnvelope == null) {
                    throw new IllegalArgumentException("Please select a target envelope");
                }
                if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                    throw new IllegalArgumentException("Please enter a valid amount");
                }
                
                envelopeService.reallocate(
                    sourceEnvelope.getId(),
                    targetEnvelope.getId(),
                    amount
                );
                dialog.close();
                onSuccess.run();
                Notification.show(
                    "Moved " + amount + " from " + sourceEnvelope.getName() +
                    " to " + targetEnvelope.getName(),
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        moveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        
        buttons.add(cancelButton, moveButton);
        layout.add(title, targetEnvelopeField, amountField, availableAmount, buttons);
        dialog.add(layout);
        dialog.open();
    }

    public void showNewEnvelopeDialog(Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);
        
        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);
        
        H3 title = new H3("Create New Envelope");
        
        TextField nameField = new TextField("Name");
        nameField.setWidthFull();
        nameField.setRequired(true);
        
        BigDecimalField amountField = new BigDecimalField("Initial Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setValue(BigDecimal.ZERO);
        amountField.setWidthFull();
        
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();
        
        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button createButton = new Button("Create", e -> {
            try {
                String name = nameField.getValue();
                BigDecimal amount = amountField.getValue();
                
                if (name == null || name.trim().isEmpty()) {
                    throw new IllegalArgumentException("Please enter a name for the envelope");
                }
                if (amount == null || amount.compareTo(BigDecimal.ZERO) < 0) {
                    throw new IllegalArgumentException("Amount cannot be negative");
                }
                
                Envelope envelope = envelopeService.createEnvelope(name.trim(), amount);
                dialog.close();
                onSuccess.run();
                Notification.show(
                    "Created new envelope: " + envelope.getName(),
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        createButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        
        buttons.add(cancelButton, createButton);
        layout.add(title, nameField, amountField, buttons);
        dialog.add(layout);
        dialog.open();
    }

    public void showEditNameDialog(Envelope envelope, Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);
        
        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);
        
        H3 title = new H3("Edit Envelope Name");
        
        TextField nameField = new TextField("New Name", envelope.getName());
        nameField.setWidthFull();
        nameField.setRequired(true);
        
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();
        
        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button saveButton = new Button("Save", e -> {
            try {
                String newName = nameField.getValue();
                if (newName == null || newName.trim().isEmpty()) {
                    throw new IllegalArgumentException("Please enter a valid name");
                }
                envelope.setName(newName.trim());
                envelopeService.save(envelope);
                dialog.close();
                onSuccess.run();
                Notification.show(
                    "Envelope name updated to " + newName,
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        
        buttons.add(cancelButton, saveButton);
        layout.add(title, nameField, buttons);
        dialog.add(layout);
        dialog.open();
    }

    public void showDeleteEnvelopeDialog(Envelope envelope, Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);
        
        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);
        
        H3 title = new H3("Delete Envelope: " + envelope.getName());
        
        // Warning text
        Span warningText = new Span("Please select where to move the existing transactions:");
        
        // Target envelope selector (excluding current envelope)
        ComboBox<Envelope> targetEnvelopeField = new ComboBox<>("Move transactions to");
        targetEnvelopeField.setItemLabelGenerator(Envelope::getName);
        List<Envelope> otherEnvelopes = envelopeService.getAllEnvelopes().stream()
            .filter(e -> !e.getId().equals(envelope.getId()))
            .toList();
        targetEnvelopeField.setItems(otherEnvelopes);
        targetEnvelopeField.setWidthFull();
        targetEnvelopeField.setRequired(true);
        
        // Display current balance
        Span balanceInfo = new Span(
            "Current balance: $" + envelope.getAvailable()
        );
        
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();
        
        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button deleteButton = new Button("Delete", e -> {
            try {
                Envelope targetEnvelope = targetEnvelopeField.getValue();
                if (targetEnvelope == null) {
                    throw new IllegalArgumentException("Please select a target envelope for the transactions");
                }
                
                envelopeService.deleteEnvelope(envelope.getId(), targetEnvelope.getId());
                dialog.close();
                onSuccess.run();
                
                Notification.show(
                    "Envelope deleted and transactions moved to " + targetEnvelope.getName(),
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        deleteButton.addThemeVariants(ButtonVariant.LUMO_ERROR);
        
        buttons.add(cancelButton, deleteButton);
        layout.add(title, warningText, targetEnvelopeField, balanceInfo, buttons);
        dialog.add(layout);
        dialog.open();
    }
    
    public void showBudgetDialog(Envelope envelope, Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);

        H3 title = new H3("Budget Settings: " + envelope.getName());

        // Monthly budget field
        BigDecimalField monthlyBudgetField = new BigDecimalField("Monthly Budget Target");
        monthlyBudgetField.setPrefixComponent(new Span("$"));
        monthlyBudgetField.setValue(envelope.getMonthlyBudget());
        monthlyBudgetField.setWidthFull();

        // Current allocation field
        BigDecimalField allocationField = new BigDecimalField("Current Allocation");
        allocationField.setPrefixComponent(new Span("$"));
        allocationField.setValue(envelope.getAllocated());
        allocationField.setWidthFull();

        // Helper text
        Span helpText = new Span("The monthly budget is your target spending. The allocation is your currently available funds.");
        helpText.getStyle().set("color", "var(--lumo-secondary-text-color)");

        // Buttons
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> dialog.close());

        Button saveButton = new Button("Save", e -> {
            try {
                BigDecimal newBudget = monthlyBudgetField.getValue();
                BigDecimal newAllocation = allocationField.getValue();

                if (newBudget == null || newBudget.compareTo(BigDecimal.ZERO) < 0) {
                    throw new IllegalArgumentException("Please enter a valid budget amount");
                }
                if (newAllocation == null || newAllocation.compareTo(BigDecimal.ZERO) < 0) {
                    throw new IllegalArgumentException("Please enter a valid allocation amount");
                }

                // Update budget
                envelope.setMonthlyBudget(newBudget);

                // Handle allocation change
                BigDecimal currentAllocation = envelope.getAllocated();
                if (newAllocation.compareTo(currentAllocation) > 0) {
                    envelope.allocate(newAllocation.subtract(currentAllocation));
                } else if (newAllocation.compareTo(currentAllocation) < 0) {
                    envelope.withdraw(currentAllocation.subtract(newAllocation));
                }

                envelopeService.save(envelope);
                dialog.close();
                onSuccess.run();

                Notification.show(
                    "Budget settings updated",
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        buttons.add(cancelButton, saveButton);
        layout.add(title, monthlyBudgetField, allocationField, helpText, buttons);
        dialog.add(layout);
        dialog.open();
    }
}===== ./src/main/java/org/emblow/envelopify/ui/MainLayout.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui;

import com.vaadin.flow.component.UI;
import com.vaadin.flow.component.applayout.AppLayout;
import com.vaadin.flow.component.applayout.DrawerToggle;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.html.H1;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.sidenav.SideNav;
import com.vaadin.flow.component.sidenav.SideNavItem;
import com.vaadin.flow.component.orderedlayout.Scroller;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import com.vaadin.flow.theme.lumo.LumoUtility;
import org.emblow.envelopify.service.SecurityService;
import org.emblow.envelopify.ui.views.ChatView;
import org.emblow.envelopify.ui.views.ConfigurationView;
import org.emblow.envelopify.ui.views.DashboardView;
import org.emblow.envelopify.ui.views.InsightsView;
import org.springframework.beans.factory.annotation.Autowired;
import com.vaadin.flow.spring.annotation.SpringComponent;
import com.vaadin.flow.spring.annotation.UIScope;
import org.emblow.envelopify.service.InitializationService;

/**
 * MainLayout is the primary application layout used after authentication.
 * It contains the header with navigation controls, a personalized greeting, and the side drawer.
 * All views for loggedâ€‘in users are displayed within this layout.
 *
 * <p>This class is a Spring-managed component (per UI) and obtains the current user via SecurityService.</p>
 *
 * @author Nicholas J Emblow
 * @version 1.0
 * @since 2025
 */
@SpringComponent
@UIScope
@AnonymousAllowed
@PageTitle("Envelofy")
public class MainLayout extends AppLayout {

    private final SecurityService securityService;
    private Button toggleDarkMode;
    private final InitializationService initializationService;
    @Autowired
    public MainLayout(SecurityService securityService, InitializationService initializationService) {
        this.securityService = securityService;
        // Set initial theme based on local storage value.
        UI.getCurrent().getPage().executeJs(
            "if(window.localStorage.getItem('theme') === 'dark') {" +
            "   document.documentElement.setAttribute('theme', 'dark');" +
            "} else {" +
            "   document.documentElement.setAttribute('theme', 'light');" +
            "}"
        );
                this.initializationService = initializationService;
        createHeader();
        createDrawer();
        
    }

    private void createHeader() {
        // Create logo label.
        H1 logo = new H1("Envelofy");
        logo.addClassNames(LumoUtility.FontSize.LARGE, LumoUtility.Margin.MEDIUM);

        // Create the drawer toggle button.
        DrawerToggle drawerToggle = new DrawerToggle();

        // Create a donation button that opens a GitHub Sponsors page.
        Button donateButton = new Button("Support the Project", e ->
            UI.getCurrent().getPage().open("https://github.com/sponsors/nicholasjemblow", "_blank")
        );

        // Create a button to toggle dark/light mode.
        toggleDarkMode = new Button("Toggle Dark Mode", e -> {
            UI.getCurrent().getPage().executeJs(
                "var theme = document.documentElement.getAttribute('theme') || 'light';" +
                "var newTheme = (theme === 'dark') ? 'light' : 'dark';" +
                "document.documentElement.setAttribute('theme', newTheme);" +
                "window.localStorage.setItem('theme', newTheme);"
            );
        });

        
                // Create a button to trigger test data initialization.
        Button initTestDataButton = new Button("Initialize Test Data", e -> {
            initializationService.initializeTestData();
            // Optionally, you can show a notification to the user here.
        });

        
        // --- Add a logout form (hidden) ---
        // Create a Div to hold our logout form.
        Div logoutFormDiv = new Div();
        // Insert the form HTML: it's hidden via inline CSS.
        logoutFormDiv.getElement().setProperty("innerHTML",
            "<form id='logoutForm' action='/logout' method='POST' style='display:none;'></form>"
        );

        // Create a sign out button that triggers the logout form submission.
        Button signOutButton = new Button("Sign Out", e ->
            UI.getCurrent().getPage().executeJs("document.getElementById('logoutForm').submit()")
        );

        // Retrieve current user's username from the SecurityService.
        String currentUsername = securityService.getCurrentUser().getUsername();
        // Create a greeting header.
        H1 greeting = new H1("Welcome, " + currentUsername + "!");
        greeting.addClassNames(LumoUtility.FontSize.MEDIUM, LumoUtility.Margin.NONE);

        // Create the header layout and add all components.
        HorizontalLayout headerLayout = new HorizontalLayout(
            drawerToggle, logo, initTestDataButton,donateButton, toggleDarkMode, signOutButton, greeting
        );
        headerLayout.setWidthFull();
        headerLayout.setDefaultVerticalComponentAlignment(
            com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment.CENTER
        );
        headerLayout.expand(logo);
        headerLayout.addClassNames(
            LumoUtility.Background.BASE,
            LumoUtility.BoxSizing.BORDER,
            LumoUtility.Display.FLEX,
            LumoUtility.AlignItems.CENTER,
            LumoUtility.Padding.MEDIUM,
            LumoUtility.Width.FULL
        );

        // Add both the header layout and the hidden logout form.
        addToNavbar(headerLayout);
        addToNavbar(logoutFormDiv); // This adds the form to the DOM so it can be submitted.
    }

    private void createDrawer() {
        SideNav nav = new SideNav();

        nav.addItem(new SideNavItem("Dashboard", DashboardView.class, 
                com.vaadin.flow.component.icon.VaadinIcon.DASHBOARD.create()));
        nav.addItem(new SideNavItem("Smart Insights", InsightsView.class, 
                com.vaadin.flow.component.icon.VaadinIcon.CHART.create()));
        nav.addItem(new SideNavItem("Chat Assistant", ChatView.class, 
                com.vaadin.flow.component.icon.VaadinIcon.CHAT.create()));
        nav.addItem(new SideNavItem("Configuration", ConfigurationView.class, 
                com.vaadin.flow.component.icon.VaadinIcon.COG.create()));

        Scroller scroller = new Scroller(nav);
        addToDrawer(scroller);
    }
}===== ./src/main/java/org/emblow/envelopify/ui/views/EnvelopeView.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.tabs.Tab;
import com.vaadin.flow.component.tabs.Tabs;
import com.vaadin.flow.router.BeforeEvent;
import com.vaadin.flow.router.HasUrlParameter;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.grid.Grid;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.grid.GridSortOrder;
import com.vaadin.flow.component.grid.GridVariant;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.data.provider.SortDirection;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.service.RecurringTransactionService;
import org.emblow.envelopify.service.BillReminderService;
import org.emblow.envelopify.ui.MainLayout;
import org.emblow.envelopify.ui.components.EnvelopeSchedulePanel;
import org.emblow.envelopify.ui.components.TransactionManagementDialogs;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.math.BigDecimal;
import org.emblow.envelopify.service.ml.AdvancedMLService;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.emblow.envelopify.ui.components.MLInsightsTable;
import org.emblow.envelopify.ui.components.MLSpendingPredictionChart;
import org.emblow.envelopify.ui.components.SpendingTrendsChart;
import org.emblow.envelopify.ui.components.UnusualSpendingChart;

@Route(value = "envelopes", layout = MainLayout.class)
@AnonymousAllowed
public class EnvelopeView extends VerticalLayout implements HasUrlParameter<Long> {
    
    private final EnvelopeService envelopeService;
    private final TransactionService transactionService;
    private final AccountService accountService;
    private final RecurringTransactionService recurringTransactionService;
    private final BillReminderService billReminderService;
    private final TransactionManagementDialogs transactionDialogs;
    
    private final VerticalLayout contentLayout = new VerticalLayout();
    private Envelope currentEnvelope;
    private final Grid<Transaction> transactionGrid;

    private final AdvancedMLService advancedMLService;
    private final SpendingInsightService insightService;

    public EnvelopeView(
        EnvelopeService envelopeService,
        TransactionService transactionService,
        AccountService accountService,
        RecurringTransactionService recurringTransactionService,
        BillReminderService billReminderService,
        TransactionManagementDialogs transactionDialogs,
        AdvancedMLService advancedMLService,
        SpendingInsightService insightService
    ) {
        this.envelopeService = envelopeService;
        this.transactionService = transactionService;
        this.accountService = accountService;
        this.recurringTransactionService = recurringTransactionService;
        this.billReminderService = billReminderService;
        this.transactionDialogs = transactionDialogs;
        this.advancedMLService = advancedMLService;
        this.insightService = insightService;
        setPadding(true);
        setSpacing(true);
        
        // Initialize transaction grid
        transactionGrid = new Grid<>();
        configureTransactionGrid();
        
        // Initialize layout
        contentLayout.setPadding(false);
        contentLayout.setSpacing(true);
        
        add(contentLayout);
    }

    @Override
    public void setParameter(BeforeEvent event, Long envelopeId) {
        currentEnvelope = envelopeService.getEnvelope(envelopeId);
        updateView();
    }
    
    private void updateView() {
        contentLayout.removeAll();
        
        // Header section
        HorizontalLayout header = new HorizontalLayout();
        header.setWidthFull();
        header.setAlignItems(Alignment.CENTER);
        header.setJustifyContentMode(JustifyContentMode.BETWEEN);
        
        H2 title = new H2(currentEnvelope.getName());
        
        Button newTransactionButton = new Button(
            "New Transaction", 
            new Icon(VaadinIcon.PLUS),
            e -> transactionDialogs.showNewTransactionDialog(this::refreshData)
        );
        newTransactionButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        
        header.add(title, newTransactionButton);
        
        // Overview Panel
        Div overviewPanel = createOverviewPanel();
        
        // Tabs for different sections
        Tab overviewTab = new Tab("Overview");
        Tab scheduleTab = new Tab("Schedule");
        Tab historyTab = new Tab("History");
        Tab analyticsTab = new Tab("Analytics");
        
        Tabs tabs = new Tabs(overviewTab, scheduleTab, historyTab, analyticsTab);
        tabs.addSelectedChangeListener(event -> {
            updateContent(event.getSelectedTab());
        });
        
        contentLayout.add(header, overviewPanel, tabs);
        
        // Show initial content
        updateContent(overviewTab);
    }
    
    private Div createOverviewPanel() {
        Div panel = new Div();
        panel.addClassName("overview-panel");
        panel.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("padding", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-m)");
        
        // General stats
        H3 statsTitle = new H3("Envelope Statistics");
        Div statsGrid = new Div();
        statsGrid.getStyle()
            .set("display", "grid")
            .set("grid-template-columns", "repeat(auto-fit, minmax(200px, 1fr))")
            .set("gap", "var(--lumo-space-m)");
        
        addStatCard(statsGrid, "Monthly Budget", 
            String.format("$%.2f", currentEnvelope.getMonthlyBudget()));
        addStatCard(statsGrid, "Available", 
            String.format("$%.2f", currentEnvelope.getAvailable()));
        addStatCard(statsGrid, "Spent This Month", 
            String.format("$%.2f", currentEnvelope.getCurrentMonthSpent()));
        
        // Account breakdown
        H3 accountsTitle = new H3("Account Breakdown");
        Div accountsGrid = new Div();
        accountsGrid.getStyle()
            .set("display", "grid")
            .set("grid-template-columns", "repeat(auto-fit, minmax(250px, 1fr))")
            .set("gap", "var(--lumo-space-m)");
        
        // Calculate spending by account
        Map<Account, BigDecimal> spendingByAccount = calculateSpendingByAccount();
        
        spendingByAccount.forEach((account, amount) -> {
            addAccountCard(accountsGrid, account, amount);
        });
        
        panel.add(statsTitle, statsGrid, accountsTitle, accountsGrid);
        return panel;
    }
    
    private void addStatCard(Div container, String label, String value) {
        Div card = new Div();
        card.getStyle()
            .set("background-color", "var(--lumo-contrast-5pct)")
            .set("padding", "var(--lumo-space-m)")
            .set("border-radius", "var(--lumo-border-radius-m)")
            .set("text-align", "center");
        
        Div labelDiv = new Div();
        labelDiv.setText(label);
        labelDiv.getStyle().set("color", "var(--lumo-secondary-text-color)");
        
        Div valueDiv = new Div();
        valueDiv.setText(value);
        valueDiv.getStyle()
            .set("font-size", "var(--lumo-font-size-xl)")
            .set("font-weight", "bold");
        
        card.add(labelDiv, valueDiv);
        container.add(card);
    }
    
    private void addAccountCard(Div container, Account account, BigDecimal amount) {
        Div card = new Div();
        card.getStyle()
            .set("background-color", "var(--lumo-contrast-5pct)")
            .set("padding", "var(--lumo-space-m)")
            .set("border-radius", "var(--lumo-border-radius-m)");
        
        H3 accountName = new H3(account.getName());
        accountName.getStyle()
            .set("margin", "0")
            .set("margin-bottom", "var(--lumo-space-s)");
        
        Div typeLabel = new Div();
        typeLabel.setText(account.getType().getDisplayName());
        typeLabel.getStyle()
            .set("color", "var(--lumo-secondary-text-color)")
            .set("margin-bottom", "var(--lumo-space-s)");
        
        Div amountLabel = new Div();
        amountLabel.setText(String.format("Spent: $%.2f", amount));
        amountLabel.getStyle()
            .set("font-weight", "bold")
            .set("color", "var(--lumo-primary-text-color)");
        
        card.add(accountName, typeLabel, amountLabel);
        container.add(card);
    }
    
    private Map<Account, BigDecimal> calculateSpendingByAccount() {
        LocalDateTime monthStart = LocalDateTime.now().withDayOfMonth(1).withHour(0).withMinute(0);
        List<Transaction> transactions = transactionService.getRecentTransactions(
            monthStart, 
            LocalDateTime.now()
        );
        
        return transactions.stream()
            .filter(tx -> tx.getEnvelope().getId().equals(currentEnvelope.getId()))
            .collect(Collectors.groupingBy(
                Transaction::getAccount,
                Collectors.reducing(
                    BigDecimal.ZERO,
                    Transaction::getAmount,
                    BigDecimal::add
                )
            ));
    }
    
    private void configureTransactionGrid() {
        transactionGrid.addThemeVariants(GridVariant.LUMO_ROW_STRIPES);
        
        transactionGrid.addColumn(tx -> 
            tx.getDate().format(DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm")))
            .setHeader("Date")
            .setSortable(true)
            .setAutoWidth(true);
            
        transactionGrid.addColumn(Transaction::getDescription)
            .setHeader("Description")
            .setAutoWidth(true);
            
        transactionGrid.addColumn(tx -> 
            String.format("$%.2f", tx.getAmount()))
            .setHeader("Amount")
            .setAutoWidth(true);
        
        // NEW: Add a column to show the transaction type (Income/Expense)
        transactionGrid.addColumn(tx -> 
            tx.getType().toString())
            .setHeader("Type")
            .setAutoWidth(true);
            
        transactionGrid.addColumn(tx -> 
            String.format("%s (%s)", 
                tx.getAccount().getName(),
                tx.getAccount().getType().getDisplayName()))
            .setHeader("Account")
            .setAutoWidth(true);
            
        // Add double-click listener for editing
        transactionGrid.addItemDoubleClickListener(event -> {
            transactionDialogs.showEditTransactionDialog(event.getItem(), this::refreshData);
        });
        
        // Set default sort on the Date column
        GridSortOrder<Transaction> order = new GridSortOrder<>(
            transactionGrid.getColumns().get(0), 
            SortDirection.DESCENDING
        );
        transactionGrid.sort(List.of(order));
    }
    
    private void updateContent(Tab selectedTab) {
        // Remove old content (after header and tabs)
        while (contentLayout.getComponentCount() > 3) {
            contentLayout.remove(contentLayout.getComponentAt(3));
        }
        
        if (selectedTab.getLabel().equals("Overview")) {
            contentLayout.add(createOverviewContent());
        } else if (selectedTab.getLabel().equals("Schedule")) {
            contentLayout.add(new EnvelopeSchedulePanel(
                currentEnvelope,
                recurringTransactionService,
                billReminderService,
                envelopeService,
                accountService
            ));
        } else if (selectedTab.getLabel().equals("History")) {
            contentLayout.add(createHistoryContent());
        } else if (selectedTab.getLabel().equals("Analytics")) {
            contentLayout.add(createAnalyticsContent());
        }
    }
    
    private VerticalLayout createOverviewContent() {
        VerticalLayout layout = new VerticalLayout();
        layout.setSpacing(true);
        layout.setPadding(false);
        
        // Add recent transactions
        H3 recentTitle = new H3("Recent Transactions");
        layout.add(recentTitle, transactionGrid);
        
        refreshData();
        return layout;
    }
    
    private VerticalLayout createHistoryContent() {
        VerticalLayout layout = new VerticalLayout();
        layout.add(transactionGrid);
        refreshData();
        return layout;
    }
    
private VerticalLayout createAnalyticsContent() {
        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);

        // Spending trends chart (historical data)
        H3 trendsTitle = new H3("Historical Spending Trends");
        SpendingTrendsChart trendsChart = new SpendingTrendsChart(transactionService);
        layout.add(trendsTitle, trendsChart);

        // ML-based prediction chart
        H3 predictionTitle = new H3("ML Spending Predictions");
        MLSpendingPredictionChart predictionChart = new MLSpendingPredictionChart(
            advancedMLService, 
            currentEnvelope
        );
        layout.add(predictionTitle, predictionChart);

        // Unusual spending visualization
        H3 anomalyTitle = new H3("Unusual Spending Events");
        UnusualSpendingChart anomalyChart = new UnusualSpendingChart(
            insightService,
            currentEnvelope
        );
        layout.add(anomalyTitle, anomalyChart);

        // ML insights table
        MLInsightsTable insightsTable = new MLInsightsTable(
            insightService,
            currentEnvelope
        );
        layout.add(insightsTable);

        return layout;
    }

    private void refreshData() {
        LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
        List<Transaction> transactions = transactionService.getRecentTransactions(
            oneMonthAgo,
            LocalDateTime.now()
        ).stream()
        .filter(tx -> tx.getEnvelope().getId().equals(currentEnvelope.getId()))
        .collect(Collectors.toList());
        
        transactionGrid.setItems(transactions);
    }
}
===== ./src/main/java/org/emblow/envelopify/ui/views/ConfigurationView.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Paragraph;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.tabs.Tab;
import com.vaadin.flow.component.tabs.Tabs;
import com.vaadin.flow.component.textfield.PasswordField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.ui.MainLayout;
import org.emblow.envelopify.service.SettingService;
import org.springframework.beans.factory.annotation.Value;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * ConfigurationView displays application configuration settings.
 * <p>
 * Currently, this view contains a single tab ("LLM Settings") where the user can select a language model service 
 * and configure its settings. The view uses the {@code SettingService} to load and save settings.
 * Settings are stored using key/value pairs.
 * </p>
 * 
 * <p>This view is accessible to anonymous users, so ensure your security configuration permits this.</p>
 * 
 * @author 
 * @version 1.0
 * @since 2025
 */
@Route(value = "config", layout = MainLayout.class)
@PageTitle("Configuration | Envelofy")
@AnonymousAllowed
public class ConfigurationView extends VerticalLayout {

    /**
     * The SettingService used to retrieve and update configuration settings.
     */
    private final SettingService settingService;
    
    @Value("${llm.service.type:jllama}")
    private String currentLLMType;
    
    @Value("${openai.api.key:}")
    private String openaiApiKey;
    
    @Value("${openai.chat.endpoint:}")
    private String openaiEndpoint;
    
    @Value("${ollama.endpoint:}")
    private String ollamaEndpoint;
    
    @Value("${ollama.model:}")
    private String ollamaModel;
    
    @Value("${groq.api.key:}")
    private String groqApiKey;

    @Value("${groq.base.url:}")
    private String groqBaseUrl;

    @Value("${groq.chat.model:}")
    private String groqModel;

    /**
     * Constructs a new ConfigurationView.
     *
     * @param settingService the service used to retrieve and update configuration settings
     */
    public ConfigurationView(SettingService settingService) {
        this.settingService = settingService;
        
        addClassName("config-view");
        setSpacing(true);
        setPadding(true);
        
        // Header section with title.
        H2 title = new H2("Configuration");
        title.getStyle().set("margin-top", "0");
        
        // Create a tab for LLM Settings.
        Tab llmTab = new Tab("LLM Settings");
        Tabs tabs = new Tabs(llmTab);
        
        // Create the content area that will hold the configuration components.
        VerticalLayout content = new VerticalLayout();
        content.setSpacing(true);
        content.setPadding(true);
        
        // Initialize content with LLM Settings.
        updateContent(content, llmTab);
        
        // Add a listener to update content when the tab selection changes.
        tabs.addSelectedChangeListener(event -> 
            updateContent(content, event.getSelectedTab())
        );
        
        add(title, tabs, content);
    }
    
    /**
     * Updates the content layout based on the selected tab.
     *
     * @param content     the VerticalLayout where content is displayed
     * @param selectedTab the currently selected tab
     */
    private void updateContent(VerticalLayout content, Tab selectedTab) {
        content.removeAll();
        
        switch (selectedTab.getLabel()) {
            case "LLM Settings" -> createLLMSettings(content);
            // Future configuration sections can be added here.
            default -> { }
        }
    }
    
    /**
     * Creates and adds the LLM Settings configuration components to the provided layout.
     *
     * @param content the layout to which LLM settings components are added
     */
    private void createLLMSettings(VerticalLayout content) {
        H3 llmTitle = new H3("Language Model Configuration");
        
        // ComboBox for selecting the LLM service type.
        ComboBox<String> llmTypeSelect = new ComboBox<>("LLM Service Type");
        llmTypeSelect.setItems("jllama", "chatgpt", "ollama", "groq");
        llmTypeSelect.setValue(currentLLMType != null ? currentLLMType : "jllama");
        
        // Create separate layouts for each LLM configuration.
        VerticalLayout chatgptSettings = createChatGPTSettings();
        VerticalLayout ollamaSettings = createOllamaSettings();
        VerticalLayout groqSettings = createGroqSettings();
        VerticalLayout jllamaSettings = createJLlamaSettings();
        
        // Set initial visibility based on the selected type.
        updateLLMSettingsVisibility(llmTypeSelect.getValue(), chatgptSettings, ollamaSettings, groqSettings, jllamaSettings);
        
        // Add listener to update visibility when the selected type changes.
        llmTypeSelect.addValueChangeListener(event ->
            updateLLMSettingsVisibility(event.getValue(), chatgptSettings, ollamaSettings, groqSettings, jllamaSettings)
        );
        
        // Save button that collects all settings and saves them.
        Button saveButton = new Button("Save Changes", new Icon(VaadinIcon.CHECK), e ->
            saveLLMSettings(llmTypeSelect.getValue(), chatgptSettings, ollamaSettings, groqSettings, jllamaSettings)
        );
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        
        // Add components to the content layout.
        content.add(
            llmTitle,
            new Paragraph("Choose your preferred language model service and configure its settings."),
            llmTypeSelect,
            chatgptSettings,
            ollamaSettings,
            groqSettings,
            jllamaSettings,
            saveButton
        );
    }
    
    /**
     * Creates the ChatGPT configuration layout.
     *
     * @return a VerticalLayout containing ChatGPT settings fields
     */
    private VerticalLayout createChatGPTSettings() {
        VerticalLayout layout = new VerticalLayout();
        layout.setVisible(false);
        layout.setSpacing(true);
        
        H3 title = new H3("ChatGPT Settings");
        
        PasswordField apiKeyField = new PasswordField("API Key");
        apiKeyField.setValue(openaiApiKey != null ? openaiApiKey : "");
        apiKeyField.setWidthFull();
        apiKeyField.setHelperText("Your OpenAI API key");
        
        TextField endpointField = new TextField("API Endpoint");
        endpointField.setValue(openaiEndpoint != null ? openaiEndpoint : "https://api.openai.com/v1/chat/completions");
        endpointField.setWidthFull();
        endpointField.setHelperText("ChatGPT API endpoint URL");
        
        layout.add(title, apiKeyField, endpointField);
        return layout;
    }
    
    /**
     * Creates the Ollama configuration layout.
     *
     * @return a VerticalLayout containing Ollama settings fields
     */
    private VerticalLayout createOllamaSettings() {
        VerticalLayout layout = new VerticalLayout();
        layout.setVisible(false);
        layout.setSpacing(true);
        
        H3 title = new H3("Ollama Settings");
        
        TextField endpointField = new TextField("Endpoint URL");
        endpointField.setValue(ollamaEndpoint != null ? ollamaEndpoint : "http://localhost:11434/api/generate");
        endpointField.setWidthFull();
        endpointField.setHelperText("Local Ollama endpoint (e.g., http://localhost:11434)");
        
        TextField modelField = new TextField("Model Name");
        modelField.setValue(ollamaModel != null ? ollamaModel : "llama2:latest");
        modelField.setWidthFull();
        modelField.setHelperText("Ollama model name (e.g., llama2:latest)");
        
        layout.add(title, endpointField, modelField);
        return layout;
    }
    
    /**
     * Creates the Groq configuration layout.
     *
     * @return a VerticalLayout containing Groq settings fields
     */
    private VerticalLayout createGroqSettings() {
        VerticalLayout layout = new VerticalLayout();
        layout.setVisible(false);
        layout.setSpacing(true);
        
        H3 title = new H3("Groq Settings");
        
        PasswordField apiKeyField = new PasswordField("API Key");
        apiKeyField.setValue(groqApiKey != null ? groqApiKey : "");
        apiKeyField.setWidthFull();
        apiKeyField.setHelperText("Your Groq API key");
        
        TextField baseUrlField = new TextField("Base URL");
        baseUrlField.setValue(groqBaseUrl != null ? groqBaseUrl : "https://api.groq.com");
        baseUrlField.setWidthFull();
        baseUrlField.setHelperText("Groq API base URL");
        
        TextField modelField = new TextField("Model Name");
        modelField.setValue(groqModel != null ? groqModel : "mixtral-8x7b-32768");
        modelField.setWidthFull();
        modelField.setHelperText("Groq model name");
        
        layout.add(title, apiKeyField, baseUrlField, modelField);
        return layout;
    }
    
    /**
     * Creates the JLlama configuration layout.
     *
     * @return a VerticalLayout containing JLlama configuration information
     */
    private VerticalLayout createJLlamaSettings() {
        VerticalLayout layout = new VerticalLayout();
        layout.setVisible(false);
        layout.setSpacing(true);
        
        H3 title = new H3("JLlama Settings");
        
        Paragraph info = new Paragraph(
                "JLlama runs locally and requires no additional configuration. " +
                "Models will be automatically downloaded when first used."
        );
        
        layout.add(title, info);
        return layout;
    }
    
    /**
     * Updates the visibility of the various LLM settings layouts based on the selected LLM service type.
     *
     * @param selectedType      the selected LLM service type ("jllama", "chatgpt", "ollama", or "groq")
     * @param chatgptSettings   the ChatGPT settings layout
     * @param ollamaSettings    the Ollama settings layout
     * @param groqSettings      the Groq settings layout
     * @param jllamaSettings    the JLlama settings layout
     */
    private void updateLLMSettingsVisibility(
        String selectedType,
        VerticalLayout chatgptSettings,
        VerticalLayout ollamaSettings,
        VerticalLayout groqSettings,
        VerticalLayout jllamaSettings
    ) {
        chatgptSettings.setVisible("chatgpt".equals(selectedType));
        ollamaSettings.setVisible("ollama".equals(selectedType));
        groqSettings.setVisible("groq".equals(selectedType));
        jllamaSettings.setVisible("jllama".equals(selectedType));
    }
    
    /**
     * Gathers the configuration values from the different LLM settings layouts and saves them using the SettingService.
     * Since the SettingService's saveSetting method takes two parameters (key and value),
     * we iterate over the settings map and call saveSetting for each entry.
     *
     * @param selectedType      the selected LLM service type
     * @param chatgptSettings   the ChatGPT settings layout
     * @param ollamaSettings    the Ollama settings layout
     * @param groqSettings      the Groq settings layout
     * @param jllamaSettings    the JLlama settings layout
     */
    private void saveLLMSettings(
        String selectedType,
        VerticalLayout chatgptSettings,
        VerticalLayout ollamaSettings,
        VerticalLayout groqSettings,
        VerticalLayout jllamaSettings
    ) {
        try {
            Map<String, String> newSettings = new HashMap<>();
            
            // Save the LLM service type.
            newSettings.put("llm.service.type", selectedType);
            
            // Save ChatGPT settings.
            if ("chatgpt".equals(selectedType)) {
                PasswordField apiKeyField = (PasswordField) chatgptSettings.getChildren()
                        .filter(c -> c instanceof PasswordField)
                        .findFirst()
                        .orElseThrow();
                TextField endpointField = (TextField) chatgptSettings.getChildren()
                        .filter(c -> c instanceof TextField)
                        .findFirst()
                        .orElseThrow();
                newSettings.put("openai.api.key", apiKeyField.getValue());
                newSettings.put("openai.chat.endpoint", endpointField.getValue());
            }
            
            // Save Ollama settings.
            if ("ollama".equals(selectedType)) {
                // Expect two TextField components.
                var ollamaFields = ollamaSettings.getChildren()
                        .filter(c -> c instanceof TextField)
                        .map(c -> (TextField) c)
                        .collect(Collectors.toList());
                newSettings.put("ollama.endpoint", ollamaFields.get(0).getValue());
                newSettings.put("ollama.model", ollamaFields.get(1).getValue());
            }
            
            // Save Groq settings.
            if ("groq".equals(selectedType)) {
                PasswordField apiKeyField = (PasswordField) groqSettings.getChildren()
                        .filter(c -> c instanceof PasswordField)
                        .findFirst()
                        .orElseThrow();
                var groqFields = groqSettings.getChildren()
                        .filter(c -> c instanceof TextField)
                        .map(c -> (TextField) c)
                        .collect(Collectors.toList());
                newSettings.put("groq.api.key", apiKeyField.getValue());
                newSettings.put("groq.base.url", groqFields.get(0).getValue());
                newSettings.put("groq.chat.model", groqFields.get(1).getValue());
            }
            
            // Instead of calling a saveSettings(Map) method, iterate over each entry and call saveSetting(key, value)
            for (Map.Entry<String, String> entry : newSettings.entrySet()) {
                settingService.saveSetting(entry.getKey(), entry.getValue());
            }
            
            Notification notification = Notification.show(
                    "Settings saved successfully. Please restart the application for changes to take effect.",
                    5000,
                    Notification.Position.MIDDLE
            );
            notification.addThemeVariants(NotificationVariant.LUMO_SUCCESS);
        } catch (Exception e) {
            Notification notification = Notification.show(
                    "Error saving settings: " + e.getMessage(),
                    5000,
                    Notification.Position.MIDDLE
            );
            notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
        }
    }
}
===== ./src/main/java/org/emblow/envelopify/ui/views/ChatView.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import org.emblow.envelopify.repository.ChartArtifactRepository;
import org.emblow.envelopify.service.llm.LLMService;
import org.emblow.envelopify.service.ChatHistoryService;
import org.emblow.envelopify.ui.MainLayout;
import org.emblow.envelopify.ui.components.ChatComponent;

@Route(value = "chat", layout = MainLayout.class)
@PageTitle("Financial Assistant | Envelofy")
public class ChatView extends VerticalLayout {

    public ChatView(LLMService llmService, 
                   ChatHistoryService chatHistoryService,
                   ChartArtifactRepository chartArtifactRepository) { // Add this parameter
        addClassName("chat-view");
        setSizeFull(); 
        setAlignItems(Alignment.CENTER);
        
        H2 header = new H2("Financial Assistant");
        header.getStyle().set("margin-top", "var(--lumo-space-m)");
        
        ChatComponent chat = new ChatComponent(llmService, chatHistoryService, chartArtifactRepository);
        
        add(header, chat);
        setFlexGrow(1, chat);
    }
}===== ./src/main/java/org/emblow/envelopify/ui/views/RootView.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

import com.vaadin.flow.component.UI;
import com.vaadin.flow.router.BeforeEnterEvent;
import com.vaadin.flow.router.BeforeEnterObserver;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.server.auth.AnonymousAllowed;
/**
 *
 * @author Nicholas J Emblow
 */
@Route("")
@AnonymousAllowed
public class RootView implements BeforeEnterObserver {
    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        event.forwardTo(LoginView.class);
    }
}
===== ./src/main/java/org/emblow/envelopify/ui/views/DashboardView.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.grid.Grid;
import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.FlexComponent;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.router.RouteAlias;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.PatternService;
import org.emblow.envelopify.service.CSVImportService;
import org.emblow.envelopify.ui.components.EnvelopeCard;
import org.emblow.envelopify.ui.components.AccountCard;
import org.emblow.envelopify.ui.components.EnvelopeManagementDialogs;
import org.emblow.envelopify.ui.components.AccountDialog;
import org.emblow.envelopify.ui.components.TransactionManagementDialogs;
import org.emblow.envelopify.ui.components.CSVImportDialog;
import org.emblow.envelopify.ui.components.SpendingTrendsChart;
import java.time.LocalDateTime;
import java.util.List;
import org.emblow.envelopify.ui.MainLayout;

/**
 * DashboardView is the primary dashboard for an authenticated user.
 * <p>
 * This view includes multiple sections:
 * <ul>
 *   <li>A header with control buttons (new transaction, new envelope, new account, CSV import)</li>
 *   <li>An accounts section showing the current user's accounts</li>
 *   <li>An envelopes section showing the current user's envelopes</li>
 *   <li>A recent transactions section displaying a grid of transactions from the past month</li>
 *   <li>A spending trends chart based on recent transaction data</li>
 * </ul>
 * All data is obtained via service methods that filter by the current user.
 * </p>
 *
 * @author Nicholas J Emblow
 * @version 1.0
 * @since 2025
 */
@Route(value = "dashboard", layout = MainLayout.class)
@PageTitle("Dashboard | Envelofy")
@AnonymousAllowed
public class DashboardView extends VerticalLayout {

    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final TransactionService transactionService;
    private final PatternService patternService;
    private final CSVImportService csvImportService;  
    private final TransactionManagementDialogs txDialogs;
    private final EnvelopeManagementDialogs envelopeDialogs;
    
    private final Grid<Transaction> transactionGrid = new Grid<>(Transaction.class);
    private final VerticalLayout envelopesLayout = new VerticalLayout();
    private final VerticalLayout accountsLayout = new VerticalLayout();
    private SpendingTrendsChart trendsChart; 

    /**
     * Constructs a new DashboardView and initializes all UI components.
     *
     * @param envelopeService   the service used for envelope operations (filtered by user)
     * @param accountService    the service used for account operations (filtered by user)
     * @param transactionService the service used for transaction operations (filtered by user)
     * @param patternService    the service used for pattern analysis on transactions
     * @param csvImportService  the service used to import transactions from CSV files
     * @param txDialogs         the dialogs used for creating and editing transactions
     */
    public DashboardView(EnvelopeService envelopeService,
                         AccountService accountService,
                         TransactionService transactionService,
                         PatternService patternService,
                         CSVImportService csvImportService,
                         TransactionManagementDialogs txDialogs) {
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.transactionService = transactionService;
        this.patternService = patternService;
        this.csvImportService = csvImportService;
        this.txDialogs = txDialogs;
        this.envelopeDialogs = new EnvelopeManagementDialogs(envelopeService);
        
        addClassName("dashboard-view");
        setPadding(true);
        setSpacing(true);

        // Build and add the various sections of the dashboard.
        add(createHeader());
        add(createAccountsSection());
        add(createEnvelopesSection());
        add(createRecentTransactionsSection());
        
        // Create and add the spending trends chart.
        trendsChart = new SpendingTrendsChart(transactionService);
        add(trendsChart);
        
        // Load data for the current user.
        refreshData();
    }
    
    /**
     * Creates the header section which includes a title and control buttons.
     *
     * @return a HorizontalLayout containing header elements.
     */
    private HorizontalLayout createHeader() {
        HorizontalLayout header = new HorizontalLayout();
        header.setWidthFull();
        header.setPadding(true);
        header.setAlignItems(FlexComponent.Alignment.CENTER);
        header.setJustifyContentMode(FlexComponent.JustifyContentMode.BETWEEN);

        H2 title = new H2("Welcome to Envelofy");

        // Create a layout to hold control buttons.
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setSpacing(true);

        // Button to launch the new transaction dialog.
        Button newTransactionButton = new Button("New Transaction", new Icon(VaadinIcon.PLUS_CIRCLE),
                e -> showNewTransactionDialog());
        newTransactionButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        // Button to launch the new envelope dialog.
        Button newEnvelopeButton = new Button("New Envelope", new Icon(VaadinIcon.FOLDER_O),
                e -> showNewEnvelopeDialog());
        newEnvelopeButton.addThemeVariants(ButtonVariant.LUMO_SUCCESS);

        // Button to launch the new account dialog.
        Button newAccountButton = new Button("New Account", new Icon(VaadinIcon.PIGGY_BANK),
                e -> showNewAccountDialog());
        newAccountButton.addThemeVariants(ButtonVariant.LUMO_CONTRAST);

        // Button to open the CSV import dialog.
        Button importButton = new Button("Import CSV", new Icon(VaadinIcon.UPLOAD),
                e -> showImportDialog());
        importButton.addThemeVariants(ButtonVariant.LUMO_CONTRAST);

        buttons.add(importButton, newAccountButton, newTransactionButton, newEnvelopeButton);
        header.add(title, buttons);
        return header;
    }
    
    /**
     * Creates the accounts section of the dashboard.
     *
     * @return a VerticalLayout containing the accounts header and list.
     */
    private VerticalLayout createAccountsSection() {
        VerticalLayout section = new VerticalLayout();
        section.setPadding(false);
        section.setSpacing(true);
        section.setWidthFull();

        H3 title = new H3("Your Accounts");
        
        accountsLayout.setPadding(false);
        accountsLayout.setSpacing(true);
        accountsLayout.setWidthFull();
        
        section.add(title, accountsLayout);
        return section;
    }
    
    /**
     * Creates the envelopes section of the dashboard.
     *
     * @return a VerticalLayout containing the envelopes header and list.
     */
    private VerticalLayout createEnvelopesSection() {
        VerticalLayout section = new VerticalLayout();
        section.setPadding(false);
        section.setSpacing(true);
        section.setWidthFull();

        H3 title = new H3("Your Envelopes");
        
        envelopesLayout.setPadding(false);
        envelopesLayout.setSpacing(true);
        envelopesLayout.setWidthFull();
        
        section.add(title, envelopesLayout);
        return section;
    }
    
    /**
     * Creates the recent transactions section which displays a grid of transactions.
     *
     * @return a VerticalLayout containing the transactions header and grid.
     */
    private VerticalLayout createRecentTransactionsSection() {
        VerticalLayout section = new VerticalLayout();
        section.setPadding(false);
        section.setSpacing(true);
        section.setWidthFull();

        H3 title = new H3("Recent Transactions");
        configureTransactionGrid();
        section.add(title, transactionGrid);
        return section;
    }
    
    /**
     * Configures the transaction grid with necessary columns and sets up double-click editing.
     */
    private void configureTransactionGrid() {
        transactionGrid.setColumns("date", "description", "amount");
        transactionGrid.addColumn(tx -> tx.getAccount().getName())
                .setHeader("Account")
                .setKey("account");
        transactionGrid.addColumn(tx -> tx.getEnvelope().getName())
                .setHeader("Envelope")
                .setKey("envelope");
        transactionGrid.getColumns().forEach(col -> col.setAutoWidth(true));
        
        transactionGrid.setSelectionMode(Grid.SelectionMode.SINGLE);
        
        // Open the edit dialog when a transaction row is double-clicked.
        transactionGrid.addItemDoubleClickListener(event ->
            txDialogs.showEditTransactionDialog(event.getItem(), this::refreshData)
        );
    }
    
    /**
     * Opens the new transaction dialog.
     */
    private void showNewTransactionDialog() {
        txDialogs.showNewTransactionDialog(this::refreshData);
    }
    
    /**
     * Opens the new envelope dialog.
     */
    private void showNewEnvelopeDialog() {
        envelopeDialogs.showNewEnvelopeDialog(this::refreshData);
    }
    
    /**
     * Opens the new account dialog.
     */
    private void showNewAccountDialog() {
        new AccountDialog(accountService, this::refreshData).open();
    }
    
    /**
     * Opens the CSV import dialog.
     */
    private void showImportDialog() {
        new CSVImportDialog(csvImportService, envelopeService, accountService, this::refreshData).open();
    }
    
    /**
     * Refreshes the dashboard data by reloading accounts, envelopes, and recent transactions.
     * This method calls the service methods that return data only for the current user.
     */
    private void refreshData() {
        // Refresh accounts.
        List<Account> accounts = accountService.getAllAccounts();
        refreshAccounts(accounts);

        // Refresh envelopes.
        List<Envelope> envelopes = envelopeService.getAllEnvelopes();
        refreshEnvelopes(envelopes);

        // Refresh recent transactions for the past month.
        LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
        List<Transaction> recentTransactions = 
                transactionService.getRecentTransactions(oneMonthAgo, LocalDateTime.now());
        transactionGrid.setItems(recentTransactions);
    }
    
    /**
     * Updates the accounts layout with the given list of accounts.
     *
     * @param accounts the list of accounts belonging to the current user
     */
    private void refreshAccounts(List<Account> accounts) {
        accountsLayout.removeAll();
        
        if (accounts.isEmpty()) {
            accountsLayout.add(new H3("No accounts yet. Add your first account to get started!"));
            return;
        }

        HorizontalLayout row = new HorizontalLayout();
        row.setWidthFull();
        row.setSpacing(true);
        
        for (Account account : accounts) {
            if (row.getComponentCount() >= 3) {
                accountsLayout.add(row);
                row = new HorizontalLayout();
                row.setWidthFull();
                row.setSpacing(true);
            }
            row.add(new AccountCard(account, accountService, this::refreshData));
        }
        
        if (row.getComponentCount() > 0) {
            accountsLayout.add(row);
        }
    }
    
    /**
     * Updates the envelopes layout with the given list of envelopes.
     *
     * @param envelopes the list of envelopes belonging to the current user
     */
    private void refreshEnvelopes(List<Envelope> envelopes) {
        envelopesLayout.removeAll();
        
        if (envelopes.isEmpty()) {
            envelopesLayout.add(new H3("No envelopes yet. Create your first envelope to get started!"));
            return;
        }

        HorizontalLayout row = new HorizontalLayout();
        row.setWidthFull();
        row.setSpacing(true);
        
        for (Envelope envelope : envelopes) {
            if (row.getComponentCount() >= 3) {
                envelopesLayout.add(row);
                row = new HorizontalLayout();
                row.setWidthFull();
                row.setSpacing(true);
            }
            row.add(new EnvelopeCard(envelope, envelopeDialogs));
        }
        
        if (row.getComponentCount() > 0) {
            envelopesLayout.add(row);
        }
    }
}
===== ./src/main/java/org/emblow/envelopify/ui/views/ErrorView.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

import com.vaadin.flow.component.html.H1;
import com.vaadin.flow.component.html.Paragraph;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import com.vaadin.flow.router.BeforeEnterEvent;
import com.vaadin.flow.router.ErrorParameter;
import com.vaadin.flow.router.HasErrorParameter;
import com.vaadin.flow.router.NotFoundException;
import com.vaadin.flow.router.PageTitle;
import jakarta.servlet.http.HttpServletResponse;

@PageTitle("Not Found")
public class ErrorView extends VerticalLayout implements HasErrorParameter<NotFoundException> {

    public ErrorView() {
        setSizeFull();
        setJustifyContentMode(JustifyContentMode.CENTER);
        setAlignItems(Alignment.CENTER);
        
        add(
            new H1("404"),
            new Paragraph("The page you're looking for does not exist")
        );
    }

    @Override
    public int setErrorParameter(BeforeEnterEvent event, ErrorParameter<NotFoundException> parameter) {
        return HttpServletResponse.SC_NOT_FOUND;
    }
}===== ./src/main/java/org/emblow/envelopify/ui/views/InsightsView.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.ui.MainLayout;
import org.emblow.envelopify.ui.components.InsightsPanel;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.emblow.envelopify.service.ml.SpendingInsight;

import java.util.List;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.notification.Notification;
import java.util.ArrayList;
import java.util.stream.Collectors;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.ml.AdvancedMLService;
import org.emblow.envelopify.service.ml.SpendingInsightType;
import org.emblow.envelopify.ui.components.SpendingTrendsChart;

@Route(value = "insights", layout = MainLayout.class)
@PageTitle("Smart Insights | Envelofy")
@AnonymousAllowed
public class InsightsView extends VerticalLayout {
    
    private final SpendingInsightService insightService;
    private final TransactionService transactionService;
    private final InsightsPanel regularInsights;
    private final InsightsPanel predictiveInsights;
    private final SpendingTrendsChart trendsChart; 
    private final AdvancedMLService mlService;
    
     public InsightsView(SpendingInsightService insightService, 
                       TransactionService transactionService,
                       AdvancedMLService mlService) { // Add to constructor
        this.mlService = mlService;
        this.insightService = insightService;
        this.transactionService = transactionService;
        
        addClassName("insights-view");
        setSizeFull();
        setSpacing(true);
        setPadding(true);

        // Header with refresh button
        HorizontalLayout header = new HorizontalLayout();
        header.setWidthFull();
        header.setJustifyContentMode(JustifyContentMode.BETWEEN);
        header.setAlignItems(Alignment.CENTER);

        H2 title = new H2("Smart Insights");
        Button refreshButton = new Button(
            "Refresh Insights", 
            new Icon(VaadinIcon.REFRESH),
            e -> refreshInsights()
        );
        refreshButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        header.add(title, refreshButton);

        // Create spending trends chart card
        Div chartCard = new Div();
        chartCard.addClassName("chart-card");
        chartCard.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("box-shadow", "var(--lumo-box-shadow-s)")
            .set("padding", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-m)");

        H2 chartTitle = new H2("Monthly Spending Trends");
        chartTitle.getStyle()
            .set("margin-top", "0")
            .set("margin-bottom", "var(--lumo-space-m)");

        trendsChart = new SpendingTrendsChart(transactionService);

        chartCard.add(chartTitle, trendsChart);
  
        // Create layout for insights panels
        HorizontalLayout content = new HorizontalLayout();
        content.setWidthFull();
        content.setSpacing(true);
        
        // Create two columns for different types of insights
        VerticalLayout leftColumn = new VerticalLayout();
        leftColumn.setPadding(false);
        leftColumn.setSpacing(true);
        leftColumn.setWidth("50%");
        leftColumn.add(new H2("Current Insights"));
        
        VerticalLayout rightColumn = new VerticalLayout();
        rightColumn.setPadding(false);
        rightColumn.setSpacing(true);
        rightColumn.setWidth("50%");
        rightColumn.add(new H2("Predictive Insights"));
        
        // Initialize insights panels
        regularInsights = new InsightsPanel();
        predictiveInsights = new InsightsPanel();
        
        leftColumn.add(regularInsights);
        rightColumn.add(predictiveInsights);
        content.add(leftColumn, rightColumn);

        // Add everything to main layout
        add(header, content);

        // Initial data load
        refreshInsights();
    }

    private void refreshInsights() {
        try {
            // 1. Retrieve regular insights from the existing service.
            List<SpendingInsight> allInsights = insightService.generateInsights();

            // 2. Get ML-based analysis for all accounts.
            List<AdvancedMLService.AccountAnalysis> analyses = mlService.analyzeAccounts();
            List<SpendingInsight> mlInsights = new ArrayList<>();

            // 3. Map ML analysis results to SpendingInsight objects.
            for (AdvancedMLService.AccountAnalysis analysis : analyses) {
                // --- Map anomalies ---
                for (AdvancedMLService.AnomalyDetection anomaly : analysis.getAnomalies()) {
                    if (anomaly.type() == AdvancedMLService.AnomalyType.AMOUNT) {
                        mlInsights.add(new SpendingInsight(
                            SpendingInsightType.UNUSUAL_SPENDING,
                            anomaly.description(),
                            anomaly.severity()  // Use anomaly severity as confidence
                        ));
                    } else if (anomaly.type() == AdvancedMLService.AnomalyType.FREQUENCY) {
                        // Optionally map frequency anomalies to recurring payments as well.
                        mlInsights.add(new SpendingInsight(
                            SpendingInsightType.RECURRING_PAYMENT,
                            anomaly.description(),
                            anomaly.severity()
                        ));
                    }
                }

                // --- Map recurring payments from merchant metrics ---
                analysis.getMerchantMetrics().forEach((merchant, metrics) -> {
                    // If the merchant has a high monthly frequency (e.g., at least one transaction per month)
                    if (metrics.monthlyFrequency() >= 1.0) {
                        mlInsights.add(new SpendingInsight(
                            SpendingInsightType.RECURRING_PAYMENT,
                            "Recurring payment detected at " + merchant + " (monthly frequency: " +
                                String.format("%.1f", metrics.monthlyFrequency()) + ")",
                            Math.min(1.0, metrics.monthlyFrequency() / 5.0)  // Arbitrary normalization
                        ));
                    }
                });

                // --- Map predicted expense from overall spending trend ---
                if (analysis.getVolumeTrend() > 0.2) { // Upward trend threshold (adjust as needed)
                    mlInsights.add(new SpendingInsight(
                        SpendingInsightType.PREDICTED_EXPENSE,
                        "Your spending is trending upward for account " + analysis.getAccount().getName() +
                            ". Consider revising your budget.",
                        0.8  // Example confidence value
                    ));
                }

                // --- Map budget suggestions from envelope metrics ---
                analysis.getEnvelopeMetrics().forEach((envelope, envMetrics) -> {
                    // If the envelope's budget utilization is high (e.g., over 90%)
                    if (envMetrics.budgetUtilization() > 0.9) {
                        // Assuming your Envelope domain object has a getName() method.
                        mlInsights.add(new SpendingInsight(
                            SpendingInsightType.BUDGET_SUGGESTION,
                            "Your envelope " + envelope.getName() + " is at " +
                                String.format("%.0f%%", envMetrics.budgetUtilization() * 100) +
                                " of its budget. Consider adjusting your budget.",
                            envMetrics.budgetUtilization()
                        ));
                    }
                });

                // --- Map seasonal patterns ---
                if (analysis.getVolumeTrend() < -0.2) { // Downward trend threshold (adjust as needed)
                    mlInsights.add(new SpendingInsight(
                        SpendingInsightType.SEASONAL_PATTERN,
                        "Your spending trend indicates a seasonal downturn for account " +
                            analysis.getAccount().getName() + ".",
                        0.75
                    ));
                }

                // --- Map reallocation suggestions from cross-account analysis ---
                AdvancedMLService.CrossAccountMetrics crossMetrics = analysis.getCrossAccountMetrics();
                if (crossMetrics != null && !crossMetrics.sharedMerchants().isEmpty()) {
                    mlInsights.add(new SpendingInsight(
                        SpendingInsightType.REALLOCATION_SUGGESTION,
                        "Your spending patterns share similarities with other accounts. Consider reallocation of funds.",
                        0.75  
                    ));
                }
            }

            // Merge regular insights with ML-based insights.
            allInsights.addAll(mlInsights);

            // 4. Split the insights into two categories: current and predictive.
            List<SpendingInsight> current = allInsights.stream()
                .filter(i -> i.getType() == SpendingInsightType.UNUSUAL_SPENDING ||
                             i.getType() == SpendingInsightType.RECURRING_PAYMENT ||
                             i.getType() == SpendingInsightType.BUDGET_SUGGESTION)
                .collect(Collectors.toList());

            List<SpendingInsight> predictive = allInsights.stream()
                .filter(i -> i.getType() == SpendingInsightType.PREDICTED_EXPENSE ||
                             i.getType() == SpendingInsightType.SEASONAL_PATTERN ||
                             i.getType() == SpendingInsightType.REALLOCATION_SUGGESTION)
                .collect(Collectors.toList());

            // 5. Update the InsightsPanel components.
            regularInsights.setInsights(current);
            predictiveInsights.setInsights(predictive);

        } catch (Exception e) {
            Notification.show(
                "Error loading insights: " + e.getMessage(),
                3000,
                Notification.Position.MIDDLE
            );
        }
    }


}
===== ./src/main/java/org/emblow/envelopify/ui/views/AccountView.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

import com.vaadin.flow.component.Component;
import com.vaadin.flow.component.UI;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.datepicker.DatePicker;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.grid.Grid;
import com.vaadin.flow.component.html.*;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.FlexComponent;
import com.vaadin.flow.component.progressbar.ProgressBar;
import com.vaadin.flow.component.tabs.Tab;
import com.vaadin.flow.component.tabs.Tabs;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.router.BeforeEvent;
import com.vaadin.flow.router.HasUrlParameter;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.regex.PatternSyntaxException;
import java.util.stream.Collectors;

import org.emblow.envelopify.domain.*;
import org.emblow.envelopify.exception.AccountException;
import org.emblow.envelopify.service.*;
import org.emblow.envelopify.service.ml.*;
import org.emblow.envelopify.ui.MainLayout;
import org.emblow.envelopify.ui.components.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Route(value = "accounts", layout = MainLayout.class)
@PageTitle("Account Details | Envelofy")
public class AccountView extends VerticalLayout implements HasUrlParameter<Long> {
    private static final Logger log = LoggerFactory.getLogger(AccountView.class);

    private final AccountService accountService;
    private final TransactionService transactionService;
    private final TransactionManagementDialogs transactionDialogs;
    private final CSVImportService csvImportService;
    private final SpendingInsightService spendingInsightService;
    private final AdvancedMLService advancedMLService;
    private final PatternService patternService;
    private final EnvelopeService envelopeService;
    private Tabs tabs; 
    private Account currentAccount;
    private final Grid<Transaction> transactionGrid;
    private AccountBalanceChart balanceChart;
    private SpendingTrendsChart trendsChart;
    private TextField searchField;

    public AccountView(
        AccountService accountService,
        TransactionService transactionService,
        TransactionManagementDialogs transactionDialogs,
        CSVImportService csvImportService,
        SpendingInsightService spendingInsightService,
        AdvancedMLService advancedMLService,
        PatternService patternService,
        EnvelopeService envelopeService
    ) {
        this.accountService = accountService;
        this.transactionService = transactionService;
        this.transactionDialogs = transactionDialogs;
        this.csvImportService = csvImportService;
        this.spendingInsightService = spendingInsightService;
        this.advancedMLService = advancedMLService;
        this.patternService = patternService;
        this.envelopeService = envelopeService;
        
        setSizeFull();
        setPadding(true);
        setSpacing(true);

        transactionGrid = new Grid<>();
        configureTransactionGrid();
    }

    @Override
    public void setParameter(BeforeEvent event, Long accountId) {
        try {
            log.info("Loading account with ID: {}", accountId);

            // First load the account
            currentAccount = accountService.getAccount(accountId);
            log.info("Successfully loaded account: {}", currentAccount.getName());

            // Now make sure all required services are available
            if (transactionService == null || envelopeService == null || 
                spendingInsightService == null || advancedMLService == null) {
                throw new IllegalStateException("Required services not initialized");
            }

            // Initialize the layout components
            log.info("Initializing view layout");
            updateView();
            log.info("View initialization complete");

        } catch (AccountException e) {
            log.error("Account access error for ID {}: {}", accountId, e.getMessage());
            Notification.show("Error: " + e.getMessage(), 3000, Notification.Position.MIDDLE);
            UI.getCurrent().navigate("dashboard");
        } catch (Exception e) {
            log.error("Unexpected error loading account {}: {}", accountId, e.getMessage(), e);
            Notification.show("Unexpected error loading account: " + e.getMessage(), 
                             5000, Notification.Position.MIDDLE);
            UI.getCurrent().navigate("dashboard");
        }
    }

    private void updateView() {
        removeAll();

        add(createAccountOverviewCard(), createActionBar());

        // Create tabs
        Tabs navigationTabs = new Tabs();
        Div pages = new Div();
        pages.setWidthFull();

        // Overview tab
        Tab overviewTab = new Tab("Overview");
        Div overviewPage = new Div();
        overviewPage.add(
            createChartSection(),
            createAnalysisSection()
        );

        // Transactions tab
        Tab transactionsTab = new Tab("Transactions");
        Div transactionsPage = new Div();
        transactionsPage.add(createTransactionSection());

        // Analytics tab
        Tab analyticsTab = new Tab("Analytics");
        Div analyticsPage = new Div();
        analyticsPage.add(
            createBudgetHealthSection(),
            createSpendingPatternsSection()
        );

        // AI Insights tab
        Tab insightsTab = new Tab("AI Insights");
        Div insightsPage = new Div();
        insightsPage.add(
            createAIInsightsSection(),
            createAnomalySection(),
            createEnvelopeRecommendationsSection()
        );

        navigationTabs.add(overviewTab, transactionsTab, analyticsTab, insightsTab);
        pages.add(overviewPage, transactionsPage, analyticsPage, insightsPage);

        // Set up tab behavior
        for (Component page : pages.getChildren().collect(Collectors.toList())) {
            page.setVisible(false);
        }
        overviewPage.setVisible(true);

        navigationTabs.addSelectedChangeListener(event -> {
            for (Component page : pages.getChildren().collect(Collectors.toList())) {
                page.setVisible(false);
            }
            if (event.getSelectedTab().equals(overviewTab)) {
                overviewPage.setVisible(true);
            } else if (event.getSelectedTab().equals(transactionsTab)) {
                transactionsPage.setVisible(true);
            } else if (event.getSelectedTab().equals(analyticsTab)) {
                analyticsPage.setVisible(true);
            } else if (event.getSelectedTab().equals(insightsTab)) {
                insightsPage.setVisible(true);
            }
        });

        add(navigationTabs, pages);
        updateTransactionList(null,"");
    }

    private Div createAccountOverviewCard() {
        Div card = new Div();
        card.addClassName("account-overview-card");
        card.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("padding", "var(--lumo-space-l)")
            .set("margin-bottom", "var(--lumo-space-m)")
            .set("box-shadow", "var(--lumo-box-shadow-xs)");

        H2 accountName = new H2(currentAccount.getName());
        
        Span typeBadge = new Span(currentAccount.getType().getDisplayName());
        typeBadge.getStyle()
            .set("background-color", "var(--lumo-primary-color-10pct)")
            .set("color", "var(--lumo-primary-text-color)")
            .set("padding", "var(--lumo-space-xs) var(--lumo-space-s)")
            .set("border-radius", "var(--lumo-border-radius-m)")
            .set("font-size", "var(--lumo-font-size-s)");

        Span balance = new Span(String.format("Balance: $%.2f", currentAccount.getBalance()));
        balance.getStyle()
            .set("font-size", "var(--lumo-font-size-xl)")
            .set("font-weight", "bold")
            .set("color", currentAccount.getBalance().signum() >= 0 ? 
                "var(--lumo-success-text-color)" : 
                "var(--lumo-error-text-color)");

        if (currentAccount.getInstitution() != null) {
            Span institution = new Span(currentAccount.getInstitution());
            institution.getStyle()
                .set("color", "var(--lumo-secondary-text-color)")
                .set("font-size", "var(--lumo-font-size-s)");
            card.add(institution);
        }

        card.add(accountName, typeBadge, balance);
        return card;
    }

    private HorizontalLayout createActionBar() {
        HorizontalLayout actionBar = new HorizontalLayout();
        actionBar.setWidthFull();
        actionBar.setSpacing(true);
        actionBar.setPadding(true);
        actionBar.getStyle()
            .set("background-color", "var(--lumo-contrast-5pct)")
            .set("border-radius", "var(--lumo-border-radius-m)")
            .set("margin-bottom", "var(--lumo-space-m)");

        Button newTransactionBtn = new Button(
            "New Transaction",
            new Icon(VaadinIcon.PLUS),
            e -> transactionDialogs.showNewTransactionDialog(
                this::refreshData, 
                currentAccount
            )
        );
        newTransactionBtn.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        Button importBtn = new Button(
            "Import Transactions",
            new Icon(VaadinIcon.UPLOAD),
            e -> new CSVImportDialog(
                csvImportService,
                envelopeService,
                accountService,  
                this::refreshData
            ).open()
        );

        Button editBtn = new Button(
            "Edit Account",
            new Icon(VaadinIcon.EDIT),
            e -> new AccountDialog(
                accountService,
                this::refreshData,
                currentAccount
            ).open()
        );

        actionBar.add(newTransactionBtn, importBtn, editBtn);
        return actionBar;
    }

    private Div createChartSection() {
        Div chartSection = new Div();
        chartSection.setWidthFull();
        chartSection.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("padding", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-m)")
            .set("box-shadow", "var(--lumo-box-shadow-xs)")
            .set("display", "flex")           // Ensure layout control
            .set("flex-direction", "column"); // Stack children vertically

        HorizontalLayout topCharts = new HorizontalLayout();
        topCharts.setWidthFull();
        topCharts.setSpacing(true);

        Div balanceChartDiv = new Div();
        balanceChartDiv.setWidthFull();
        H3 balanceTitle = new H3("Balance History");
        balanceChart = new AccountBalanceChart(currentAccount);
        balanceChart.getElement().getStyle().set("height", "300px");
        balanceChartDiv.add(balanceTitle, balanceChart);

        Div categoryChartDiv = new Div();
        categoryChartDiv.setWidthFull();
        H3 categoryTitle = new H3("Spending by Category");
        SpendingCategoryChart categoryChart = new SpendingCategoryChart(currentAccount);
        categoryChart.getElement().getStyle().set("height", "300px");
        categoryChartDiv.add(categoryTitle, categoryChart);

        topCharts.add(balanceChartDiv, categoryChartDiv);

        H3 trendsTitle = new H3("Monthly Spending Trends");
        SpendingTrendsChart_Accounts trendsChart = new SpendingTrendsChart_Accounts(currentAccount);
        trendsChart.getElement().getStyle()
            .set("height", "300px")
            .set("flex-grow", "1"); // Allow it to take available space

        chartSection.add(topCharts, trendsTitle, trendsChart);
        chartSection.setHeight("auto"); // Let content dictate height
        return chartSection;
    }

    private Div createAIInsightsSection() {
        Div section = new Div();
        section.setWidthFull();
        section.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("padding", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-m)");

        List<SpendingInsight> insights = spendingInsightService.generateInsights()
            .stream()
            .filter(i -> i.getMessage().contains(currentAccount.getName()))
            .collect(Collectors.toList());

        AdvancedMLService.AccountAnalysis analysis = advancedMLService.analyzeAccounts()
            .stream()
            .filter(a -> a.getAccount().getId().equals(currentAccount.getId()))
            .findFirst()
            .orElse(null);

        List<AdvancedMLService.AnomalyDetection> anomalies = 
            advancedMLService.detectAnomaliesForAccount(currentAccount.getTransactions());

        // Add summary at the top
        section.add(createInsightSummary(insights, analysis, anomalies));

        if (!insights.isEmpty()) {
            insights.forEach(insight -> {
                Div card = new Div();
                card.addClassName("insight-card");
                card.getStyle()
                    .set("padding", "var(--lumo-space-m)")
                    .set("margin-bottom", "var(--lumo-space-s)")
                    .set("border-radius", "var(--lumo-border-radius-m)")
                    .set("background-color", "var(--lumo-contrast-5pct)");

                Icon icon = getInsightIcon(insight.getType());
                icon.setColor(getInsightColor(insight.getType()));

                Span message = new Span(insight.getMessage());
                message.getStyle().set("margin-left", "var(--lumo-space-s)");

                ProgressBar confidence = new ProgressBar();
                confidence.setValue(insight.getConfidence());
                confidence.setWidth("100%");

                card.add(new HorizontalLayout(icon, message), confidence);
                section.add(card);
            });
        }

        if (analysis != null && !analysis.getMerchantMetrics().isEmpty()) {
            H4 merchantTitle = new H4("Top Merchant Analysis");
            Grid<Map.Entry<String, AdvancedMLService.MerchantMetrics>> merchantGrid = new Grid<>();
            
            merchantGrid.setItems(analysis.getMerchantMetrics().entrySet().stream()
                .sorted((e1, e2) -> Double.compare(e2.getValue().totalSpent(), e1.getValue().totalSpent()))
                .limit(5)
                .collect(Collectors.toList()));

            merchantGrid.addColumn(Map.Entry::getKey)
                .setHeader("Merchant")
                .setAutoWidth(true);
            merchantGrid.addColumn(e -> String.format("$%.2f", e.getValue().totalSpent()))
                .setHeader("Total Spent")
                .setAutoWidth(true);
            merchantGrid.addColumn(e -> String.format("%.1f/month", e.getValue().monthlyFrequency()))
                .setHeader("Frequency")
                .setAutoWidth(true);

            section.add(merchantTitle, merchantGrid);
        }

        return section;
    }

    private Div createBudgetHealthSection() {
        Div section = new Div();
        section.setWidthFull();
        section.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("padding", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-m)");

        AdvancedMLService.AccountAnalysis analysis = advancedMLService.analyzeAccounts()
            .stream()
            .filter(a -> a.getAccount().getId().equals(currentAccount.getId()))
            .findFirst()
            .orElse(null);

        if (analysis != null) {
            H3 title = new H3("Budget Health");

            // Balance trend indicator
            Div trendSection = new Div();
            String trendDescription = analysis.getVolumeTrend() > 0 ? 
                "Increasing" : analysis.getVolumeTrend() < 0 ? "Decreasing" : "Stable";
            trendSection.add(
                new H4("Balance Trend: " + trendDescription),
                new Span(String.format("%.1f%% per month", analysis.getVolumeTrend() * 100))
            );

            // Monthly volume
            Div volumeSection = new Div();
            volumeSection.add(
                new H4("Average Monthly Volume"),
                new Span(String.format("$%.2f", analysis.getAverageMonthlyVolume()))
            );

            section.add(title, trendSection, volumeSection);

            // Add envelope metrics if available
            if (!analysis.getEnvelopeMetrics().isEmpty()) {
                H4 envelopeTitle = new H4("Envelope Health");
                Grid<Map.Entry<Envelope, AdvancedMLService.EnvelopeMetrics>> envelopeGrid = new Grid<>();
                
                envelopeGrid.setItems(analysis.getEnvelopeMetrics().entrySet());
                envelopeGrid.addColumn(e -> e.getKey().getName())
                    .setHeader("Envelope")
                    .setAutoWidth(true);
                envelopeGrid.addColumn(e -> String.format("%.1f%%", e.getValue().budgetUtilization() * 100))
                    .setHeader("Budget Utilization")
                    .setAutoWidth(true);
                envelopeGrid.addColumn(e -> String.format("$%.2f", e.getValue().totalSpent()))
                    .setHeader("Total Spent")
                    .setAutoWidth(true);
                envelopeGrid.addColumn(e -> {
                    double trend = e.getValue().spendingTrend();
                    return String.format("%s%.1f%%", trend > 0 ? "+" : "", trend * 100);
                })
                    .setHeader("Trend")
                    .setAutoWidth(true);

                section.add(envelopeTitle, envelopeGrid);
            }
        }

        return section;
    }

    private Div createSpendingPatternsSection() {
        Div section = new Div();
        section.setWidthFull();
        section.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("padding", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-m)");

        H3 title = new H3("Spending Patterns");

        // Get account analysis
        AdvancedMLService.AccountAnalysis analysis = advancedMLService.analyzeAccounts()
            .stream()
            .filter(a -> a.getAccount().getId().equals(currentAccount.getId()))
            .findFirst()
            .orElse(null);

        if (analysis != null) {
            // Day of week patterns
            H4 dowTitle = new H4("Day of Week Patterns");
            Grid<Map.Entry<java.time.DayOfWeek, Double>> dowGrid = new Grid<>();
            dowGrid.setItems(analysis.getDayOfWeekPatterns().entrySet());
            dowGrid.addColumn(e -> e.getKey().toString())
                .setHeader("Day")
                .setAutoWidth(true);
            dowGrid.addColumn(e -> String.format("$%.2f", e.getValue()))
                .setHeader("Average Spending")
                .setAutoWidth(true);

            // Merchant patterns
            H4 merchantTitle = new H4("Merchant Patterns");
            Grid<Map.Entry<String, AdvancedMLService.MerchantMetrics>> merchantGrid = new Grid<>();
            merchantGrid.setItems(analysis.getMerchantMetrics().entrySet().stream()
                .filter(e -> e.getValue().monthlyFrequency() > 0.5)
                .collect(Collectors.toList()));
            merchantGrid.addColumn(Map.Entry::getKey)
                .setHeader("Merchant")
                .setAutoWidth(true);
            merchantGrid.addColumn(e -> String.format("Every %.1f days", e.getValue().averageDaysBetween()))
                .setHeader("Frequency")
                .setAutoWidth(true);
            merchantGrid.addColumn(e -> String.format("$%.2f", e.getValue().averageAmount()))
                .setHeader("Average Amount")
                .setAutoWidth(true);

            section.add(title, dowTitle, dowGrid, merchantTitle, merchantGrid);
        }

        return section;
    }

    private Div createAnomalySection() {
        Div section = new Div();
        section.setWidthFull();
        section.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("padding", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-m)");

        H3 title = new H3("Anomaly Detection");

        List<AdvancedMLService.AnomalyDetection> anomalies = 
            advancedMLService.detectAnomaliesForAccount(currentAccount.getTransactions());

        if (!anomalies.isEmpty()) {
            Grid<AdvancedMLService.AnomalyDetection> grid = new Grid<>();
            grid.setItems(anomalies);
            
            grid.addColumn(AdvancedMLService.AnomalyDetection::description)
                .setHeader("Description")
                .setAutoWidth(true);
            grid.addColumn(a -> String.format("%.1f", a.severity()))
                .setHeader("Severity")
                .setAutoWidth(true);
            grid.addComponentColumn(anomaly -> {
                ProgressBar severity = new ProgressBar();
                severity.setValue(anomaly.severity() / 5.0); // Normalize to 0-1
                return severity;
            })
                .setHeader("Impact")
                .setAutoWidth(true);

            section.add(title, grid);
        } else {
            Span noAnomalies = new Span("No anomalies detected");
            noAnomalies.getStyle().set("color", "var(--lumo-success-text-color)");
            section.add(title, noAnomalies);
        }

        return section;
    }

    private Div createEnvelopeRecommendationsSection() {
        Div section = new Div();
        section.setWidthFull();
        section.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("padding", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-m)");

        H3 title = new H3("Envelope Recommendations");

        // Get suggestions for recent transactions
        List<Transaction> recentTransactions = transactionService.getRecentTransactions(
            LocalDateTime.now().minusWeeks(2),
            LocalDateTime.now()
        );

        if (!recentTransactions.isEmpty()) {
            Grid<Transaction> grid = new Grid<>();
            grid.setItems(recentTransactions);
            
            grid.addColumn(Transaction::getDescription)
                .setHeader("Transaction")
                .setAutoWidth(true);
            grid.addColumn(tx -> String.format("$%.2f", tx.getAmount()))
                .setHeader("Amount")
                .setAutoWidth(true);
            grid.addColumn(tx -> tx.getEnvelope().getName())
                .setHeader("Current Envelope")
                .setAutoWidth(true);
            grid.addComponentColumn(tx -> {
                // Get envelope suggestions
                Map<Envelope, Double> suggestions = patternService.suggestEnvelopes(tx);
                if (!suggestions.isEmpty()) {
                    Map.Entry<Envelope, Double> topSuggestion = suggestions.entrySet().stream()
                        .max(Map.Entry.comparingByValue())
                        .get();
                    
                    if (!topSuggestion.getKey().equals(tx.getEnvelope())) {
                        Button changeBtn = new Button(
                            String.format("Change to %s (%.0f%% match)", 
                                topSuggestion.getKey().getName(),
                                topSuggestion.getValue() * 100
                            ),
                            e -> {
                                // Update transaction envelope
                                transactionService.updateTransaction(
                                    tx.getId(),
                                    topSuggestion.getKey().getId(),
                                    tx.getAccount().getId(),
                                    tx.getDate(),
                                    tx.getDescription(),
                                    tx.getAmount(),
                                    tx.getType()
                                );
                                refreshData();
                            }
                        );
                        changeBtn.addThemeVariants(ButtonVariant.LUMO_SMALL);
                        return changeBtn;
                    }
                }
                return new Span("Best match");
            })
                .setHeader("Suggestion")
                .setAutoWidth(true);

            section.add(title, grid);
        } else {
            section.add(title, new Span("No recent transactions to analyze"));
        }

        return section;
    }

    private Div createAnalysisSection() {
        Div section = new Div();
        section.setWidthFull();
        section.getStyle()
            .set("display", "flex")
            .set("gap", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-m)");

        // Monthly spending card
        Div spendingCard = createMetricCard(
            "Monthly Spending",
            calculateMonthlySpending(),
            "var(--lumo-primary-color)"
        );

        // Income card
        Div incomeCard = createMetricCard(
            "Monthly Income",
            calculateMonthlyIncome(),
            "var(--lumo-success-color)"
        );

        // Transaction count card
        Div countCard = createMetricCard(
            "Transaction Count",
            String.valueOf(currentAccount.getTransactions().size()),
            "var(--lumo-contrast-color)"
        );

        section.add(spendingCard, incomeCard, countCard);
        return section;
    }

    private VerticalLayout createTransactionSection() {
        VerticalLayout section = new VerticalLayout();
        section.setPadding(false);
        section.setSpacing(true);
        
        // Add filtering controls
        HorizontalLayout filterBar = new HorizontalLayout();
        
        DatePicker startDate = new DatePicker("Start Date");
        DatePicker endDate = new DatePicker("End Date");
        
        searchField = new TextField();
        searchField.setPlaceholder("Search transactions...");
        searchField.setPrefixComponent(new Icon(VaadinIcon.SEARCH));
        
        searchField.addValueChangeListener(e -> {
            // Get current selected tab for transaction type
            Tab selectedTab = tabs.getSelectedTab();
            TransactionType type = null;
            if (selectedTab != null) {
                switch (selectedTab.getLabel()) {
                    case "Income" -> type = TransactionType.INCOME;
                    case "Expenses" -> type = TransactionType.EXPENSE;
                }
            }
            
            // Apply date filters and search
            String searchPattern = e.getValue();
            List<Transaction> filtered = currentAccount.getTransactions().stream()
                .filter(tx -> {
                    boolean matchesDate = true;
                    if (startDate.getValue() != null) {
                        matchesDate = !tx.getDate().toLocalDate().isBefore(startDate.getValue());
                    }
                    if (endDate.getValue() != null) {
                        matchesDate = matchesDate && !tx.getDate().toLocalDate().isAfter(endDate.getValue());
                    }
                    return matchesDate;
                })
                .collect(Collectors.toList());
                
            transactionGrid.setItems(filtered);
            updateTransactionList(type, searchPattern);
        });

        Button filterButton = new Button("Apply Filters", e -> {
            searchField.getElement().callJsFunction("focus");
            searchField.setValue(searchField.getValue()); // Trigger search with date filters
        });
        
        filterBar.add(startDate, endDate, searchField, filterButton);
        
        // Add transaction tabs
        tabs = new Tabs();
        Tab allTab = new Tab("All Transactions");
        Tab incomingTab = new Tab("Income");
        Tab outgoingTab = new Tab("Expenses");
        tabs.add(allTab, incomingTab, outgoingTab);

        tabs.addSelectedChangeListener(event -> {
            switch (event.getSelectedTab().getLabel()) {
                case "All Transactions" -> updateTransactionList(null, searchField.getValue());
                case "Income" -> updateTransactionList(TransactionType.INCOME, searchField.getValue());
                case "Expenses" -> updateTransactionList(TransactionType.EXPENSE, searchField.getValue());
            }
        });

        section.add(filterBar, tabs, transactionGrid);
        return section;
    }
    
    private Div createInsightSummary(List<SpendingInsight> insights, 
                                    AdvancedMLService.AccountAnalysis analysis, 
                                    List<AdvancedMLService.AnomalyDetection> anomalies) {
        Div summaryCard = new Div();
        summaryCard.getStyle()
            .set("background-color", "var(--lumo-contrast-5pct)")
            .set("border-radius", "var(--lumo-border-radius-m)")
            .set("padding", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-l)");

        H4 summaryTitle = new H4("Key Takeaways");
        summaryCard.add(summaryTitle);

        // Build summary points
        VerticalLayout points = new VerticalLayout();
        points.setSpacing(true);
        points.setPadding(false);

        // Spending trends
        if (analysis != null) {
            String trendDescription = analysis.getVolumeTrend() > 0.1 ? 
                "increasing" : analysis.getVolumeTrend() < -0.1 ? 
                "decreasing" : "stable";
            double trendPercent = Math.abs(analysis.getVolumeTrend() * 100);

            Span trend = new Span(String.format("ðŸ“ˆ Spending is %s (%.1f%% per month)", 
                trendDescription, trendPercent));
            points.add(trend);
        }

        // Most significant insights
        insights.stream()
            .filter(i -> i.getConfidence() > 0.8)  // Only high confidence insights
            .forEach(insight -> {
                String emoji = switch (insight.getType()) {
                    case RECURRING_PAYMENT -> "ðŸ”„";
                    case UNUSUAL_SPENDING -> "âš ï¸";
                    case PREDICTED_EXPENSE -> "ðŸ“…";
                    case BUDGET_SUGGESTION -> "ðŸ’°";
                    case SEASONAL_PATTERN -> "ðŸ“Š";
                    case REALLOCATION_SUGGESTION -> "ðŸ”„";
                };

                // Convert message to more concise format
                String message = insight.getMessage()
                    .replaceAll("detected in", "in")
                    .replaceAll("Consider ", "")
                    .replaceAll(" recommended", "");

                points.add(new Span(emoji + " " + message));
            });

        // Anomalies summary
        if (!anomalies.isEmpty()) {
            // Group anomalies by type
            long amountAnomalies = anomalies.stream()
                .filter(a -> a.type() == AdvancedMLService.AnomalyType.AMOUNT)
                .count();
            long freqAnomalies = anomalies.stream()
                .filter(a -> a.type() == AdvancedMLService.AnomalyType.FREQUENCY)
                .count();

            if (amountAnomalies > 0) {
                points.add(new Span(String.format("âš ï¸ Found %d unusual transaction amount%s", 
                    amountAnomalies, amountAnomalies > 1 ? "s" : "")));
            }
            if (freqAnomalies > 0) {
                points.add(new Span(String.format("ðŸ“Š Found %d unusual spending pattern%s", 
                    freqAnomalies, freqAnomalies > 1 ? "s" : "")));
            }
        }

        // Add top merchants if available
        if (analysis != null && !analysis.getMerchantMetrics().isEmpty()) {
            String topMerchant = analysis.getMerchantMetrics().entrySet().stream()
                .max(Map.Entry.comparingByValue(Comparator.comparingDouble(
                    AdvancedMLService.MerchantMetrics::totalSpent)))
                .map(Map.Entry::getKey)
                .orElse(null);

            if (topMerchant != null) {
                points.add(new Span(String.format("ðŸª Highest spending at %s", topMerchant)));
            }
        }

        // Add recommendations count
        long recommendationCount = insights.stream()
            .filter(i -> i.getType() == SpendingInsightType.BUDGET_SUGGESTION ||
                        i.getType() == SpendingInsightType.REALLOCATION_SUGGESTION)
            .count();
        if (recommendationCount > 0) {
            points.add(new Span(String.format("ðŸ’¡ %d budget optimization suggestion%s", 
                recommendationCount, recommendationCount > 1 ? "s" : "")));
        }

        summaryCard.add(points);
        return summaryCard;
    }
    private void configureTransactionGrid() {
        transactionGrid.addColumn(tx -> 
            tx.getDate().format(DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm")))
            .setHeader("Date")
            .setSortable(true)
            .setAutoWidth(true);
            
        transactionGrid.addColumn(Transaction::getDescription)
            .setHeader("Description")
            .setAutoWidth(true);
            
        transactionGrid.addColumn(tx -> String.format("$%.2f", tx.getAmount()))
            .setHeader("Amount")
            .setAutoWidth(true);
            
        transactionGrid.addColumn(tx -> tx.getType().toString())
            .setHeader("Type")
            .setAutoWidth(true);
            
        transactionGrid.addColumn(tx -> tx.getEnvelope().getName())
            .setHeader("Envelope")
            .setAutoWidth(true);

        transactionGrid.addItemDoubleClickListener(event -> {
            transactionDialogs.showEditTransactionDialog(event.getItem(), this::refreshData);
        });

        transactionGrid.setClassNameGenerator(tx -> {
            return tx.getType() == TransactionType.INCOME ? "income-row" : "expense-row";
        });
    }


    private Icon getInsightIcon(SpendingInsightType type) {
        return switch (type) {
            case RECURRING_PAYMENT -> VaadinIcon.REFRESH.create();
            case UNUSUAL_SPENDING -> VaadinIcon.EXCLAMATION_CIRCLE.create();
            case PREDICTED_EXPENSE -> VaadinIcon.TRENDING_UP.create();
            case BUDGET_SUGGESTION -> VaadinIcon.PIGGY_BANK.create();
            case SEASONAL_PATTERN -> VaadinIcon.CALENDAR.create();
            case REALLOCATION_SUGGESTION -> VaadinIcon.EXCHANGE.create();
        };
    }

    private String getInsightColor(SpendingInsightType type) {
        return switch (type) {
            case UNUSUAL_SPENDING -> "var(--lumo-error-color)";
            case BUDGET_SUGGESTION -> "var(--lumo-success-color)";
            case PREDICTED_EXPENSE -> "var(--lumo-primary-color)";
            default -> "var(--lumo-contrast)";
        };
    }

    private Div createMetricCard(String title, String value, String color) {
        Div card = new Div();
        card.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("padding", "var(--lumo-space-m)")
            .set("flex", "1")
            .set("text-align", "center")
            .set("box-shadow", "var(--lumo-box-shadow-xs)");

        H3 titleElem = new H3(title);
        titleElem.getStyle()
            .set("margin", "0")
            .set("color", "var(--lumo-secondary-text-color)")
            .set("font-size", "var(--lumo-font-size-s)");

        Span valueElem = new Span(value);
        valueElem.getStyle()
            .set("font-size", "var(--lumo-font-size-xxl)")
            .set("font-weight", "bold")
            .set("color", color);

        card.add(titleElem, valueElem);
        return card;
    }

    private String calculateMonthlySpending() {
        BigDecimal total = currentAccount.getTransactions().stream()
            .filter(tx -> tx.getType() == TransactionType.EXPENSE)
            .filter(tx -> tx.getDate().getMonth() == LocalDateTime.now().getMonth())
            .map(Transaction::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        return String.format("$%.2f", total);
    }

    private String calculateMonthlyIncome() {
        BigDecimal total = currentAccount.getTransactions().stream()
            .filter(tx -> tx.getType() == TransactionType.INCOME)
            .filter(tx -> tx.getDate().getMonth() == LocalDateTime.now().getMonth())
            .map(Transaction::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        return String.format("$%.2f", total);
    }

    private void updateTransactionList(TransactionType type, String searchPattern) {
        List<Transaction> transactions = currentAccount.getTransactions();
        
        // Filter by type if specified
        if (type != null) {
            transactions = transactions.stream()
                .filter(tx -> tx.getType() == type)
                .collect(Collectors.toList());
        }

        // Apply search pattern if provided
        if (searchPattern != null && !searchPattern.isEmpty()) {
            try {
                // Try as regex pattern first
                Pattern pattern = Pattern.compile(searchPattern, Pattern.CASE_INSENSITIVE);
                transactions = transactions.stream()
                    .filter(tx -> 
                        pattern.matcher(tx.getDescription()).find() ||
                        pattern.matcher(tx.getEnvelope().getName()).find() ||
                        pattern.matcher(tx.getAmount().toString()).find() ||
                        pattern.matcher(tx.getType().toString()).find()
                    )
                    .collect(Collectors.toList());
            } catch (PatternSyntaxException e) {
                // If regex fails, fall back to simple contains search
                String search = searchPattern.toLowerCase();
                transactions = transactions.stream()
                    .filter(tx ->
                        tx.getDescription().toLowerCase().contains(search) ||
                        tx.getEnvelope().getName().toLowerCase().contains(search) ||
                        tx.getAmount().toString().contains(search) ||
                        tx.getType().toString().toLowerCase().contains(search)
                    )
                    .collect(Collectors.toList());
            }
        }

        transactionGrid.setItems(transactions);
    }

    private void refreshData() {
        currentAccount = accountService.getAccount(currentAccount.getId());
        balanceChart.refreshData();
        updateTransactionList(null,"");
    }
}===== ./src/main/java/org/emblow/envelopify/ui/views/LoginView.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

import com.vaadin.flow.component.UI;
import com.vaadin.flow.component.login.LoginForm;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.router.BeforeEnterEvent;
import com.vaadin.flow.router.BeforeEnterObserver;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.html.Hr;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;

/**
 * LoginView is the entry point for unauthenticated users.
 * It displays a Vaadin LoginForm for user authentication and provides a registration link.
 *
 * <p>This view is accessible to anonymous users, and its form posts to the /login URL (handled by Spring Security).</p>
 *
 * @author Nicholas J Emblow
 * @version 1.0
 * @since 2025
 */
@Route("login") 
@PageTitle("Login | Envelofy")
@AnonymousAllowed
public class LoginView extends VerticalLayout implements BeforeEnterObserver {
    private final LoginForm login;

    public LoginView() {
        addClassName("login-view");
        setSizeFull();
        setAlignItems(Alignment.CENTER);
        setJustifyContentMode(JustifyContentMode.CENTER);
        getStyle().set("padding", "var(--lumo-space-l)");

        // Create a card-like container for the login form
        Div loginContainer = new Div();
        loginContainer.addClassName("login-container");
        loginContainer.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("box-shadow", "var(--lumo-box-shadow-m)")
            .set("padding", "var(--lumo-space-l)")
            .set("max-width", "400px")
            .set("width", "100%");

        // Initialize the login form
        login = new LoginForm();
        login.setAction("login");  // This matches the loginProcessingUrl in SecurityConfig
        login.setForgotPasswordButtonVisible(false);

        // Create header
        H2 header = new H2("Welcome to Envelofy");
        header.getStyle()
            .set("margin", "0")
            .set("text-align", "center")
            .set("color", "var(--lumo-primary-text-color)");

        // Add register button
        Button registerButton = new Button("Don't have an account? Register");
        registerButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY);
        registerButton.getStyle().set("margin-top", "var(--lumo-space-m)");
        registerButton.addClickListener(e -> getUI().ifPresent(ui -> 
            ui.navigate("register")));

        // Add components to the container
        loginContainer.add(
            header,
            new Hr(),  // Add a divider
            login,
            registerButton
        );

        add(loginContainer);
    }

    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        // Add error parameter handling
        if (event.getLocation()
                .getQueryParameters()
                .getParameters()
                .containsKey("error")) {
            login.setError(true);
        }
    }
}===== ./src/main/java/org/emblow/envelopify/ui/views/RegistrationView.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.html.Paragraph;
import com.vaadin.flow.component.textfield.EmailField;
import com.vaadin.flow.component.textfield.PasswordField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.service.UserService;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.ClickEvent;
import com.vaadin.flow.component.ComponentEventListener;
import com.vaadin.flow.router.BeforeEnterEvent;
import com.vaadin.flow.router.BeforeEnterObserver;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;

/**
 * RegistrationView is responsible for allowing new users to register an account.
 * 
 * <p>This view collects the username, email, password, and confirmation of password.
 * On successful registration (handled via UserService), it redirects the user to the login page.</p>
 *
 * @author Nicholas J Emblow
 * @version 1.0
 * @since 2025
 */
@Route("register")
@PageTitle("Register | Envelofy")
@AnonymousAllowed
public class RegistrationView extends VerticalLayout implements BeforeEnterObserver {

    private final UserService userService;

    /**
     * Constructs a new RegistrationView.
     *
     * @param userService The service used to create a new user.
     */
    public RegistrationView(UserService userService) {
        this.userService = userService;
        configureLayout();
    }

    /**
     * Configures the layout and adds all UI components required for registration.
     */
    private void configureLayout() {
        // Set full size and center components
        setSizeFull();
        setAlignItems(Alignment.CENTER);
        setJustifyContentMode(JustifyContentMode.CENTER);
        addClassName("register-view");

        // Header for the registration page
        H2 header = new H2("Create Account");

        // Username field: required and full width.
        TextField usernameField = new TextField("Username");
        usernameField.setRequired(true);
        usernameField.setWidthFull();

        // Email field: required and validated.
        EmailField emailField = new EmailField("Email");
        emailField.setRequired(true);
        emailField.setWidthFull();

        // Password field: required.
        PasswordField passwordField = new PasswordField("Password");
        passwordField.setRequired(true);
        passwordField.setWidthFull();

        // Confirm password field: required.
        PasswordField confirmPasswordField = new PasswordField("Confirm Password");
        confirmPasswordField.setRequired(true);
        confirmPasswordField.setWidthFull();

        // Registration button with click listener.
        Button registerButton = new Button("Register", (ComponentEventListener<ClickEvent<Button>>) event -> {
            handleRegistration(usernameField.getValue(), emailField.getValue(), 
                               passwordField.getValue(), confirmPasswordField.getValue());
        });
        registerButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        // Button that navigates to the login view if the user already has an account.
        Button loginButton = new Button("Already have an account? Login", 
                e -> getUI().ifPresent(ui -> ui.navigate("login")));
        loginButton.addThemeVariants(ButtonVariant.LUMO_TERTIARY);

        // Add all components to the layout.
        add(header, usernameField, emailField, passwordField, confirmPasswordField, registerButton, loginButton);
    }

    /**
     * Handles the registration logic. Validates that the passwords match and calls UserService.
     * On success, navigates to the login page; on failure, shows an error notification.
     *
     * @param username         The username entered by the user.
     * @param email            The email address entered by the user.
     * @param password         The password entered by the user.
     * @param confirmPassword  The confirmation password entered by the user.
     */
    private void handleRegistration(String username, String email, String password, String confirmPassword) {
        try {
            if (!password.equals(confirmPassword)) {
                throw new IllegalArgumentException("Passwords do not match");
            }
            // Create the user using the UserService.
            userService.createUser(username, password, email);
            // On successful registration, navigate to the login view.
            getUI().ifPresent(ui -> ui.navigate("login"));
            Notification.show("Registration successful! Please login.");
        } catch (IllegalArgumentException e) {
            Notification.show("Registration failed: " + e.getMessage(), 3000, Notification.Position.MIDDLE)
                        .addThemeVariants(NotificationVariant.LUMO_ERROR);
        }
    }

    /**
     * Implements BeforeEnterObserver to perform actions before the view is entered.
     * This method can be used to reset fields or perform cleanup if needed.
     *
     * @param event The before-enter event.
     */
    @Override
    public void beforeEnter(BeforeEnterEvent event) {
        // Optionally, perform any cleanup or reset operations here.
    }
}

===== ./src/main/java/org/emblow/envelopify/service/BillReminderService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.scheduling.annotation.Scheduled;
import org.emblow.envelopify.domain.BillReminder;
import org.emblow.envelopify.repository.BillReminderRepository;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.User;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class BillReminderService {
    private static final Logger log = LoggerFactory.getLogger(BillReminderService.class);
    
    private final BillReminderRepository repository;
    private final SecurityService securityService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;

    public BillReminderService(
        BillReminderRepository repository,
        SecurityService securityService,
        EnvelopeService envelopeService,
        AccountService accountService
    ) {
        this.repository = repository;
        this.securityService = securityService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;
    }

    @Transactional
    public BillReminder create(BillReminder reminder) {
        try {
            // Validate envelope and account ownership
            Envelope envelope = envelopeService.getEnvelope(reminder.getEnvelope().getId());
            Account account = accountService.getAccount(reminder.getAccount().getId());
            
            reminder.setEnvelope(envelope);
            reminder.setAccount(account);
            return repository.save(reminder);
            
        } catch (Exception e) {
            log.error("Error creating bill reminder", e);
            throw new RuntimeException("Could not create bill reminder: " + e.getMessage());
        }
    }

    @Transactional
    public void update(Long id, BillReminder updated) {
        try {
            BillReminder existing = repository.findById(id)
                .orElseThrow(() -> new RuntimeException("Bill reminder not found"));
                
            // Validate envelope and account ownership
            Envelope envelope = envelopeService.getEnvelope(updated.getEnvelope().getId());
            Account account = accountService.getAccount(updated.getAccount().getId());
            
            // Update fields
            existing.setDescription(updated.getDescription());
            existing.setAmount(updated.getAmount());
            existing.setDueDate(updated.getDueDate());
            existing.setReminderDays(updated.getReminderDays());
            existing.setPaid(updated.isPaid());
            existing.setEnvelope(envelope);
            existing.setAccount(account);
            
            repository.save(existing);
            
        } catch (Exception e) {
            log.error("Error updating bill reminder", e);
            throw new RuntimeException("Could not update bill reminder: " + e.getMessage());
        }
    }

    @Transactional
    public void delete(Long id) {
        try {
            BillReminder reminder = repository.findById(id)
                .orElseThrow(() -> new RuntimeException("Bill reminder not found"));
                
            // Validate ownership through envelope
            envelopeService.getEnvelope(reminder.getEnvelope().getId());
            repository.deleteById(id);
            
        } catch (Exception e) {
            log.error("Error deleting bill reminder", e);
            throw new RuntimeException("Could not delete bill reminder: " + e.getMessage());
        }
    }

    @Transactional
    public void markAsPaid(Long id) {
        try {
            BillReminder reminder = repository.findById(id)
                .orElseThrow(() -> new RuntimeException("Bill reminder not found"));
                
            // Validate ownership through envelope
            envelopeService.getEnvelope(reminder.getEnvelope().getId());
            reminder.setPaid(true);
            repository.save(reminder);
            
        } catch (Exception e) {
            log.error("Error marking bill reminder as paid", e);
            throw new RuntimeException("Could not mark bill reminder as paid: " + e.getMessage());
        }
    }

    public List<BillReminder> getUpcoming() {
        try {
            User currentUser = securityService.getCurrentUser();
            return repository.findByPaidFalseOrderByDueDateAsc().stream()
                .filter(reminder -> reminder.getEnvelope().getOwner().getId().equals(currentUser.getId()))
                .collect(Collectors.toList());
                
        } catch (Exception e) {
            log.error("Error retrieving upcoming bill reminders", e);
            throw new RuntimeException("Could not retrieve upcoming bill reminders: " + e.getMessage());
        }
    }

    public List<BillReminder> getOverdue() {
        try {
            User currentUser = securityService.getCurrentUser();
            return repository.findByPaidFalseAndDueDateBefore(LocalDate.now()).stream()
                .filter(reminder -> reminder.getEnvelope().getOwner().getId().equals(currentUser.getId()))
                .collect(Collectors.toList());
                
        } catch (Exception e) {
            log.error("Error retrieving overdue bill reminders", e);
            throw new RuntimeException("Could not retrieve overdue bill reminders: " + e.getMessage());
        }
    }

    public List<BillReminder> getAllForEnvelope(Long envelopeId) {
        try {
            // This validates ownership
            envelopeService.getEnvelope(envelopeId);
            return repository.findByEnvelopeId(envelopeId);
            
        } catch (Exception e) {
            log.error("Error retrieving bill reminders for envelope", e);
            throw new RuntimeException("Could not retrieve bill reminders: " + e.getMessage());
        }
    }

    @Scheduled(cron = "0 0 9 * * *") // Run daily at 9 AM
    public void checkReminders() {
        try {
            User currentUser = securityService.getCurrentUser();
            List<BillReminder> reminders = repository.findByPaidFalseOrderByDueDateAsc();
            
            for (BillReminder reminder : reminders) {
                // Only process reminders for the current user's envelopes
                if (reminder.getEnvelope().getOwner().getId().equals(currentUser.getId()) 
                    && reminder.needsReminder()) {
                    
                    // TODO: Implement notification system
                    log.info("Reminder needed for: {} (Due: {})", 
                        reminder.getDescription(), 
                        reminder.getDueDate());
                }
            }
        } catch (Exception e) {
            log.error("Error checking bill reminders", e);
        }
    }
}
===== ./src/main/java/org/emblow/envelopify/service/TransactionService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.InsufficientFundsException;
import org.emblow.envelopify.repository.TransactionRepository;
import org.emblow.envelopify.repository.EnvelopeRepository;
import org.emblow.envelopify.repository.AccountRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.emblow.envelopify.domain.User;
import org.emblow.envelopify.exception.BusinessException;
import org.emblow.envelopify.exception.ValidationException;

// Update TransactionService.java
@Service
public class TransactionService {
    private final TransactionRepository transactionRepository;
    private final EnvelopeRepository envelopeRepository;
    private final AccountRepository accountRepository;
    private final SecurityService securityService;
    private final PatternService patternService;

    public TransactionService(
        TransactionRepository transactionRepository,
        EnvelopeRepository envelopeRepository,
        AccountRepository accountRepository,
        SecurityService securityService,
        PatternService patternService
    ) {
        this.transactionRepository = transactionRepository;
        this.envelopeRepository = envelopeRepository;
        this.accountRepository = accountRepository;
        this.securityService = securityService;
        this.patternService = patternService;
    }

    public List<Transaction> getRecentTransactions(LocalDateTime start, LocalDateTime end) {
        User currentUser = securityService.getCurrentUser();
        return transactionRepository.findByDateBetweenAndEnvelope_OwnerOrderByDateDesc(
            start, end, currentUser
        );
    }
    private void validateTransaction(
        LocalDateTime date,
        String description,
        BigDecimal amount,
        Long envelopeId,
        Long accountId
    ) {
        Map<String, String> violations = new HashMap<>();

        if (date == null) {
            violations.put("date", "Date is required");
        } else if (date.isAfter(LocalDateTime.now())) {
            violations.put("date", "Date cannot be in the future");
        }

        if (description == null || description.trim().isEmpty()) {
            violations.put("description", "Description is required");
        }

        if (amount == null) {
            violations.put("amount", "Amount is required");
        } else if (amount.compareTo(BigDecimal.ZERO) <= 0) {
            violations.put("amount", "Amount must be positive");
        }

        if (envelopeId == null) {
            violations.put("envelopeId", "Envelope ID is required");
        }

        if (accountId == null) {
            violations.put("accountId", "Account ID is required");
        }

        if (!violations.isEmpty()) {
            throw new ValidationException(violations);
        }
    }
    @Transactional
    public Transaction recordTransaction(
        Long envelopeId,
        Long accountId,
        LocalDateTime date,
        String description,
        BigDecimal amount,
        TransactionType type
    ) {

        validateTransaction(date, description, amount, envelopeId, accountId);
        
    User currentUser = securityService.getCurrentUser();

    Envelope envelope = envelopeRepository.findByIdAndOwner(envelopeId, currentUser)
        .orElseThrow(() -> new BusinessException("ENVELOPE_NOT_FOUND", "Envelope not found"));
        
    Account account = accountRepository.findByIdAndOwner(accountId, currentUser)
        .orElseThrow(() -> new BusinessException("ACCOUNT_NOT_FOUND", "Account not found"));


        Transaction transaction = new Transaction(date, description, amount, envelope, account, type);

        if (null == type) {
            throw new IllegalArgumentException("Unsupported transaction type");
        } else switch (type) {
            case EXPENSE -> {
                BigDecimal accountAmount = account.getType() == Account.AccountType.CREDIT_CARD ?
                        amount : amount.negate();
                if (account.getType() != Account.AccountType.CREDIT_CARD &&
                        account.getBalance().subtract(amount).compareTo(BigDecimal.ZERO) < 0) {
                    throw new InsufficientFundsException(account.getName(), amount);
                }   envelope.spend(amount);
                account.debit(accountAmount);
            }
            case INCOME -> {
                envelope.allocate(amount);
                account.credit(amount);
            }
            default -> throw new IllegalArgumentException("Unsupported transaction type");
        }

        envelopeRepository.save(envelope);
        accountRepository.save(account);
        Transaction saved = transactionRepository.save(transaction);

        updatePatternLearning(saved);

        return saved;
    }

    @Transactional
    public Transaction updateTransaction(
        Long id,
        Long envelopeId,
        Long accountId,
        LocalDateTime date,
        String description,
        BigDecimal amount,
        TransactionType newType
    ) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }

        User currentUser = securityService.getCurrentUser();

        Transaction transaction = transactionRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Transaction not found"));
            
        // Verify ownership
        securityService.validateOwnership(transaction.getEnvelope().getOwner());

        Envelope oldEnvelope = transaction.getEnvelope();
        Account oldAccount = transaction.getAccount();
        BigDecimal oldAmount = transaction.getAmount();
        TransactionType oldType = transaction.getType();

        Envelope newEnvelope = envelopeRepository.findByIdAndOwner(envelopeId, currentUser)
            .orElseThrow(() -> new RuntimeException("Envelope not found"));
            
        Account newAccount = accountRepository.findByIdAndOwner(accountId, currentUser)
            .orElseThrow(() -> new RuntimeException("Account not found"));

        // Reverse old transaction effects
        if (oldType == TransactionType.EXPENSE) {
            oldEnvelope.unspend(oldAmount);
            BigDecimal oldAccountAmount = oldAccount.getType() == Account.AccountType.CREDIT_CARD ?
                oldAmount : oldAmount.negate();
            oldAccount.credit(oldAccountAmount);
        } else if (oldType == TransactionType.INCOME) {
            oldEnvelope.unallocate(oldAmount);
            oldAccount.debit(oldAmount);
        }

        if (null == newType) {
            throw new IllegalArgumentException("Unsupported transaction type");
        } else // Apply new transaction effects
        switch (newType) {
            case EXPENSE -> {
                newEnvelope.spend(amount);
                BigDecimal newAccountAmount = newAccount.getType() == Account.AccountType.CREDIT_CARD ?
                        amount : amount.negate();
                if (newAccount.getType() != Account.AccountType.CREDIT_CARD &&
                        newAccount.getBalance().subtract(amount).compareTo(BigDecimal.ZERO) < 0) {
                    throw new InsufficientFundsException(newAccount.getName(), amount);
                }   newAccount.debit(newAccountAmount);
            }
            case INCOME -> {
                newEnvelope.allocate(amount);
                newAccount.credit(amount);
            }
            default -> throw new IllegalArgumentException("Unsupported transaction type");
        }

        transaction.setDate(date);
        transaction.setDescription(description);
        transaction.setAmount(amount);
        transaction.setEnvelope(newEnvelope);
        transaction.setAccount(newAccount);
        transaction.setType(newType);

        envelopeRepository.save(oldEnvelope);
        if (!oldEnvelope.getId().equals(newEnvelope.getId())) {
            envelopeRepository.save(newEnvelope);
        }
        
        accountRepository.save(oldAccount);
        if (!oldAccount.getId().equals(newAccount.getId())) {
            accountRepository.save(newAccount);
        }

        Transaction updated = transactionRepository.save(transaction);

        if (!oldEnvelope.getId().equals(newEnvelope.getId())) {
            updatePatternLearning(updated);
        }

        return updated;
    }

    @Transactional
    public void deleteTransaction(Long id) {
        Transaction transaction = transactionRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Transaction not found"));
            
        // Verify ownership
        securityService.validateOwnership(transaction.getEnvelope().getOwner());

        Envelope envelope = transaction.getEnvelope();
        Account account = transaction.getAccount();
        BigDecimal amount = transaction.getAmount();
        TransactionType type = transaction.getType();

        if (type == TransactionType.EXPENSE) {
            envelope.unspend(amount);
            BigDecimal accountAmount = account.getType() == Account.AccountType.CREDIT_CARD ?
                amount : amount.negate();
            account.credit(accountAmount);
        } else if (type == TransactionType.INCOME) {
            envelope.unallocate(amount);
            account.debit(amount);
        }

        envelopeRepository.save(envelope);
        accountRepository.save(account);
        transactionRepository.delete(transaction);
    }

    private void updatePatternLearning(Transaction transaction) {
        try {
            patternService.suggestEnvelopes(transaction);
        } catch (Exception e) {
            System.err.println("Error updating pattern learning: " + e.getMessage());
        }
    }
}===== ./src/main/java/org/emblow/envelopify/service/UserService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.User;
import org.emblow.envelopify.repository.UserRepository;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Transactional
    public User createUser(String username, String password, String email) {
        // Validate unique constraints
        if (userRepository.existsByUsername(username)) {
            throw new IllegalArgumentException("Username already taken");
        }
        if (userRepository.existsByEmail(email)) {
            throw new IllegalArgumentException("Email already registered");
        }

        // Create and save user
        User user = new User(
            username,
            passwordEncoder.encode(password),
            email
        );
        return userRepository.save(user);
    }

    @Transactional(readOnly = true)
    public User getUserById(Long id) {
        return userRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("User not found"));
    }

    @Transactional(readOnly = true)
    public User getUserByUsername(String username) {
        return userRepository.findByUsername(username)
            .orElseThrow(() -> new RuntimeException("User not found"));
    }

    @Transactional
    public User updateUser(Long id, String email, String fullName, String timezone, String currencyCode) {
        User user = getUserById(id);
        
        // Only update email if it changed and isn't taken
        if (email != null && !email.equals(user.getEmail())) {
            if (userRepository.existsByEmail(email)) {
                throw new IllegalArgumentException("Email already registered");
            }
            user.setEmail(email);
        }

        if (fullName != null) user.setFullName(fullName);
        if (timezone != null) user.setTimezone(timezone);
        if (currencyCode != null) user.setCurrencyCode(currencyCode);

        return userRepository.save(user);
    }

    @Transactional
    public void updatePassword(Long id, String currentPassword, String newPassword) {
        User user = getUserById(id);
        
        // Verify current password
        if (!passwordEncoder.matches(currentPassword, user.getPasswordHash())) {
            throw new IllegalArgumentException("Current password is incorrect");
        }

        // Update password
        user.setPasswordHash(passwordEncoder.encode(newPassword));
        userRepository.save(user);
    }

    @Transactional
    public void deleteUser(Long id) {
        if (!userRepository.existsById(id)) {
            throw new RuntimeException("User not found");
        }
        userRepository.deleteById(id);
    }
}
===== ./src/main/java/org/emblow/envelopify/service/ChatHistoryService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.emblow.envelopify.domain.ChatSession;
import org.emblow.envelopify.domain.ChatMessage;
import org.emblow.envelopify.domain.User;
import org.emblow.envelopify.repository.ChatSessionRepository;
import org.emblow.envelopify.repository.ChatMessageRepository;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.List;
import java.util.Optional;
import org.emblow.envelopify.domain.ChartArtifact;
import org.emblow.envelopify.repository.ChartArtifactRepository;

@Service
public class ChatHistoryService {
    private static final int MAX_TOKENS = 4000; // Adjust based on LLM limits

    @Autowired
    private SecurityService securityService;

    @Autowired
    private ChatSessionRepository chatSessionRepository;

    @Autowired
    private ChatMessageRepository chatMessageRepository;
    
    private final ChartArtifactRepository chartArtifactRepository;

    @Autowired
    public ChatHistoryService(SecurityService securityService,
                            ChatSessionRepository chatSessionRepository,
                            ChatMessageRepository chatMessageRepository,
                            ChartArtifactRepository chartArtifactRepository) {
        this.securityService = securityService;
        this.chatSessionRepository = chatSessionRepository;
        this.chatMessageRepository = chatMessageRepository;
        this.chartArtifactRepository = chartArtifactRepository;
    }

    @Transactional
    public ChatSession createNewSession(String title) {
        User currentUser = securityService.getCurrentUser();
        ChatSession session = new ChatSession(title, currentUser);
        return chatSessionRepository.save(session);
    }

    @Transactional(readOnly = true)
    public List<ChartArtifact> getChartsForSession(ChatSession session) {
        // Verify the user owns this session
        if (!securityService.isOwner(session.getOwner())) {
            throw new RuntimeException("Access denied");
        }
        return chartArtifactRepository.findBySession(session);
    }

    @Transactional(readOnly = true)
    public List<ChatSession> getUserSessions() {
        User currentUser = securityService.getCurrentUser();
        return chatSessionRepository.findByOwnerOrderByCreatedAtDesc(currentUser);
    }

    @Transactional(readOnly = true)
    public Optional<ChatSession> getSession(Long sessionId) {
        ChatSession session = chatSessionRepository.findById(sessionId)
            .orElse(null);
        if (session != null && !securityService.isOwner(session.getOwner())) {
            return Optional.empty();
        }
        return Optional.ofNullable(session);
    }

    @Transactional
    public void addMessage(Long sessionId, String role, String content) {
        ChatSession session = getSession(sessionId)
            .orElseThrow(() -> new RuntimeException("Chat session not found or access denied"));
        
        ChatMessage message = new ChatMessage(role, content);
        session.addMessage(message);
        trimHistory(session);
        chatSessionRepository.save(session);
    }

    @Transactional
    public void addMessageWithCharts(Long sessionId, String role, String content, List<String> chartDataList) {
        ChatSession session = getSession(sessionId)
            .orElseThrow(() -> new RuntimeException("Chat session not found or access denied"));

        ChatMessage message = new ChatMessage(role, content);
        session.addMessage(message);

        // Save charts if present
        if (chartDataList != null && !chartDataList.isEmpty()) {
            for (String chartData : chartDataList) {
                ChartArtifact chart = new ChartArtifact(chartData, session);
                chartArtifactRepository.save(chart);
            }
        }

        trimHistory(session);
        chatSessionRepository.save(session);
    }

    @Transactional(readOnly = true)
    public List<ChatMessage> getSessionMessages(Long sessionId) {
        ChatSession session = getSession(sessionId)
            .orElseThrow(() -> new RuntimeException("Chat session not found or access denied"));
        return chatMessageRepository.findBySessionOrderByTimestampAsc(session);
    }

    private void trimHistory(ChatSession session) {
        List<ChatMessage> messages = session.getMessages();
        int totalTokens = messages.stream().mapToInt(ChatMessage::estimateTokens).sum();
        
        while (totalTokens > MAX_TOKENS && !messages.isEmpty()) {
            ChatMessage oldest = messages.remove(0);
            chatMessageRepository.delete(oldest);
            totalTokens -= oldest.estimateTokens();
        }
    }

    @Transactional
    public void deleteSession(Long sessionId) {
        ChatSession session = getSession(sessionId)
            .orElseThrow(() -> new RuntimeException("Chat session not found or access denied"));
        chatSessionRepository.delete(session);
    }
}===== ./src/main/java/org/emblow/envelopify/service/SecurityService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.User;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

@Service
public class SecurityService {
    private final UserService userService;

    public SecurityService(UserService userService) {
        this.userService = userService;
    }

    public User getCurrentUser() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || !auth.isAuthenticated()) {
            throw new RuntimeException("No authenticated user found");
        }
        return userService.getUserByUsername(auth.getName());
    }

    public boolean isOwner(User resourceOwner) {
        return getCurrentUser().getId().equals(resourceOwner.getId());
    }

    public void validateOwnership(User resourceOwner) {
        if (!isOwner(resourceOwner)) {
            throw new RuntimeException("Access denied: You don't own this resource");
        }
    }
}===== ./src/main/java/org/emblow/envelopify/service/InitializationService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.stereotype.Service;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.emblow.envelopify.repository.AccountRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class InitializationService {
    private static final Logger log = LoggerFactory.getLogger(InitializationService.class);
    
    private final AccountRepository accountRepository;
    private final TestDataService testDataService;
    
    public InitializationService(
        AccountRepository accountRepository,
        TestDataService testDataService
    ) {
        this.accountRepository = accountRepository;
        this.testDataService = testDataService;
    }
    /* dont init yet!
    @EventListener(ApplicationReadyEvent.class)
    public void onApplicationReady() {
        initializeTestData();
    }
    */
    public void initializeTestData() {
        // Only initialize if no accounts exist
        if (accountRepository.count() == 0) {
            log.info("No existing data found. Initializing test data...");
            try {
                testDataService.createTestData();
                log.info("Test data initialization complete.");
            } catch (Exception e) {
                log.error("Error initializing test data", e);
            }
        } else {
            log.info("Existing data found. Skipping test data initialization.");
        }
    }
}
===== ./src/main/java/org/emblow/envelopify/service/IntentDetectionService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.service.ml.TransactionNaiveBayes;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Service
public class IntentDetectionService {
    private final TransactionNaiveBayes classifier;

    public IntentDetectionService() {
        this.classifier = new TransactionNaiveBayes();
        trainClassifier();
    }

    private void trainClassifier() {
        List<TransactionNaiveBayes.TransactionFeatures> trainingData = new ArrayList<>();

        // Budget-related queries (50 samples)
        trainingData.add(createFeatures("How much is my budget?", "budget"));
        trainingData.add(createFeatures("What's my remaining budget this month?", "budget"));
        trainingData.add(createFeatures("Can I increase my groceries budget?", "budget"));
        trainingData.add(createFeatures("Is my budget sufficient for this month?", "budget"));
        trainingData.add(createFeatures("Do I have enough budget left for dining out?", "budget"));
        trainingData.add(createFeatures("What's my monthly budget cap?", "budget"));
        trainingData.add(createFeatures("Can you tell me my current budget?", "budget"));
        trainingData.add(createFeatures("How much budget have I allocated for rent?", "budget"));
        trainingData.add(createFeatures("Budget status update", "budget"));
        trainingData.add(createFeatures("What is my budget limit?", "budget"));
        trainingData.add(createFeatures("Show my budget allocation", "budget"));
        trainingData.add(createFeatures("Budget details for this month", "budget"));
        trainingData.add(createFeatures("Tell me my budget overview", "budget"));
        trainingData.add(createFeatures("What is my total budget?", "budget"));
        trainingData.add(createFeatures("Give me a budget summary", "budget"));
        trainingData.add(createFeatures("How much money is allocated in my budget?", "budget"));
        trainingData.add(createFeatures("Check my budget balance", "budget"));
        trainingData.add(createFeatures("What's left in my budget?", "budget"));
        trainingData.add(createFeatures("Budget insights", "budget"));
        trainingData.add(createFeatures("Am I exceeding my budget?", "budget"));
        trainingData.add(createFeatures("Update on my budget", "budget"));
        trainingData.add(createFeatures("Remaining funds in my budget", "budget"));
        trainingData.add(createFeatures("Monthly budget report", "budget"));
        trainingData.add(createFeatures("Budget utilization status", "budget"));
        trainingData.add(createFeatures("How do I compare to my budget?", "budget"));
        trainingData.add(createFeatures("Is my budget balanced?", "budget"));
        trainingData.add(createFeatures("Budget check", "budget"));
        trainingData.add(createFeatures("Detail my budget", "budget"));
        trainingData.add(createFeatures("Budget performance", "budget"));
        trainingData.add(createFeatures("Track my budget usage", "budget"));
        trainingData.add(createFeatures("What's my entertainment budget?", "budget"));
        trainingData.add(createFeatures("Show budget categories", "budget"));
        trainingData.add(createFeatures("Budget breakdown by category", "budget"));
        trainingData.add(createFeatures("How much can I spend on utilities?", "budget"));
        trainingData.add(createFeatures("What's my discretionary budget?", "budget"));
        trainingData.add(createFeatures("Budget limits for each category", "budget"));
        trainingData.add(createFeatures("Am I within budget this quarter?", "budget"));
        trainingData.add(createFeatures("Show me my savings budget", "budget"));
        trainingData.add(createFeatures("What's my holiday spending budget?", "budget"));
        trainingData.add(createFeatures("Emergency fund budget status", "budget"));
        trainingData.add(createFeatures("Budget allocation by percentage", "budget"));
        trainingData.add(createFeatures("How much is budgeted for car expenses?", "budget"));
        trainingData.add(createFeatures("What's my annual budget plan?", "budget"));
        trainingData.add(createFeatures("Show me my flexible spending budget", "budget"));
        trainingData.add(createFeatures("Budget variance analysis", "budget"));
        trainingData.add(createFeatures("What's my travel budget?", "budget"));
        trainingData.add(createFeatures("Healthcare budget status", "budget"));
        trainingData.add(createFeatures("Education budget overview", "budget"));
        trainingData.add(createFeatures("Budget vs actual spending", "budget"));
        trainingData.add(createFeatures("Show my clothing budget", "budget"));

        // Spending-related queries (50 samples)
        trainingData.add(createFeatures("How much did I spend this month?", "spending"));
        trainingData.add(createFeatures("What did I spend on entertainment?", "spending"));
        trainingData.add(createFeatures("Show me my recent spending", "spending"));
        trainingData.add(createFeatures("What are my expenses this month?", "spending"));
        trainingData.add(createFeatures("List my spending for the last week", "spending"));
        trainingData.add(createFeatures("Track my spending habits", "spending"));
        trainingData.add(createFeatures("How much did I spend on groceries?", "spending"));
        trainingData.add(createFeatures("Spending details for this month", "spending"));
        trainingData.add(createFeatures("What did I spend on dining out?", "spending"));
        trainingData.add(createFeatures("Can you show my spending history?", "spending"));
        trainingData.add(createFeatures("Provide a spending summary", "spending"));
        trainingData.add(createFeatures("What's my total expenditure this month?", "spending"));
        trainingData.add(createFeatures("Detail my spending on utilities", "spending"));
        trainingData.add(createFeatures("Recent spending breakdown", "spending"));
        trainingData.add(createFeatures("Track my expenditure", "spending"));
        trainingData.add(createFeatures("How much money have I spent?", "spending"));
        trainingData.add(createFeatures("Spending overview", "spending"));
        trainingData.add(createFeatures("Expense details for this week", "spending"));
        trainingData.add(createFeatures("Can I see my spending chart?", "spending"));
        trainingData.add(createFeatures("What are my major expenses?", "spending"));
        trainingData.add(createFeatures("Provide a breakdown of my spending", "spending"));
        trainingData.add(createFeatures("Track my daily spending", "spending"));
        trainingData.add(createFeatures("What did I spend on transportation?", "spending"));
        trainingData.add(createFeatures("Spending report", "spending"));
        trainingData.add(createFeatures("How are my spending patterns?", "spending"));
        trainingData.add(createFeatures("Show my expense report", "spending"));
        trainingData.add(createFeatures("Monthly spending details", "spending"));
        trainingData.add(createFeatures("How much did I overspend this month?", "spending"));
        trainingData.add(createFeatures("Spending data summary", "spending"));
        trainingData.add(createFeatures("Financial outflow details", "spending"));
        trainingData.add(createFeatures("Where did I spend the most money?", "spending"));
        trainingData.add(createFeatures("Show my recurring expenses", "spending"));
        trainingData.add(createFeatures("What did I spend at restaurants?", "spending"));
        trainingData.add(createFeatures("How much went to online shopping?", "spending"));
        trainingData.add(createFeatures("Show my subscription expenses", "spending"));
        trainingData.add(createFeatures("What did I spend on Amazon?", "spending"));
        trainingData.add(createFeatures("How much did I spend on coffee?", "spending"));
        trainingData.add(createFeatures("Show my weekend spending", "spending"));
        trainingData.add(createFeatures("What are my work-related expenses?", "spending"));
        trainingData.add(createFeatures("How much did I spend on gifts?", "spending"));
        trainingData.add(createFeatures("Show my medical expenses", "spending"));
        trainingData.add(createFeatures("What did I spend on home maintenance?", "spending"));
        trainingData.add(createFeatures("Detail my insurance payments", "spending"));
        trainingData.add(createFeatures("Show my pet expenses", "spending"));
        trainingData.add(createFeatures("How much did I spend on hobbies?", "spending"));
        trainingData.add(createFeatures("What are my cash withdrawals?", "spending"));
        trainingData.add(createFeatures("Show my charitable donations", "spending"));
        trainingData.add(createFeatures("Detail my gym and fitness expenses", "spending"));
        trainingData.add(createFeatures("What did I spend on books?", "spending"));
        trainingData.add(createFeatures("Show my technology purchases", "spending"));

        // Prediction-related queries (50 samples)
        trainingData.add(createFeatures("What will I spend next month?", "prediction"));
        trainingData.add(createFeatures("Predict my expenses for December", "prediction"));
        trainingData.add(createFeatures("How much will groceries cost next week?", "prediction"));
        trainingData.add(createFeatures("Forecast my expenses for the coming month", "prediction"));
        trainingData.add(createFeatures("Can you predict my spending for next month?", "prediction"));
        trainingData.add(createFeatures("What's the predicted expenditure for this month?", "prediction"));
        trainingData.add(createFeatures("Future spending prediction", "prediction"));
        trainingData.add(createFeatures("Estimate my upcoming expenses", "prediction"));
        trainingData.add(createFeatures("What are my projected costs?", "prediction"));
        trainingData.add(createFeatures("Predict future spending habits", "prediction"));
        trainingData.add(createFeatures("Forecast my monthly spending", "prediction"));
        trainingData.add(createFeatures("Can you estimate next month's expenses?", "prediction"));
        trainingData.add(createFeatures("What will be my expenditure trend?", "prediction"));
        trainingData.add(createFeatures("Predict expense forecast", "prediction"));
        trainingData.add(createFeatures("Anticipate my spending for next month", "prediction"));
        trainingData.add(createFeatures("Estimate my future financial outflow", "prediction"));
        trainingData.add(createFeatures("Future expense estimate", "prediction"));
        trainingData.add(createFeatures("Projected spending for next month", "prediction"));
        trainingData.add(createFeatures("How much am I expected to spend?", "prediction"));
        trainingData.add(createFeatures("Upcoming spending prediction", "prediction"));
        trainingData.add(createFeatures("What will my expenses look like next month?", "prediction"));
        trainingData.add(createFeatures("Forecast my future costs", "prediction"));
        trainingData.add(createFeatures("Predict my next month's spending", "prediction"));
        trainingData.add(createFeatures("Future budget forecast", "prediction"));
        trainingData.add(createFeatures("What expenses do I anticipate?", "prediction"));
        trainingData.add(createFeatures("Predict upcoming expenditures", "prediction"));
        trainingData.add(createFeatures("Estimate the cost for next week", "prediction"));
        trainingData.add(createFeatures("What is the forecast for my expenses?", "prediction"));
        trainingData.add(createFeatures("Anticipated spending details", "prediction"));
        trainingData.add(createFeatures("Estimate future outflow", "prediction"));
        trainingData.add(createFeatures("Will I stay within budget next month?", "prediction"));
        trainingData.add(createFeatures("Predict my holiday spending", "prediction"));
        trainingData.add(createFeatures("What will utilities cost next month?", "prediction"));
        trainingData.add(createFeatures("Forecast my subscription costs", "prediction"));
        trainingData.add(createFeatures("Predict next quarter's expenses", "prediction"));
        trainingData.add(createFeatures("How much should I save next month?", "prediction"));
        trainingData.add(createFeatures("What will my rent increase to?", "prediction"));
        trainingData.add(createFeatures("Predict my travel expenses", "prediction"));
        trainingData.add(createFeatures("Future entertainment costs", "prediction"));
        trainingData.add(createFeatures("Will I need to adjust my budget?", "prediction"));
        trainingData.add(createFeatures("Predict my annual expenses", "prediction"));
        trainingData.add(createFeatures("What will groceries cost next month?", "prediction"));
        trainingData.add(createFeatures("Forecast my insurance premiums", "prediction"));
        trainingData.add(createFeatures("Predict my car maintenance costs", "prediction"));
        trainingData.add(createFeatures("What will healthcare cost me?", "prediction"));
        trainingData.add(createFeatures("Estimate next year's expenses", "prediction"));
        trainingData.add(createFeatures("Predict my debt payments", "prediction"));
        trainingData.add(createFeatures("Future household expenses", "prediction"));
        trainingData.add(createFeatures("What will my tax burden be?", "prediction"));
        trainingData.add(createFeatures("Predict educational expenses", "prediction"));

        // General financial queries (50 samples)
        trainingData.add(createFeatures("Tell me about my finances", "general"));
        trainingData.add(createFeatures("What's my financial status?", "general"));
        trainingData.add(createFeatures("Help me with my money", "general"));
        trainingData.add(createFeatures("Show me my overall financial overview", "general"));
        trainingData.add(createFeatures("Give me a financial summary", "general"));
        trainingData.add(createFeatures("What's the state of my finances?", "general"));
        trainingData.add(createFeatures("Provide my financial report", "general"));
        trainingData.add(createFeatures("How healthy are my finances?", "general"));
        trainingData.add(createFeatures("Overall financial update", "general"));
        trainingData.add(createFeatures("Detail my financial situation", "general"));
        trainingData.add(createFeatures("What is my net worth?", "general"));
        trainingData.add(createFeatures("Show my financial breakdown", "general"));
        trainingData.add(createFeatures("Provide an overview of my money", "general"));
        trainingData.add(createFeatures("What does my financial picture look like?", "general"));
        trainingData.add(createFeatures("General financial health check", "general"));
        trainingData.add(createFeatures("How am I doing financially?", "general"));
        trainingData.add(createFeatures("Can you give me a financial overview?", "general"));
        trainingData.add(createFeatures("Current financial summary", "general"));
        trainingData.add(createFeatures("What are my financial metrics?", "general"));
        trainingData.add(createFeatures("Financial analysis of my expenses", "general"));
        trainingData.add(createFeatures("My financial snapshot", "general"));
        trainingData.add(createFeatures("Overall money management status", "general"));
        trainingData.add(createFeatures("Detailed financial status report", "general"));
        trainingData.add(createFeatures("Show my income and expenses overview", "general"));
        trainingData.add(createFeatures("Provide my fiscal overview", "general"));
        trainingData.add(createFeatures("What is my current monetary status?", "general"));
        trainingData.add(createFeatures("Update on my overall finances", "general"));
        trainingData.add(createFeatures("Comprehensive financial summary", "general"));
        trainingData.add(createFeatures("Financial condition update", "general"));
        trainingData.add(createFeatures("Detailed overview of my finances", "general"));
        trainingData.add(createFeatures("How's my cash flow looking?", "general"));
        trainingData.add(createFeatures("What's my financial health score?", "general"));
        trainingData.add(createFeatures("Show my asset allocation", "general"));
        trainingData.add(createFeatures("What are my top financial priorities?", "general"));
        trainingData.add(createFeatures("Give me a money management review", "general"));
        trainingData.add(createFeatures("How diversified are my investments?", "general"));
        trainingData.add(createFeatures("What's my debt-to-income ratio?", "general"));
        trainingData.add(createFeatures("Show my emergency fund status", "general"));
        trainingData.add(createFeatures("What's my savings rate?", "general"));
        trainingData.add(createFeatures("How much do I have in investments?", "general"));
        trainingData.add(createFeatures("What's my credit utilization?", "general"));
        trainingData.add(createFeatures("Show my retirement accounts", "general"));
        trainingData.add(createFeatures("What's my overall wealth trend?", "general"));
        trainingData.add(createFeatures("How much equity do I have?", "general"));
        trainingData.add(createFeatures("What's my monthly cash flow?", "general"));
        trainingData.add(createFeatures("Show my investment returns", "general"));
        trainingData.add(createFeatures("What's my financial risk profile?", "general"));
        trainingData.add(createFeatures("How much am I worth?", "general"));
        trainingData.add(createFeatures("Show my tax efficiency", "general"));
        trainingData.add(createFeatures("What's my liquidity position?", "general"));

        classifier.train(trainingData);
    }

    private TransactionNaiveBayes.TransactionFeatures createFeatures(String query, String intent) {
        return new TransactionNaiveBayes.TransactionFeatures(
            query,                // Description
            BigDecimal.ZERO,      // Amount (not used here)
            LocalDateTime.now(),  // Date (not used here)
            intent,               // Category (intent in this case)
            null,                 // AccountType (not used)
            ""                    // AccountName (not used)
        );
    }

    public String detectIntent(String query) {
        TransactionNaiveBayes.TransactionFeatures features = createFeatures(query, "unknown");
        Map<String, Double> predictions = classifier.predict(features);

        return predictions.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse("general");
    }
}===== ./src/main/java/org/emblow/envelopify/service/CategoryService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Category;
import org.emblow.envelopify.domain.User;
import org.emblow.envelopify.repository.CategoryRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
public class CategoryService {
    private static final Logger log = LoggerFactory.getLogger(CategoryService.class);
    
    private final CategoryRepository categoryRepository;
    private final SecurityService securityService;

    public CategoryService(
        CategoryRepository categoryRepository,
        SecurityService securityService
    ) {
        this.categoryRepository = categoryRepository;
        this.securityService = securityService;
    }

    @Transactional
    public Category create(String name, String description) {
        try {
            // Set the owner to the current user
            User currentUser = securityService.getCurrentUser();
            
            // Check if category already exists for this user
            Optional<Category> existing = categoryRepository.findByNameAndOwner(name, currentUser);
            if (existing.isPresent()) {
                throw new IllegalArgumentException("Category already exists: " + name);
            }
            
            Category category = new Category(name, description);
            category.setOwner(currentUser);
            
            return categoryRepository.save(category);
            
        } catch (Exception e) {
            log.error("Error creating category", e);
            throw new RuntimeException("Could not create category: " + e.getMessage());
        }
    }

    @Transactional
    public Category update(Long id, String name, String description) {
        try {
            Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Category not found"));
                
            // Validate ownership
            securityService.validateOwnership(category.getOwner());
            
            category.setName(name);
            category.setDescription(description);
            
            return categoryRepository.save(category);
            
        } catch (Exception e) {
            log.error("Error updating category", e);
            throw new RuntimeException("Could not update category: " + e.getMessage());
        }
    }

    @Transactional
    public void delete(Long id) {
        try {
            Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Category not found"));
                
            // Validate ownership
            securityService.validateOwnership(category.getOwner());
            
            categoryRepository.delete(category);
            
        } catch (Exception e) {
            log.error("Error deleting category", e);
            throw new RuntimeException("Could not delete category: " + e.getMessage());
        }
    }

    public List<Category> getAllForCurrentUser() {
        try {
            User currentUser = securityService.getCurrentUser();
            return categoryRepository.findByOwner(currentUser);
            
        } catch (Exception e) {
            log.error("Error retrieving categories", e);
            throw new RuntimeException("Could not retrieve categories: " + e.getMessage());
        }
    }

    public Category getById(Long id) {
        try {
            Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Category not found"));
                
            // Validate ownership
            securityService.validateOwnership(category.getOwner());
            
            return category;
            
        } catch (Exception e) {
            log.error("Error retrieving category", e);
            throw new RuntimeException("Could not retrieve category: " + e.getMessage());
        }
    }

    // Helper method for services that need to do ownership validation
    public void validateOwnership(Long categoryId) {
        Category category = categoryRepository.findById(categoryId)
            .orElseThrow(() -> new RuntimeException("Category not found"));
        securityService.validateOwnership(category.getOwner());
    }
}
===== ./src/main/java/org/emblow/envelopify/service/PatternService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Pattern;
import org.emblow.envelopify.domain.Pattern.PatternType;
import org.emblow.envelopify.domain.Category;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.User;
import org.emblow.envelopify.repository.PatternRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class PatternService {
    private static final Logger log = LoggerFactory.getLogger(PatternService.class);
    private static final double MIN_CONFIDENCE = 0.3;
    
    private final PatternRepository patternRepository;
    private final CategoryService categoryService;
    private final SecurityService securityService;
    private final EnvelopeService envelopeService;

    public PatternService(
        PatternRepository patternRepository,
        CategoryService categoryService,
        SecurityService securityService,
        EnvelopeService envelopeService  // Add this parameter
    ) {
        this.patternRepository = patternRepository;
        this.categoryService = categoryService;
        this.securityService = securityService;
        this.envelopeService = envelopeService;  // Add this assignment
    }


    @Transactional
    public Pattern createPattern(String pattern, PatternType type, Long categoryId) {
        try {
            // Validate category ownership
            Category category = categoryService.getById(categoryId);
            
            // Check if pattern already exists
            Optional<Pattern> existing = patternRepository.findByPatternAndType(pattern, type);
            if (existing.isPresent()) {
                throw new IllegalArgumentException("Pattern already exists");
            }
            
            Pattern newPattern = new Pattern(pattern, type, category);
            return patternRepository.save(newPattern);
            
        } catch (IllegalArgumentException e) {
            log.error("Error creating pattern", e);
            throw new RuntimeException("Could not create pattern: " + e.getMessage());
        }
    }

    @Transactional
    public void delete(Long id) {
        try {
            Pattern pattern = patternRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Pattern not found"));
                
            // Validate ownership through category
            categoryService.validateOwnership(pattern.getCategory().getId());
            
            patternRepository.delete(pattern);
            
        } catch (Exception e) {
            log.error("Error deleting pattern", e);
            throw new RuntimeException("Could not delete pattern: " + e.getMessage());
        }
    }

 public Map<Envelope, Double> suggestEnvelopes(Transaction transaction) {
    try {
        User currentUser = securityService.getCurrentUser();
        Map<Envelope, Double> suggestions = new HashMap<>();
        
        // Get confident patterns for current user
        List<Pattern> patterns = patternRepository.findConfidentPatterns(
            currentUser.getId(), 
            MIN_CONFIDENCE
        );
        
        // Track category scores first since patterns don't link directly to envelopes
        Map<Category, Double> categoryScores = new HashMap<>();
        
        // Match patterns against transaction
        for (Pattern pattern : patterns) {
            if (pattern.appliesTo(transaction)) {
                Category category = pattern.getCategory();
                categoryScores.merge(category, pattern.getConfidence(), Double::sum);
            }
        }
        
        // Normalize category scores
        double total = categoryScores.values().stream()
            .mapToDouble(Double::doubleValue)
            .sum();
            
        if (total > 0) {
            categoryScores.forEach((category, score) -> 
                categoryScores.put(category, score / total));
                
            // Find envelopes with matching categories and apply the scores
            List<Envelope> userEnvelopes = envelopeService.getAllEnvelopes();  // Need to inject EnvelopeService
            for (Envelope envelope : userEnvelopes) {
                // Match envelopes to categories based on names as a simple approach
                categoryScores.entrySet().stream()
                    .filter(entry -> envelope.getName().toLowerCase()
                        .contains(entry.getKey().getName().toLowerCase()))
                    .findFirst()
                    .ifPresent(entry -> suggestions.put(envelope, entry.getValue()));
            }
        }
        
        return suggestions;
        
    } catch (Exception e) {
        log.error("Error suggesting envelopes", e);
        throw new RuntimeException("Could not suggest envelopes: " + e.getMessage());
    }
}

    @Transactional
    public void learnFromTransaction(Transaction transaction, boolean wasCorrect) {
        try {
            User currentUser = securityService.getCurrentUser();
            List<Pattern> patterns = patternRepository.findByUserId(currentUser.getId());
            
            boolean patternFound = false;
            for (Pattern pattern : patterns) {
                if (pattern.appliesTo(transaction)) {
                    pattern.incrementMatch(wasCorrect);
                    patternFound = true;
                }
            }
            
            // If no patterns matched and the transaction was correct,
            // create new patterns based on the transaction
            if (!patternFound && wasCorrect) {
                createPatternsFromTransaction(transaction);
            }
            
        } catch (Exception e) {
            log.error("Error learning from transaction", e);
            throw new RuntimeException("Could not learn from transaction: " + e.getMessage());
        }
    }

    private void createPatternsFromTransaction(Transaction transaction) {
        try {
            Category category = transaction.getEnvelope().getCategory();
            if (category == null) {
                log.warn("No category found for envelope: {}", transaction.getEnvelope().getName());
                return;
            }
            
            // Create merchant pattern
            createPattern(
                transaction.getDescription().toLowerCase(),
                PatternType.MERCHANT,
                category.getId()
            );
            
            // Create temporal pattern
            LocalDateTime date = transaction.getDate();
            String temporalPattern;
            if (date.getDayOfMonth() <= 5 || date.getDayOfMonth() >= 25) {
                // Monthly pattern
                temporalPattern = "DOM" + date.getDayOfMonth() + ":" + date.getHour();
            } else {
                // Weekly pattern
                temporalPattern = "DOW" + date.getDayOfWeek().getValue() + ":" + date.getHour();
            }
            createPattern(temporalPattern, PatternType.TEMPORAL, category.getId());
            
            // Create amount pattern
            String amountPattern = "=" + transaction.getAmount().toString();
            createPattern(amountPattern, PatternType.AMOUNT, category.getId());
            
        } catch (Exception e) {
            log.error("Error creating patterns from transaction", e);
            // Don't throw - this is a best-effort pattern creation
        }
    }

    public List<Pattern> getPatternsByCategory(Long categoryId) {
        try {
            // Validate category ownership
            Category category = categoryService.getById(categoryId);
            return patternRepository.findByCategory(category);
            
        } catch (Exception e) {
            log.error("Error retrieving patterns by category", e);
            throw new RuntimeException("Could not retrieve patterns: " + e.getMessage());
        }
    }

    public List<Pattern> getPatternsByType(PatternType type) {
        try {
            User currentUser = securityService.getCurrentUser();
            // Filter patterns by user through the category owner
            return patternRepository.findByType(type).stream()
                .filter(p -> p.getCategory().getOwner().getId().equals(currentUser.getId()))
                .collect(Collectors.toList());
                
        } catch (Exception e) {
            log.error("Error retrieving patterns by type", e);
            throw new RuntimeException("Could not retrieve patterns: " + e.getMessage());
        }
    }
}
===== ./src/main/java/org/emblow/envelopify/service/EnvelopeService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Envelope;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.emblow.envelopify.domain.InsufficientFundsException;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.User;
import org.emblow.envelopify.exception.BusinessException;
import org.emblow.envelopify.exception.EnvelopeException;
import org.emblow.envelopify.exception.ValidationException;
import org.emblow.envelopify.repository.EnvelopeRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.DataIntegrityViolationException;

@Service
public class EnvelopeService {
        private static final Logger log = LoggerFactory.getLogger(EnvelopeService.class);
    private final EnvelopeRepository envelopeRepository;
    private final SecurityService securityService;
    public EnvelopeService(
        EnvelopeRepository envelopeRepository,
        SecurityService securityService
    ) {
        this.envelopeRepository = envelopeRepository;
        this.securityService = securityService;
    }


    public List<Envelope> getAllEnvelopes() {
        User currentUser = securityService.getCurrentUser();
        return envelopeRepository.findByOwner(currentUser);
    }

    @Transactional
    public Envelope getEnvelope(Long id) {
        User currentUser = securityService.getCurrentUser();
        return envelopeRepository.findByIdAndOwnerWithTransactions(id, currentUser)
            .orElseThrow(() -> new RuntimeException("Envelope not found"));
    }


    @Transactional
    public Envelope createEnvelope(String name, BigDecimal initialAllocation) {
        validateEnvelopeCreation(name, initialAllocation);
        
        User currentUser = securityService.getCurrentUser();
        Envelope envelope = new Envelope(name, initialAllocation, currentUser);
        
        try {
            return envelopeRepository.save(envelope);
        } catch (DataIntegrityViolationException e) {
            throw new BusinessException("DUPLICATE_ENVELOPE", 
                "An envelope with this name already exists");
        }
    }
    private void validateEnvelopeCreation(String name, BigDecimal initialAllocation) {
        Map<String, String> violations = new HashMap<>();
        
        if (name == null || name.trim().isEmpty()) {
            violations.put("name", "Name is required");
        } else if (name.length() > 100) {
            violations.put("name", "Name must be less than 100 characters");
        }
        
        if (initialAllocation == null) {
            violations.put("initialAllocation", "Initial allocation is required");
        } else if (initialAllocation.compareTo(BigDecimal.ZERO) < 0) {
            violations.put("initialAllocation", 
                "Initial allocation cannot be negative");
        }
        
        if (!violations.isEmpty()) {
            throw new ValidationException(violations);
        }
    }
     @Transactional
    public void reallocate(Long sourceId, Long targetId, BigDecimal amount) {
        validateReallocation(sourceId, targetId, amount);
        
        User currentUser = securityService.getCurrentUser();
        
        Envelope source = envelopeRepository.findByIdAndOwner(sourceId, currentUser)
            .orElseThrow(() -> new EnvelopeException(
                EnvelopeException.ENVELOPE_NOT_FOUND, 
                "Source envelope not found"
            ));
            
        Envelope target = envelopeRepository.findByIdAndOwner(targetId, currentUser)
            .orElseThrow(() -> new EnvelopeException(
                EnvelopeException.ENVELOPE_NOT_FOUND, 
                "Target envelope not found"
            ));

        if (sourceId.equals(targetId)) {
            throw new BusinessException("INVALID_OPERATION", 
                "Cannot move money to the same envelope");
        }

        if (!source.canSpend(amount)) {
            throw new EnvelopeException(
                EnvelopeException.INSUFFICIENT_FUNDS,
                String.format("Insufficient funds in %s: required %.2f, available %.2f",
                    source.getName(), amount, source.getAvailable())
            );
        }

        source.withdraw(amount);
        target.allocate(amount);
        
        envelopeRepository.save(source);
        envelopeRepository.save(target);
    }

    @Transactional
    public Envelope save(Envelope envelope) {
        return envelopeRepository.save(envelope);
    }

    @Transactional
    public Envelope updateEnvelope(Long id, String name) {
        Envelope envelope = getEnvelope(id);
        envelope.setName(name);
        return envelopeRepository.save(envelope);
    }
    
    private void validateReallocation(Long sourceId, Long targetId, BigDecimal amount) {
        Map<String, String> violations = new HashMap<>();
        
        if (sourceId == null) {
            violations.put("sourceId", "Source envelope ID is required");
        }
        
        if (targetId == null) {
            violations.put("targetId", "Target envelope ID is required");
        }
        
        if (amount == null) {
            violations.put("amount", "Amount is required");
        } else if (amount.compareTo(BigDecimal.ZERO) <= 0) {
            violations.put("amount", "Amount must be positive");
        }
        
        if (!violations.isEmpty()) {
            throw new ValidationException(violations);
        }
    }
    
    @Transactional
    public void flush() {
        envelopeRepository.flush();
    }


    @Transactional
    public void deleteEnvelope(Long sourceId, Long targetId) {
        validateEnvelopeDeletion(sourceId, targetId);
        
        User currentUser = securityService.getCurrentUser();

        Envelope source = envelopeRepository.findByIdAndOwner(sourceId, currentUser)
            .orElseThrow(() -> new EnvelopeException(
                EnvelopeException.ENVELOPE_NOT_FOUND, 
                "Source envelope not found"
            ));
            
        Envelope target = envelopeRepository.findByIdAndOwner(targetId, currentUser)
            .orElseThrow(() -> new EnvelopeException(
                EnvelopeException.ENVELOPE_NOT_FOUND, 
                "Target envelope not found"
            ));

        if (sourceId.equals(targetId)) {
            throw new BusinessException("INVALID_OPERATION", 
                "Cannot transfer to the same envelope");
        }

        // Transfer allocation and spent amounts
        target.allocate(source.getAllocated());
        if (source.getSpent().compareTo(BigDecimal.ZERO) > 0) {
            target.spend(source.getSpent());
        }

        // Update transactions to point to target envelope
        source.getTransactions().forEach(tx -> tx.setEnvelope(target));

        try {
            envelopeRepository.save(target);
            envelopeRepository.deleteById(sourceId);
        } catch (Exception e) {
            throw new BusinessException("DELETE_FAILED", 
                "Failed to delete envelope: " + e.getMessage());
        }
    }

    private void validateEnvelopeDeletion(Long sourceId, Long targetId) {
        Map<String, String> violations = new HashMap<>();
        
        if (sourceId == null) {
            violations.put("sourceId", "Source envelope ID is required");
        }
        
        if (targetId == null) {
            violations.put("targetId", "Target envelope ID is required");
        }
        
        if (!violations.isEmpty()) {
            throw new ValidationException(violations);
        }
    }
}===== ./src/main/java/org/emblow/envelopify/service/ml/TransactionNaiveBayes.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */
import java.util.*;
import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.Month;
import java.math.BigDecimal;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.emblow.envelopify.domain.Account;
import java.util.stream.Collectors;

public class TransactionNaiveBayes {
    private static final Logger log = LoggerFactory.getLogger(TransactionNaiveBayes.class);
    
    // Probability tables
    private final Map<String, Double> categoryPriors = new HashMap<>();
    private final Map<String, Map<String, Double>> wordLikelihoods = new HashMap<>();
    private final Map<String, GaussianDistribution> amountDistributions = new HashMap<>();
    private final Map<String, Map<DayOfWeek, Double>> dayOfWeekLikelihoods = new HashMap<>();
    private final Map<String, Map<Month, Double>> monthLikelihoods = new HashMap<>();
    private final Map<String, Map<Account.AccountType, Double>> accountTypeLikelihoods = new HashMap<>();
    private final Map<String, Map<String, Double>> accountNameLikelihoods = new HashMap<>();
    
    // Smoothing parameters
    private static final double ALPHA = 1.0;  // Laplace smoothing
    private static final double MIN_STD_DEV = 0.01;  // Minimum standard deviation
    
    // Feature weights
    private static final double WORD_WEIGHT = 0.4;
    private static final double AMOUNT_WEIGHT = 0.25;
    private static final double TIME_WEIGHT = 0.15;
    private static final double ACCOUNT_TYPE_WEIGHT = 0.1;
    private static final double ACCOUNT_NAME_WEIGHT = 0.1;
    
    private final Set<String> vocabulary = new HashSet<>();
    private final TextPreprocessor textPreprocessor;
    
    public TransactionNaiveBayes() {
        this.textPreprocessor = new TextPreprocessor();
    }
    
    public void train(List<TransactionFeatures> transactions) {
        log.info("Training NBC with {} transactions", transactions.size());
        
        // Clear previous state
        categoryPriors.clear();
        wordLikelihoods.clear();
        amountDistributions.clear();
        dayOfWeekLikelihoods.clear();
        monthLikelihoods.clear();
        accountTypeLikelihoods.clear();
        accountNameLikelihoods.clear();
        vocabulary.clear();
        
        // Count category frequencies
        Map<String, Integer> categoryCounts = new HashMap<>();
        for (TransactionFeatures tx : transactions) {
            categoryCounts.merge(tx.category(), 1, Integer::sum);
        }
        
        // Calculate priors
        int totalTransactions = transactions.size();
        categoryCounts.forEach((category, count) -> 
            categoryPriors.put(category, (count.doubleValue() + ALPHA) / 
                (totalTransactions + ALPHA * categoryCounts.size())));
        
        // Build vocabulary
        transactions.forEach(tx -> 
            vocabulary.addAll(Arrays.asList(textPreprocessor.tokenize(tx.description()))));
        
        // Initialize likelihood tables
        for (String category : categoryCounts.keySet()) {
            wordLikelihoods.put(category, new HashMap<>());
            dayOfWeekLikelihoods.put(category, new HashMap<>());
            monthLikelihoods.put(category, new HashMap<>());
            accountTypeLikelihoods.put(category, new HashMap<>());
            accountNameLikelihoods.put(category, new HashMap<>());
        }
        
        // Calculate all likelihoods
        calculateWordLikelihoods(transactions, categoryCounts);
        calculateAmountDistributions(transactions, categoryCounts);
        calculateTemporalLikelihoods(transactions, categoryCounts);
        calculateAccountLikelihoods(transactions, categoryCounts);
        
        log.info("Training complete. Vocabulary size: {}", vocabulary.size());
    }
    
    public Map<String, Double> predict(TransactionFeatures transaction) {
        Map<String, Double> scores = new HashMap<>();
        double totalScore = 0.0;
        
        // Calculate scores for each category
        for (String category : categoryPriors.keySet()) {
            double score = Math.log(categoryPriors.get(category));
            
            // Word features
            String[] words = textPreprocessor.tokenize(transaction.description());
            double wordScore = 0.0;
            for (String word : words) {
                if (vocabulary.contains(word)) {
                    wordScore += Math.log(wordLikelihoods.get(category)
                        .getOrDefault(word, ALPHA / (vocabulary.size() * ALPHA)));
                }
            }
            
            // Amount feature
            double amountScore = amountDistributions.get(category)
                .logProbability(transaction.amount().doubleValue());
            
            // Temporal features
            double dayScore = Math.log(dayOfWeekLikelihoods.get(category)
                .getOrDefault(transaction.date().getDayOfWeek(), 
                    ALPHA / (7 * ALPHA)));
            double monthScore = Math.log(monthLikelihoods.get(category)
                .getOrDefault(transaction.date().getMonth(), 
                    ALPHA / (12 * ALPHA)));
                    
            // Account features
            double accountTypeScore = Math.log(accountTypeLikelihoods.get(category)
                .getOrDefault(transaction.accountType(), 
                    ALPHA / (Account.AccountType.values().length * ALPHA)));
                    
            double accountNameScore = Math.log(accountNameLikelihoods.get(category)
                .getOrDefault(transaction.accountName(), 
                    ALPHA / accountNameLikelihoods.size()));
            
            // Combine scores with weights
            score += WORD_WEIGHT * wordScore +
                    AMOUNT_WEIGHT * amountScore +
                    TIME_WEIGHT * (dayScore + monthScore) +
                    ACCOUNT_TYPE_WEIGHT * accountTypeScore +
                    ACCOUNT_NAME_WEIGHT * accountNameScore;
            
            scores.put(category, Math.exp(score));
            totalScore += Math.exp(score);
        }
        
        // Normalize probabilities
        Map<String, Double> normalizedScores = new HashMap<>();
        for (Map.Entry<String, Double> entry : scores.entrySet()) {
            normalizedScores.put(entry.getKey(), entry.getValue() / totalScore);
        }
        
        return normalizedScores;
    }
    
    private void calculateWordLikelihoods(
        List<TransactionFeatures> transactions,
        Map<String, Integer> categoryCounts
    ) {
        // Count word occurrences per category
        Map<String, Map<String, Integer>> wordCounts = new HashMap<>();
        categoryCounts.keySet().forEach(category -> 
            wordCounts.put(category, new HashMap<>()));
        
        for (TransactionFeatures tx : transactions) {
            String[] words = textPreprocessor.tokenize(tx.description());
            for (String word : words) {
                wordCounts.get(tx.category()).merge(word, 1, Integer::sum);
            }
        }
        
        // Calculate likelihoods with Laplace smoothing
        for (String category : categoryCounts.keySet()) {
            int totalWords = wordCounts.get(category).values().stream()
                .mapToInt(Integer::intValue).sum();
            
            for (String word : vocabulary) {
                int count = wordCounts.get(category).getOrDefault(word, 0);
                double likelihood = (count + ALPHA) / 
                    (totalWords + ALPHA * vocabulary.size());
                wordLikelihoods.get(category).put(word, likelihood);
            }
        }
    }
    
    private void calculateAccountLikelihoods(
        List<TransactionFeatures> transactions,
        Map<String, Integer> categoryCounts
    ) {
        // Count account patterns per category
        Map<String, Map<Account.AccountType, Integer>> typeCountsByCategory = new HashMap<>();
        Map<String, Map<String, Integer>> nameCountsByCategory = new HashMap<>();
        
        for (TransactionFeatures tx : transactions) {
            // Account type counts
            typeCountsByCategory
                .computeIfAbsent(tx.category(), k -> new HashMap<>())
                .merge(tx.accountType(), 1, Integer::sum);
                
            // Account name counts
            nameCountsByCategory
                .computeIfAbsent(tx.category(), k -> new HashMap<>())
                .merge(tx.accountName(), 1, Integer::sum);
        }
        
        // Calculate likelihoods with smoothing
        for (String category : categoryCounts.keySet()) {
            int totalTx = categoryCounts.get(category);
            
            // Account type likelihoods
            for (Account.AccountType type : Account.AccountType.values()) {
                int count = typeCountsByCategory
                    .getOrDefault(category, Map.of())
                    .getOrDefault(type, 0);
                    
                double likelihood = (count + ALPHA) / 
                    (totalTx + ALPHA * Account.AccountType.values().length);
                    
                accountTypeLikelihoods.get(category).put(type, likelihood);
            }
            
            // Account name likelihoods
            Set<String> allAccountNames = nameCountsByCategory.values().stream()
                .flatMap(m -> m.keySet().stream())
                .collect(Collectors.toSet());
                
            for (String name : allAccountNames) {
                int count = nameCountsByCategory
                    .getOrDefault(category, Map.of())
                    .getOrDefault(name, 0);
                    
                double likelihood = (count + ALPHA) / 
                    (totalTx + ALPHA * allAccountNames.size());
                    
                accountNameLikelihoods.get(category).put(name, likelihood);
            }
        }
    }
    
    private void calculateAmountDistributions(
        List<TransactionFeatures> transactions,
        Map<String, Integer> categoryCounts
    ) {
        // Group amounts by category
        Map<String, List<Double>> amountsByCategory = new HashMap<>();
        categoryCounts.keySet().forEach(category -> 
            amountsByCategory.put(category, new ArrayList<>()));
        
        transactions.forEach(tx -> 
            amountsByCategory.get(tx.category())
                .add(tx.amount().doubleValue()));
        
        // Calculate distributions
        amountsByCategory.forEach((category, amounts) -> {
            double mean = amounts.stream()
                .mapToDouble(Double::doubleValue)
                .average()
                .orElse(0.0);
            
            double variance = amounts.stream()
                .mapToDouble(a -> Math.pow(a - mean, 2))
                .average()
                .orElse(MIN_STD_DEV);
            
            amountDistributions.put(category, 
                new GaussianDistribution(mean, Math.sqrt(variance)));
        });
    }
    
    private void calculateTemporalLikelihoods(
        List<TransactionFeatures> transactions,
        Map<String, Integer> categoryCounts
    ) {
        // Count temporal patterns
        Map<String, Map<DayOfWeek, Integer>> dayCountsByCategory = new HashMap<>();
        Map<String, Map<Month, Integer>> monthCountsByCategory = new HashMap<>();
        
        categoryCounts.keySet().forEach(category -> {
            dayCountsByCategory.put(category, new HashMap<>());
            monthCountsByCategory.put(category, new HashMap<>());
        });
        
        for (TransactionFeatures tx : transactions) {
            dayCountsByCategory.get(tx.category())
                .merge(tx.date().getDayOfWeek(), 1, Integer::sum);
            monthCountsByCategory.get(tx.category())
                .merge(tx.date().getMonth(), 1, Integer::sum);
        }
        
        // Calculate likelihoods with Laplace smoothing
        for (String category : categoryCounts.keySet()) {
            // Days of week
            int totalDays = dayCountsByCategory.get(category).values().stream()
                .mapToInt(Integer::intValue).sum();
            
            for (DayOfWeek day : DayOfWeek.values()) {
                int count = dayCountsByCategory.get(category)
                    .getOrDefault(day, 0);
                double likelihood = (count + ALPHA) / (totalDays + 7 * ALPHA);
                dayOfWeekLikelihoods.get(category).put(day, likelihood);
            }
            
            // Months
            int totalMonths = monthCountsByCategory.get(category).values().stream()
                .mapToInt(Integer::intValue).sum();
            
            for (Month month : Month.values()) {
                int count = monthCountsByCategory.get(category)
                    .getOrDefault(month, 0);
                double likelihood = (count + ALPHA) / (totalMonths + 12 * ALPHA);
                monthLikelihoods.get(category).put(month, likelihood);
            }
        }
    }
    
    // Helper class for Gaussian distribution calculations
    private static class GaussianDistribution {
        private final double mean;
        private final double stdDev;
        
        public GaussianDistribution(double mean, double stdDev) {
            this.mean = mean;
            this.stdDev = Math.max(stdDev, MIN_STD_DEV);
        }
        
        public double logProbability(double x) {
            double zScore = (x - mean) / stdDev;
            return -0.5 * (Math.log(2 * Math.PI) + 
                2 * Math.log(stdDev) + zScore * zScore);
        }
    }
    
    // Helper class for text preprocessing
    private static class TextPreprocessor {
        public String[] tokenize(String text) {
            return text.toLowerCase()
                .replaceAll("[^a-z0-9\\s]", "")
                .split("\\s+");
        }
    }

    // Feature record
    public record TransactionFeatures(
        String description,
        BigDecimal amount,
        LocalDateTime date,
        String category,
        Account.AccountType accountType,
        String accountName
    ) {
        public static TransactionFeatures fromTransaction(
            org.emblow.envelopify.domain.Transaction tx
        ) {
            return new TransactionFeatures(
                tx.getDescription(),
                tx.getAmount(),
                tx.getDate(),
                tx.getEnvelope().getName(),
                tx.getAccount().getType(),
                tx.getAccount().getName()
            );
        }
    }
}===== ./src/main/java/org/emblow/envelopify/service/ml/SpendingInsight.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */
public class SpendingInsight {
    private final SpendingInsightType type;
    private final String message;
    private final double confidence;

    public SpendingInsight(SpendingInsightType type, String message, double confidence) {
        this.type = type;
        this.message = message;
        this.confidence = confidence;
    }

    public SpendingInsightType getType() {
        return type;
    }

    public String getMessage() {
        return message;
    }

    public double getConfidence() {
        return confidence;
    }
}===== ./src/main/java/org/emblow/envelopify/service/ml/SpendingInsightType.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */
public enum SpendingInsightType {
    RECURRING_PAYMENT,
    UNUSUAL_SPENDING,
    PREDICTED_EXPENSE,
    BUDGET_SUGGESTION,
    SEASONAL_PATTERN,
    REALLOCATION_SUGGESTION
}

===== ./src/main/java/org/emblow/envelopify/service/ml/TransactionClassifier.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.stereotype.Service;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.repository.TransactionRepository;
import org.emblow.envelopify.repository.EnvelopeRepository;
import org.emblow.envelopify.service.ml.TransactionNaiveBayes.TransactionFeatures;

import java.time.*;
import java.util.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.math.BigDecimal;

@Service
public class TransactionClassifier {
    private static final Logger log = LoggerFactory.getLogger(TransactionClassifier.class);
    
    private final TransactionRepository transactionRepository;
    private final EnvelopeRepository envelopeRepository;
    private final TransactionNaiveBayes classifier;
    
    // Cache of account-specific models
    private final Map<Account.AccountType, TransactionNaiveBayes> accountTypeModels = new HashMap<>();
    private final Map<String, TransactionNaiveBayes> accountSpecificModels = new HashMap<>();

    public TransactionClassifier(
        TransactionRepository transactionRepository,
        EnvelopeRepository envelopeRepository
    ) {
        this.transactionRepository = transactionRepository;
        this.envelopeRepository = envelopeRepository;
        this.classifier = new TransactionNaiveBayes();
    }

    public void trainModel() {
        List<Transaction> transactions = transactionRepository.findAll();
        if (transactions.isEmpty()) {
            log.warn("No transactions available for training");
            return;
        }

        // Train main classifier
        List<TransactionFeatures> features = transactions.stream()
            .map(TransactionFeatures::fromTransaction)
            .toList();
        classifier.train(features);
        
        // Train account type specific models
        for (Account.AccountType accountType : Account.AccountType.values()) {
            List<Transaction> accountTypeTransactions = transactions.stream()
                .filter(tx -> tx.getAccount().getType() == accountType)
                .toList();
                
            if (!accountTypeTransactions.isEmpty()) {
                TransactionNaiveBayes typeModel = new TransactionNaiveBayes();
                typeModel.train(accountTypeTransactions.stream()
                    .map(TransactionFeatures::fromTransaction)
                    .toList());
                accountTypeModels.put(accountType, typeModel);
            }
        }
        
        // Train account-specific models
        Set<String> accountNames = transactions.stream()
            .map(tx -> tx.getAccount().getName())
            .collect(java.util.stream.Collectors.toSet());
            
        for (String accountName : accountNames) {
            List<Transaction> accountTransactions = transactions.stream()
                .filter(tx -> tx.getAccount().getName().equals(accountName))
                .toList();
                
            if (accountTransactions.size() >= 50) { // Only train if enough data
                TransactionNaiveBayes accountModel = new TransactionNaiveBayes();
                accountModel.train(accountTransactions.stream()
                    .map(TransactionFeatures::fromTransaction)
                    .toList());
                accountSpecificModels.put(accountName, accountModel);
            }
        }
        
        log.info("Model trained with {} transactions", transactions.size());
    }

    public Map<Envelope, Double> predictCategory(Transaction transaction) {
        TransactionFeatures features = TransactionFeatures.fromTransaction(transaction);
        
        // Get predictions from different models
        Map<String, Double> generalPredictions = classifier.predict(features);
        Map<String, Double> typeSpecificPredictions = accountTypeModels
            .getOrDefault(transaction.getAccount().getType(), classifier)
            .predict(features);
        Map<String, Double> accountSpecificPredictions = accountSpecificModels
            .getOrDefault(transaction.getAccount().getName(), classifier)
            .predict(features);
            
        // Weighted combination of predictions
        Map<String, Double> combinedPredictions = new HashMap<>();
        Set<String> allCategories = new HashSet<>();
        allCategories.addAll(generalPredictions.keySet());
        allCategories.addAll(typeSpecificPredictions.keySet());
        allCategories.addAll(accountSpecificPredictions.keySet());
        
        for (String category : allCategories) {
            double generalWeight = 0.4;
            double typeWeight = 0.3;
            double accountWeight = 0.3;
            
            double combinedScore = 
                generalWeight * generalPredictions.getOrDefault(category, 0.0) +
                typeWeight * typeSpecificPredictions.getOrDefault(category, 0.0) +
                accountWeight * accountSpecificPredictions.getOrDefault(category, 0.0);
                
            combinedPredictions.put(category, combinedScore);
        }
        
        // Normalize combined scores
        double totalScore = combinedPredictions.values().stream()
            .mapToDouble(Double::doubleValue)
            .sum();
            
        Map<String, Double> normalizedPredictions = new HashMap<>();
        combinedPredictions.forEach((category, score) -> 
            normalizedPredictions.put(category, score / totalScore));
        
        // Convert category names to envelopes
        Map<Envelope, Double> predictions = new HashMap<>();
        normalizedPredictions.forEach((categoryName, probability) -> {
            if (probability > 0.05) { // Only include non-trivial probabilities
                transactionRepository.findByEnvelopeName(categoryName)
                    .stream()
                    .findFirst()
                    .ifPresent(tx -> predictions.put(tx.getEnvelope(), probability));
            }
        });
        
        return predictions;
    }

    public Map<Envelope, Double> suggestEnvelopesForAccount(Account account) {
        // Get recent transactions for this account
        LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
        List<Transaction> accountTransactions = transactionRepository.findAll().stream()
            .filter(tx -> tx.getAccount().getId().equals(account.getId()))
            .filter(tx -> tx.getDate().isAfter(oneMonthAgo))
            .toList();
            
        if (accountTransactions.isEmpty()) {
            return Map.of();
        }
        
        // Calculate envelope usage frequencies
        Map<Envelope, Integer> envelopeCounts = new HashMap<>();
        Map<Envelope, BigDecimal> envelopeAmounts = new HashMap<>();
        
        for (Transaction tx : accountTransactions) {
            envelopeCounts.merge(tx.getEnvelope(), 1, Integer::sum);
            envelopeAmounts.merge(tx.getEnvelope(), tx.getAmount(), BigDecimal::add);
        }
        
        // Calculate scores based on both frequency and amount
        Map<Envelope, Double> scores = new HashMap<>();
        double totalTransactions = accountTransactions.size();
        BigDecimal totalAmount = envelopeAmounts.values().stream()
            .reduce(BigDecimal.ZERO, BigDecimal::add);
            
        envelopeCounts.forEach((envelope, count) -> {
            double frequencyScore = count / totalTransactions;
            double amountScore = envelopeAmounts.get(envelope)
                .divide(totalAmount, 2, java.math.RoundingMode.HALF_UP)
                .doubleValue();
            scores.put(envelope, 0.5 * frequencyScore + 0.5 * amountScore);
        });
        
        return scores;
    }

    public void retrain() {
        accountTypeModels.clear();
        accountSpecificModels.clear();
        trainModel();
    }
}===== ./src/main/java/org/emblow/envelopify/service/ml/SpendingInsightService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.stereotype.Service;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.repository.TransactionRepository;
import org.emblow.envelopify.repository.AccountRepository;

import java.time.*;
import java.util.*;
import java.util.stream.Collectors;
import java.math.BigDecimal;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class SpendingInsightService {
    private static final Logger log = LoggerFactory.getLogger(SpendingInsightService.class);
    
    private final TransactionRepository transactionRepository;
    private final AccountRepository accountRepository;
    private final TransactionClassifier classifier;

    public SpendingInsightService(
        TransactionRepository transactionRepository,
        AccountRepository accountRepository,
        TransactionClassifier classifier
    ) {
        this.transactionRepository = transactionRepository;
        this.accountRepository = accountRepository;
        this.classifier = classifier;
    }

    public List<SpendingInsight> generateInsights() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        try {
            // Add different types of insights
            insights.addAll(detectRecurringPayments());
            insights.addAll(detectUnusualSpending());
            insights.addAll(predictUpcomingExpenses());
            insights.addAll(generateBudgetSuggestions());
            insights.addAll(generateAccountSpecificInsights());
            insights.addAll(detectCrossAccountPatterns());
            
            log.debug("Generated {} insights", insights.size());
        } catch (Exception e) {
            log.error("Error generating insights", e);
        }
        
        return insights;
    }

    private List<SpendingInsight> detectRecurringPayments() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get last 6 months of transactions
        LocalDateTime sixMonthsAgo = LocalDateTime.now().minusMonths(6);
        List<Transaction> transactions = transactionRepository
            .findByDateAfterOrderByDateDesc(sixMonthsAgo);

        // Group by account and envelope
        Map<Account, Map<Envelope, List<Transaction>>> groupedTransactions = transactions.stream()
            .collect(Collectors.groupingBy(
                Transaction::getAccount,
                Collectors.groupingBy(Transaction::getEnvelope)
            ));

        // Analyze each account's envelopes
        for (Map.Entry<Account, Map<Envelope, List<Transaction>>> accountEntry : 
             groupedTransactions.entrySet()) {
            
            Account account = accountEntry.getKey();
            
            for (Map.Entry<Envelope, List<Transaction>> envEntry : 
                 accountEntry.getValue().entrySet()) {
                
                Envelope envelope = envEntry.getKey();
                List<Transaction> envTransactions = envEntry.getValue();
                
                // Look for regular patterns in amounts and timing
                Map<BigDecimal, List<Transaction>> byAmount = envTransactions.stream()
                    .collect(Collectors.groupingBy(Transaction::getAmount));

                // Analyze each amount group for timing patterns
                for (Map.Entry<BigDecimal, List<Transaction>> amountGroup : 
                     byAmount.entrySet()) {
                    
                    if (amountGroup.getValue().size() >= 3) {
                        OptionalDouble avgDays = calculateAverageDaysBetween(
                            amountGroup.getValue()
                        );
                        
                        if (avgDays.isPresent()) {
                            double stdDev = calculateStdDev(
                                amountGroup.getValue(), 
                                avgDays.getAsDouble()
                            );
                            
                            if (stdDev < 5.0) {
                                insights.add(new SpendingInsight(
                                    SpendingInsightType.RECURRING_PAYMENT,
                                    String.format(
                                        "Recurring payment detected in %s using %s: $%.2f every %.1f days",
                                        envelope.getName(),
                                        account.getName(),
                                        amountGroup.getKey(),
                                        avgDays.getAsDouble()
                                    ),
                                    0.9
                                ));
                            }
                        }
                    }
                }
            }
        }

        return insights;
    }

    private List<SpendingInsight> detectUnusualSpending() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get historical spending patterns
        LocalDateTime threeMonthsAgo = LocalDateTime.now().minusMonths(3);
        List<Transaction> recentTransactions = transactionRepository
            .findByDateAfterOrderByDateDesc(threeMonthsAgo);

        // Group by account and envelope
        Map<Account, Map<Envelope, List<Transaction>>> groupedTransactions = recentTransactions.stream()
            .collect(Collectors.groupingBy(
                Transaction::getAccount,
                Collectors.groupingBy(Transaction::getEnvelope)
            ));

        // Analyze each account's envelopes
        for (Map.Entry<Account, Map<Envelope, List<Transaction>>> accountEntry : 
             groupedTransactions.entrySet()) {
            
            Account account = accountEntry.getKey();
            
            for (Map.Entry<Envelope, List<Transaction>> envEntry : 
                 accountEntry.getValue().entrySet()) {
                
                Envelope envelope = envEntry.getKey();
                List<Transaction> envTransactions = envEntry.getValue();
                
                // Calculate average and standard deviation of amounts
                double[] amounts = envTransactions.stream()
                    .mapToDouble(tx -> tx.getAmount().doubleValue())
                    .toArray();
                    
                DoubleSummaryStatistics stats = Arrays.stream(amounts)
                    .summaryStatistics();
                double mean = stats.getAverage();
                double stdDev = calculateStdDev(amounts, mean);
                
                // Look for amounts > 2 standard deviations from mean
                envTransactions.stream()
                    .filter(tx -> tx.getDate().isAfter(LocalDateTime.now().minusWeeks(2)))
                    .forEach(tx -> {
                        double zscore = (tx.getAmount().doubleValue() - mean) / stdDev;
                        if (zscore > 2.0) {
                            insights.add(new SpendingInsight(
                                SpendingInsightType.UNUSUAL_SPENDING,
                                String.format(
                                    "Unusual spending detected in %s using %s: $%.2f " +
                                    "(%.1fx higher than average)",
                                    envelope.getName(),
                                    account.getName(),
                                    tx.getAmount(),
                                    tx.getAmount().doubleValue() / mean
                                ),
                                0.8
                            ));
                        }
                    });
            }
        }

        return insights;
    }

    private List<SpendingInsight> predictUpcomingExpenses() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get historical transactions
        LocalDateTime sixMonthsAgo = LocalDateTime.now().minusMonths(6);
        List<Transaction> transactions = transactionRepository
            .findByDateAfterOrderByDateDesc(sixMonthsAgo);

        // Group by account and envelope
        Map<Account, Map<Envelope, List<Transaction>>> groupedTransactions = transactions.stream()
            .collect(Collectors.groupingBy(
                Transaction::getAccount,
                Collectors.groupingBy(Transaction::getEnvelope)
            ));

        // Analyze each account's envelopes
        for (Map.Entry<Account, Map<Envelope, List<Transaction>>> accountEntry : 
             groupedTransactions.entrySet()) {
            
            Account account = accountEntry.getKey();
            
            for (Map.Entry<Envelope, List<Transaction>> envEntry : 
                 accountEntry.getValue().entrySet()) {
                
                Envelope envelope = envEntry.getKey();
                List<Transaction> envTransactions = envEntry.getValue();
                
                if (envTransactions.size() >= 3) {
                    // Calculate monthly totals
                    Map<YearMonth, BigDecimal> monthlyTotals = envTransactions.stream()
                        .collect(Collectors.groupingBy(
                            tx -> YearMonth.from(tx.getDate()),
                            Collectors.reducing(
                                BigDecimal.ZERO,
                                Transaction::getAmount,
                                BigDecimal::add
                            )
                        ));

                    // Calculate trend
                    double[] totals = monthlyTotals.values().stream()
                        .mapToDouble(BigDecimal::doubleValue)
                        .toArray();
                        
                    double trend = calculateTrend(totals);
                    double currentAvg = Arrays.stream(totals).average().orElse(0.0);
                    double predictedNext = currentAvg * (1 + trend);

                    if (Math.abs(trend) > 0.1) {
                        insights.add(new SpendingInsight(
                            SpendingInsightType.PREDICTED_EXPENSE,
                            String.format(
                                "Predicted %s spending next month using %s: $%.2f " +
                                "(%.1f%% %s than average)",
                                envelope.getName(),
                                account.getName(),
                                predictedNext,
                                Math.abs(trend * 100),
                                trend > 0 ? "higher" : "lower"
                            ),
                            0.7
                        ));
                    }
                }
            }
        }

        return insights;
    }

    private List<SpendingInsight> generateBudgetSuggestions() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get last 6 months of transactions
        LocalDateTime sixMonthsAgo = LocalDateTime.now().minusMonths(6);
        List<Transaction> transactions = transactionRepository
            .findByDateAfterOrderByDateDesc(sixMonthsAgo);

        // Group by account and envelope
        Map<Account, Map<Envelope, List<Transaction>>> groupedTransactions = transactions.stream()
            .collect(Collectors.groupingBy(
                Transaction::getAccount,
                Collectors.groupingBy(Transaction::getEnvelope)
            ));

        // Analyze each account's envelopes
        for (Map.Entry<Account, Map<Envelope, List<Transaction>>> accountEntry : 
             groupedTransactions.entrySet()) {
            
            Account account = accountEntry.getKey();
            
            for (Map.Entry<Envelope, List<Transaction>> envEntry : 
                 accountEntry.getValue().entrySet()) {
                
                Envelope envelope = envEntry.getKey();
                List<Transaction> envTransactions = envEntry.getValue();
                
                // Calculate monthly statistics
                Map<YearMonth, BigDecimal> monthlyTotals = envTransactions.stream()
                    .collect(Collectors.groupingBy(
                        tx -> YearMonth.from(tx.getDate()),
                        Collectors.reducing(
                            BigDecimal.ZERO,
                            Transaction::getAmount,
                            BigDecimal::add
                        )
                    ));

                // Calculate average monthly spending
                double avgMonthlySpend = monthlyTotals.values().stream()
                    .mapToDouble(BigDecimal::doubleValue)
                    .average()
                    .orElse(0.0);

                // Compare with current allocation
                double currentAllocation = envelope.getAllocated().doubleValue();
                double spendRatio = avgMonthlySpend / currentAllocation;

                if (spendRatio > 0.95) {
                    insights.add(new SpendingInsight(
                        SpendingInsightType.BUDGET_SUGGESTION,
                        String.format(
                            "Consider increasing %s budget for %s by %.0f%%. " +
                            "Current allocation of $%.2f is frequently depleted.",
                            envelope.getName(),
                            account.getName(),
                            Math.min((spendRatio - 1) * 100 + 10, 30),
                            currentAllocation
                        ),
                        0.8
                    ));
                } else if (spendRatio < 0.7 && monthlyTotals.size() >= 3) {
                    insights.add(new SpendingInsight(
                        SpendingInsightType.BUDGET_SUGGESTION,
                        String.format(
                            "Consider decreasing %s budget for %s by %.0f%%. " +
                            "Average monthly spending ($%.2f) is well below " +
                            "allocation ($%.2f).",
                            envelope.getName(),
                            account.getName(),
                            Math.min((1 - spendRatio) * 100, 20),
                            avgMonthlySpend,
                            currentAllocation
                        ),
                        0.7
                    ));
                }

                // Check for seasonal patterns
                Map<Month, List<BigDecimal>> monthlySpending = monthlyTotals.entrySet()
                    .stream()
                    .collect(Collectors.groupingBy(
                        e -> e.getKey().getMonth(),
                        Collectors.mapping(
                            Map.Entry::getValue,
                            Collectors.toList()
                        )
                    ));

                monthlySpending.forEach((month, amounts) -> {
                    if (amounts.size() >= 2) {
                        double monthAvg = amounts.stream()
                            .mapToDouble(BigDecimal::doubleValue)
                            .average()
                            .getAsDouble();
                            
                        if (monthAvg > avgMonthlySpend * 1.3) {
                            insights.add(new SpendingInsight(
                                SpendingInsightType.SEASONAL_PATTERN,
                                String.format(
                                    "%s typically needs %.0f%% more budget in %s " +
                                    "for %s. Consider temporary allocation increase.",
                                    envelope.getName(),
                                    ((monthAvg / avgMonthlySpend) - 1) * 100,
                                    month.toString(),
                                    account.getName()
                                ),
                                0.75
                            ));
                        }
                    }
                });
            }
        }

        return insights;
    }

    private List<SpendingInsight> generateAccountSpecificInsights() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get all accounts
        List<Account> accounts = accountRepository.findAll();
        
        for (Account account : accounts) {
            // Get account transactions
            List<Transaction> accountTransactions = transactionRepository
                .findByDateAfterOrderByDateDesc(LocalDateTime.now().minusMonths(3))
                .stream()
                .filter(tx -> tx.getAccount().getId().equals(account.getId()))
                .collect(Collectors.toList());
                
            if (accountTransactions.isEmpty()) continue;
            
            // Add account type specific insights
            if (account.getType() == Account.AccountType.CREDIT_CARD) {
                // Check credit utilization
                BigDecimal balance = account.getBalance();
                // Assuming a standard credit limit, in practice this would come from the account
                BigDecimal estimatedLimit = BigDecimal.valueOf(5000.00);
                double utilizationRate = balance.doubleValue() / estimatedLimit.doubleValue();
                
                if (utilizationRate > 0.7) {
                    insights.add(new SpendingInsight(
                        SpendingInsightType.UNUSUAL_SPENDING,
                        String.format(
                            "High credit utilization (%.0f%%) detected on %s. Consider reducing usage or requesting a limit increase.",
                            utilizationRate * 100,
                            account.getName()
                        ),
                        0.9
                    ));
                }
            } else if (account.getType() == Account.AccountType.CHECKING) {
                // Check for low balance trends
                BigDecimal balance = account.getBalance();
                BigDecimal avgMonthlySpend = accountTransactions.stream()
                    .map(Transaction::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add)
                    .divide(BigDecimal.valueOf(3), 2, java.math.RoundingMode.HALF_UP);
                
                if (balance.compareTo(avgMonthlySpend) < 0) {
                    insights.add(new SpendingInsight(
                        SpendingInsightType.BUDGET_SUGGESTION,
                        String.format(
                            "Current balance ($%.2f) in %s is below average monthly spending ($%.2f). Consider maintaining higher balance.",
                            balance,
                            account.getName(),
                            avgMonthlySpend
                        ),
                        0.85
                    ));
                }
            }

            // Analyze transaction patterns
            Map<String, List<Transaction>> merchantPatterns = accountTransactions.stream()
                .collect(Collectors.groupingBy(Transaction::getDescription));
            
            // Look for frequent merchants and spending patterns
            merchantPatterns.forEach((merchant, transactions) -> {
                if (transactions.size() >= 3) {
                    OptionalDouble avgDays = calculateAverageDaysBetween(transactions);
                    if (avgDays.isPresent() && avgDays.getAsDouble() < 35) {
                        double avgAmount = transactions.stream()
                            .mapToDouble(tx -> tx.getAmount().doubleValue())
                            .average()
                            .orElse(0.0);
                            
                        insights.add(new SpendingInsight(
                            SpendingInsightType.RECURRING_PAYMENT,
                            String.format(
                                "Regular payments of $%.2f to %s detected on %s (every %.1f days)",
                                avgAmount,
                                merchant,
                                account.getName(),
                                avgDays.getAsDouble()
                            ),
                            0.85
                        ));
                    }
                }
            });
        }
        
        return insights;
    }

    private List<SpendingInsight> detectCrossAccountPatterns() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get recent transactions across all accounts
        LocalDateTime threeMonthsAgo = LocalDateTime.now().minusMonths(3);
        List<Transaction> recentTransactions = transactionRepository
            .findByDateAfterOrderByDateDesc(threeMonthsAgo);
            
        // Group by merchant across accounts
        Map<String, Map<Account, List<Transaction>>> merchantAccountPatterns = 
            recentTransactions.stream()
                .collect(Collectors.groupingBy(
                    Transaction::getDescription,
                    Collectors.groupingBy(Transaction::getAccount)
                ));
                
        // Look for merchants used across multiple accounts
        merchantAccountPatterns.forEach((merchant, accountTransactions) -> {
            if (accountTransactions.size() > 1) {
                // Calculate total spent per account
                Map<Account, BigDecimal> accountTotals = new HashMap<>();
                accountTransactions.forEach((account, transactions) -> {
                    BigDecimal total = transactions.stream()
                        .map(Transaction::getAmount)
                        .reduce(BigDecimal.ZERO, BigDecimal::add);
                    accountTotals.put(account, total);
                });
                
                // If significant spending across accounts, suggest consolidation
                if (accountTotals.size() > 1) {
                    String accountsList = accountTotals.entrySet().stream()
                        .map(e -> String.format("%s ($%.2f)", 
                            e.getKey().getName(), 
                            e.getValue()))
                        .collect(Collectors.joining(", "));
                        
                    insights.add(new SpendingInsight(
                        SpendingInsightType.REALLOCATION_SUGGESTION,
                        String.format(
                            "Multiple accounts used for %s: %s. Consider consolidating to one account for better tracking.",
                            merchant,
                            accountsList
                        ),
                        0.7
                    ));
                }
            }
        });
        
        return insights;
    }

    // Helper methods
    private OptionalDouble calculateAverageDaysBetween(List<Transaction> transactions) {
        if (transactions.size() < 2) {
            return OptionalDouble.empty();
        }

        List<Transaction> sorted = transactions.stream()
            .sorted(Comparator.comparing(Transaction::getDate))
            .collect(Collectors.toList());

        double totalDays = 0;
        int count = 0;

        for (int i = 1; i < sorted.size(); i++) {
            Duration duration = Duration.between(
                sorted.get(i-1).getDate(),
                sorted.get(i).getDate()
            );
            totalDays += duration.toDays();
            count++;
        }

        return count > 0 ? 
            OptionalDouble.of(totalDays / count) : 
            OptionalDouble.empty();
    }

    private double calculateStdDev(double[] values, double mean) {
        return Math.sqrt(
            Arrays.stream(values)
                .map(v -> Math.pow(v - mean, 2))
                .average()
                .orElse(0.0)
        );
    }

    private double calculateStdDev(List<Transaction> transactions, double avgDays) {
        if (transactions.size() < 2) {
            return Double.MAX_VALUE;
        }

        List<Transaction> sorted = transactions.stream()
            .sorted(Comparator.comparing(Transaction::getDate))
            .collect(Collectors.toList());

        double sumSquaredDiff = 0;
        int count = 0;

        for (int i = 1; i < sorted.size(); i++) {
            double days = Duration.between(
                sorted.get(i-1).getDate(),
                sorted.get(i).getDate()
            ).toDays();
            sumSquaredDiff += Math.pow(days - avgDays, 2);
            count++;
        }

        return count > 0 ? 
            Math.sqrt(sumSquaredDiff / count) : 
            Double.MAX_VALUE;
    }

    private double calculateTrend(double[] values) {
        if (values.length < 2) {
            return 0.0;
        }

        // Simple linear regression to calculate trend
        int n = values.length;
        double sumX = 0;
        double sumY = 0;
        double sumXY = 0;
        double sumXX = 0;

        for (int i = 0; i < n; i++) {
            sumX += i;
            sumY += values[i];
            sumXY += i * values[i];
            sumXX += i * i;
        }

        double slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        double meanY = sumY / n;

        // Return normalized trend (as percentage change)
        return slope / meanY;
    }
}===== ./src/main/java/org/emblow/envelopify/service/ml/AdvancedMLService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */

import org.springframework.stereotype.Service;
import org.springframework.scheduling.annotation.Scheduled;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.repository.TransactionRepository;
import org.emblow.envelopify.repository.EnvelopeRepository;
import org.emblow.envelopify.repository.AccountRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.*;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.math.BigDecimal;
import java.util.stream.Collectors;

@Service
public class AdvancedMLService {
    private static final Logger log = LoggerFactory.getLogger(AdvancedMLService.class);
    
    private final TransactionRepository transactionRepository;
    private final EnvelopeRepository envelopeRepository;
    private final AccountRepository accountRepository;
    private final TransactionClassifier classifier;
    
    public AdvancedMLService(
        TransactionRepository transactionRepository,
        EnvelopeRepository envelopeRepository,
        AccountRepository accountRepository,
        TransactionClassifier classifier
    ) {
        this.transactionRepository = transactionRepository;
        this.envelopeRepository = envelopeRepository;
        this.accountRepository = accountRepository;
        this.classifier = classifier;
    }
    
    @Scheduled(cron = "0 0 2 * * *") // Run at 2 AM daily
    public void retrainModels() {
        log.info("Starting daily model retraining");
        classifier.retrain();
    }
    
    public List<AccountAnalysis> analyzeAccounts() {
        List<AccountAnalysis> analyses = new ArrayList<>();
        
        try {
            // Get all accounts
            List<Account> accounts = accountRepository.findAll();
            
            for (Account account : accounts) {
                analyses.add(analyzeAccount(account));
            }
            
            // Add cross-account analysis if we have multiple accounts
            if (accounts.size() > 1) {
                addCrossAccountAnalysis(analyses);
            }
            
        } catch (Exception e) {
            log.error("Error analyzing accounts", e);
        }
        
        return analyses;
    }
    
    private AccountAnalysis analyzeAccount(Account account) {
        // Get recent transactions
        LocalDateTime sixMonthsAgo = LocalDateTime.now().minusMonths(6);
        List<Transaction> accountTransactions = transactionRepository
            .findByDateAfterOrderByDateDesc(sixMonthsAgo)
            .stream()
            .filter(tx -> tx.getAccount().getId().equals(account.getId()))
            .collect(Collectors.toList());
            
        // Calculate key metrics
        Map<YearMonth, BigDecimal> monthlyVolumes = accountTransactions.stream()
            .collect(Collectors.groupingBy(
                tx -> YearMonth.from(tx.getDate()),
                Collectors.reducing(
                    BigDecimal.ZERO,
                    Transaction::getAmount,
                    BigDecimal::add
                )
            ));
            
        // Monthly statistics
        DoubleSummaryStatistics volumeStats = monthlyVolumes.values().stream()
            .mapToDouble(BigDecimal::doubleValue)
            .summaryStatistics();
            
        // Merchant analysis
        Map<String, MerchantMetrics> merchantMetrics = analyzeMerchants(accountTransactions);
        
        // Envelope usage patterns
        Map<Envelope, EnvelopeMetrics> envelopeMetrics = analyzeEnvelopes(accountTransactions);
        
        // Anomaly detection
        List<AnomalyDetection> anomalies = detectAnomaliesForAccount(accountTransactions);
        
        // Weekly patterns
        Map<DayOfWeek, Double> dayOfWeekPatterns = analyzeDayOfWeekPatterns(accountTransactions);
        
        // Balance trends
        BalanceTrends balanceTrends = analyzeBalanceTrends(account, accountTransactions);
        
        return new AccountAnalysis(
            account,
            volumeStats.getAverage(),
            calculateTrend(new ArrayList<>(monthlyVolumes.values())),
            new ArrayList<>(merchantMetrics.entrySet().stream()
                .sorted((e1, e2) -> Double.compare(e2.getValue().totalSpent, e1.getValue().totalSpent))
                .limit(5)
                .map(Map.Entry::getKey)
                .toList()),
            anomalies,
            merchantMetrics,
            envelopeMetrics,
            dayOfWeekPatterns,
            balanceTrends
        );
    }
    
    private Map<String, MerchantMetrics> analyzeMerchants(List<Transaction> transactions) {
        Map<String, MerchantMetrics> metrics = new HashMap<>();
        
        // Group transactions by merchant
        Map<String, List<Transaction>> byMerchant = transactions.stream()
            .collect(Collectors.groupingBy(Transaction::getDescription));
            
        byMerchant.forEach((merchant, merchantTxs) -> {
            double totalSpent = merchantTxs.stream()
                .mapToDouble(tx -> tx.getAmount().doubleValue())
                .sum();
                
            double avgAmount = merchantTxs.stream()
                .mapToDouble(tx -> tx.getAmount().doubleValue())
                .average()
                .orElse(0.0);
                
            OptionalDouble avgDaysBetween = calculateAverageDaysBetween(merchantTxs);
            
            double frequency = (double) merchantTxs.size() / 
                ChronoUnit.MONTHS.between(
                    merchantTxs.get(merchantTxs.size() - 1).getDate(),
                    merchantTxs.get(0).getDate()
                );
                
            Map<Envelope, Integer> envelopeUsage = merchantTxs.stream()
                .collect(Collectors.groupingBy(
                    Transaction::getEnvelope,
                    Collectors.collectingAndThen(Collectors.counting(), Long::intValue)
                ));
                
            metrics.put(merchant, new MerchantMetrics(
                totalSpent,
                avgAmount,
                frequency,
                avgDaysBetween.orElse(0.0),
                envelopeUsage
            ));
        });
        
        return metrics;
    }
    
    private Map<Envelope, EnvelopeMetrics> analyzeEnvelopes(List<Transaction> transactions) {
        Map<Envelope, EnvelopeMetrics> metrics = new HashMap<>();
        
        // Group transactions by envelope
        Map<Envelope, List<Transaction>> byEnvelope = transactions.stream()
            .collect(Collectors.groupingBy(Transaction::getEnvelope));
            
        byEnvelope.forEach((envelope, envTxs) -> {
            double totalSpent = envTxs.stream()
                .mapToDouble(tx -> tx.getAmount().doubleValue())
                .sum();
                
            Map<YearMonth, Double> monthlySpending = envTxs.stream()
                .collect(Collectors.groupingBy(
                    tx -> YearMonth.from(tx.getDate()),
                    Collectors.summingDouble(tx -> tx.getAmount().doubleValue())
                ));
                
            double trend = calculateTrend(monthlySpending.values().stream()
                .mapToDouble(Double::doubleValue)
                .toArray());
                
            metrics.put(envelope, new EnvelopeMetrics(
                totalSpent,
                monthlySpending,
                trend,
                envelope.getBudgetUtilization()
            ));
        });
        
        return metrics;
    }
    
    private Map<DayOfWeek, Double> analyzeDayOfWeekPatterns(List<Transaction> transactions) {
        return transactions.stream()
            .collect(Collectors.groupingBy(
                tx -> tx.getDate().getDayOfWeek(),
                Collectors.averagingDouble(tx -> tx.getAmount().doubleValue())
            ));
    }
    
    private BalanceTrends analyzeBalanceTrends(Account account, List<Transaction> transactions) {
        if (transactions.isEmpty()) {
            return new BalanceTrends(0.0, 0.0, 0.0, Collections.emptyMap());
        }
        
        // Calculate daily balances
        TreeMap<LocalDate, Double> dailyBalances = new TreeMap<>();
        double runningBalance = account.getBalance().doubleValue();
        
        // Work backwards from current balance
        for (Transaction tx : transactions) {
            LocalDate date = tx.getDate().toLocalDate();
            runningBalance -= tx.getAmount().doubleValue();
            dailyBalances.merge(date, runningBalance, Double::sum);
        }
        
        // Calculate metrics
        DoubleSummaryStatistics stats = dailyBalances.values().stream()
            .mapToDouble(Double::doubleValue)
            .summaryStatistics();
            
        double volatility = Math.sqrt(dailyBalances.values().stream()
            .mapToDouble(balance -> Math.pow(balance - stats.getAverage(), 2))
            .average()
            .orElse(0.0));
            
        return new BalanceTrends(
            stats.getAverage(),
            volatility,
            calculateTrend(dailyBalances.values().stream()
                .mapToDouble(Double::doubleValue)
                .toArray()),
            dailyBalances
        );
    }
    
    private void addCrossAccountAnalysis(List<AccountAnalysis> analyses) {
        // Find common merchants across accounts
        Map<String, Set<Account>> merchantAccounts = new HashMap<>();
        
        for (AccountAnalysis analysis : analyses) {
            for (String merchant : analysis.getMerchantMetrics().keySet()) {
                merchantAccounts.computeIfAbsent(merchant, k -> new HashSet<>())
                    .add(analysis.getAccount());
            }
        }
        
        // Add cross-account insights to each analysis
        for (AccountAnalysis analysis : analyses) {
            List<String> sharedMerchants = merchantAccounts.entrySet().stream()
                .filter(e -> e.getValue().size() > 1 && 
                            e.getValue().contains(analysis.getAccount()))
                .map(Map.Entry::getKey)
                .toList();
                
            analysis.setCrossAccountMetrics(new CrossAccountMetrics(
                sharedMerchants,
                analyses.stream()
                    .filter(a -> !a.equals(analysis))
                    .collect(Collectors.toMap(
                        a -> a.getAccount(),
                        a -> calculateAccountSimilarity(analysis, a)
                    ))
            ));
        }
    }
    
    private double calculateAccountSimilarity(AccountAnalysis a1, AccountAnalysis a2) {
        Set<String> merchants1 = a1.getMerchantMetrics().keySet();
        Set<String> merchants2 = a2.getMerchantMetrics().keySet();
        
        // Jaccard similarity of merchant sets
        Set<String> intersection = new HashSet<>(merchants1);
        intersection.retainAll(merchants2);
        
        Set<String> union = new HashSet<>(merchants1);
        union.addAll(merchants2);
        
        return union.isEmpty() ? 0.0 : 
            (double) intersection.size() / union.size();
    }
    
    public List<AnomalyDetection> detectAnomaliesForAccount(List<Transaction> transactions) {
        List<AnomalyDetection> anomalies = new ArrayList<>();
        
        if (transactions.isEmpty()) return anomalies;
        
        // Calculate statistical measures
        DoubleSummaryStatistics stats = transactions.stream()
            .mapToDouble(tx -> tx.getAmount().doubleValue())
            .summaryStatistics();
            
        double mean = stats.getAverage();
        double stdDev = calculateStdDev(transactions, mean);
        
        // Check recent transactions for anomalies
        transactions.stream()
            .filter(tx -> tx.getDate().isAfter(LocalDateTime.now().minusWeeks(2)))
            .forEach(tx -> {
                double zscore = (tx.getAmount().doubleValue() - mean) / stdDev;
                if (Math.abs(zscore) > 2.5) {
                    anomalies.add(new AnomalyDetection(
                        tx,
                        AnomalyType.AMOUNT,
                        Math.abs(zscore),
                        String.format(
                            "Unusual transaction amount for %s: $%.2f",
                            tx.getAccount().getName(),
                            tx.getAmount()
                        )
                    ));
                }
            });
            
        // Check for unusual frequency
        Map<LocalDate, Long> dailyCounts = transactions.stream()
            .collect(Collectors.groupingBy(
                tx -> tx.getDate().toLocalDate(),
                Collectors.counting()
            ));
            
        DoubleSummaryStatistics freqStats = dailyCounts.values().stream()
            .mapToDouble(Long::doubleValue)
            .summaryStatistics();
            
        double freqMean = freqStats.getAverage();
        double freqStdDev = calculateStdDev(
            dailyCounts.values().stream()
                .mapToDouble(Long::doubleValue)
                .toArray(),
            freqMean
        );
        
        dailyCounts.forEach((date, count) -> {
            if (date.isAfter(LocalDate.now().minusWeeks(2))) {
                double zscore = (count - freqMean) / freqStdDev;
                if (zscore > 2.5) {
                    anomalies.add(new AnomalyDetection(
                        null,
                        AnomalyType.FREQUENCY,
                        zscore,
                        String.format(
                            "Unusual number of transactions (%d) on %s",
                            count,
                            date
                        )
                    ));
                }
            }
        });
        
        return anomalies;
    }
    
    // Helper classes for analysis results
    public record MerchantMetrics(
        double totalSpent,
        double averageAmount,
        double monthlyFrequency,
        double averageDaysBetween,
        Map<Envelope, Integer> envelopeUsage
    ) {}
    
    public record EnvelopeMetrics(
        double totalSpent,
        Map<YearMonth, Double> monthlySpending,
        double spendingTrend,
        double budgetUtilization
    ) {}
    
    public record BalanceTrends(
        double averageBalance,
        double balanceVolatility,
        double balanceTrend,
        Map<LocalDate, Double> dailyBalances
    ) {}
    
    public record CrossAccountMetrics(
        List<String> sharedMerchants,
        Map<Account, Double> accountSimilarities
    ) {}
    
    // Main analysis result class
    public static class AccountAnalysis {
        private final Account account;
        private final double averageMonthlyVolume;
        private final double volumeTrend;
        private final List<String> topMerchants;
        private final List<AnomalyDetection> anomalies;
        private final Map<String, MerchantMetrics> merchantMetrics;
        private final Map<Envelope, EnvelopeMetrics> envelopeMetrics;
        private final Map<DayOfWeek, Double> dayOfWeekPatterns;
        private final BalanceTrends balanceTrends;
        private CrossAccountMetrics crossAccountMetrics;

        public AccountAnalysis(
            Account account,
            double averageMonthlyVolume,
            double volumeTrend,
            List<String> topMerchants,
            List<AnomalyDetection> anomalies,
            Map<String, MerchantMetrics> merchantMetrics,
            Map<Envelope, EnvelopeMetrics> envelopeMetrics,
            Map<DayOfWeek, Double> dayOfWeekPatterns,
            BalanceTrends balanceTrends
        ) {
            this.account = account;
            this.averageMonthlyVolume = averageMonthlyVolume;
            this.volumeTrend = volumeTrend;
            this.topMerchants = topMerchants;
            this.anomalies = anomalies;
            this.merchantMetrics = merchantMetrics;
            this.envelopeMetrics = envelopeMetrics;
            this.dayOfWeekPatterns = dayOfWeekPatterns;
            this.balanceTrends = balanceTrends;
            this.crossAccountMetrics = null;
        }

        public void setCrossAccountMetrics(CrossAccountMetrics metrics) {
            this.crossAccountMetrics = metrics;
        }

        // Getters
        public Account getAccount() { return account; }
        public double getAverageMonthlyVolume() { return averageMonthlyVolume; }
        public double getVolumeTrend() { return volumeTrend; }
        public List<String> getTopMerchants() { return topMerchants; }
        public List<AnomalyDetection> getAnomalies() { return anomalies; }
        public Map<String, MerchantMetrics> getMerchantMetrics() { return merchantMetrics; }
        public Map<Envelope, EnvelopeMetrics> getEnvelopeMetrics() { return envelopeMetrics; }
        public Map<DayOfWeek, Double> getDayOfWeekPatterns() { return dayOfWeekPatterns; }
        public BalanceTrends getBalanceTrends() { return balanceTrends; }
        public CrossAccountMetrics getCrossAccountMetrics() { return crossAccountMetrics; }
    }

    public enum AnomalyType {
        AMOUNT,
        FREQUENCY,
        PATTERN
    }

    public record AnomalyDetection(
        Transaction transaction,
        AnomalyType type,
        double severity,
        String description
    ) {}

    // Helper methods
    private OptionalDouble calculateAverageDaysBetween(List<Transaction> transactions) {
        if (transactions.size() < 2) {
            return OptionalDouble.empty();
        }

        List<Transaction> sorted = transactions.stream()
            .sorted(Comparator.comparing(Transaction::getDate))
            .collect(Collectors.toList());

        double totalDays = 0;
        int count = 0;

        for (int i = 1; i < sorted.size(); i++) {
            Duration duration = Duration.between(
                sorted.get(i-1).getDate(),
                sorted.get(i).getDate()
            );
            totalDays += duration.toDays();
            count++;
        }

        return count > 0 ? 
            OptionalDouble.of(totalDays / count) : 
            OptionalDouble.empty();
    }

    private double calculateStdDev(List<Transaction> transactions, double mean) {
        return Math.sqrt(
            transactions.stream()
                .mapToDouble(tx -> Math.pow(tx.getAmount().doubleValue() - mean, 2))
                .average()
                .orElse(0.0)
        );
    }

    private double calculateStdDev(double[] values, double mean) {
        return Math.sqrt(
            Arrays.stream(values)
                .map(v -> Math.pow(v - mean, 2))
                .average()
                .orElse(0.0)
        );
    }

    private double calculateTrend(double[] values) {
        if (values.length < 2) {
            return 0.0;
        }

        // Simple linear regression
        int n = values.length;
        double sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;

        for (int i = 0; i < n; i++) {
            sumX += i;
            sumY += values[i];
            sumXY += i * values[i];
            sumXX += i * i;
        }

        double slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        double meanY = sumY / n;

        return slope / meanY; // Return normalized trend
    }

    private double calculateTrend(List<BigDecimal> values) {
        return calculateTrend(values.stream()
            .mapToDouble(BigDecimal::doubleValue)
            .toArray());
    }
}===== ./src/main/java/org/emblow/envelopify/service/CSVImportService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.repository.TransactionRepository;
import org.emblow.envelopify.repository.EnvelopeRepository;
import org.emblow.envelopify.repository.AccountRepository;
import org.emblow.envelopify.service.PatternService;

import java.io.BufferedReader;
import java.io.StringReader;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import org.emblow.envelopify.repository.AccountRepository;

@Service
public class CSVImportService {
    private final TransactionRepository transactionRepository;
    private final EnvelopeRepository envelopeRepository;
    private final AccountRepository accountRepository;
    private final PatternService patternService;
    private final TransactionService transactionService;

    public CSVImportService(
        TransactionRepository transactionRepository,
        EnvelopeRepository envelopeRepository,
        AccountRepository accountRepository,
        PatternService patternService,
        TransactionService transactionService
    ) {
        this.transactionRepository = transactionRepository;
        this.envelopeRepository = envelopeRepository;
        this.accountRepository = accountRepository;
        this.patternService = patternService;
        this.transactionService = transactionService;
    }

    @Transactional
    public ImportResult importTransactions(
        String csvContent,
        CSVMapping mapping,
        Long defaultEnvelopeId,
        Long accountId
    ) {
        ImportResult result = new ImportResult();
        
        Envelope defaultEnvelope = envelopeRepository.findById(defaultEnvelopeId)
            .orElseThrow(() -> new RuntimeException("Default envelope not found"));
            
        Account account = accountRepository.findById(accountId)
            .orElseThrow(() -> new RuntimeException("Account not found"));

        try (BufferedReader reader = new BufferedReader(new StringReader(csvContent))) {
            // Skip header row if specified
            if (mapping.hasHeader()) {
                reader.readLine();
            }

            String line;
            while ((line = reader.readLine()) != null) {
                try {
                    String[] fields = line.split(mapping.delimiter());
                    
                    // Parse fields using mapping
                    LocalDateTime date = parseDate(
                        fields[mapping.dateColumnIndex()],
                        mapping.dateFormat()
                    );
                    
                    String description = fields[mapping.descriptionColumnIndex()].trim();
                    
                    // Determine the transaction type based on the multiplier:
                    // if negative => INCOME, otherwise EXPENSE.
                    TransactionType txType = mapping.amountMultiplier() < 0 ? 
                        TransactionType.INCOME : TransactionType.EXPENSE;
                    // Parse the amount using the absolute multiplier.
                    BigDecimal amount = parseAmount(
                        fields[mapping.amountColumnIndex()],
                        Math.abs(mapping.amountMultiplier())
                    );

                    // Find best envelope match using pattern service.
                    Transaction temp = new Transaction();
                    temp.setDate(date);
                    temp.setDescription(description);
                    temp.setAmount(amount);
                    temp.setAccount(account);
                    
                    Map<Envelope, Double> suggestions = patternService.suggestEnvelopes(temp);
                    
                    // Use highest confidence suggestion or default envelope.
                    Envelope targetEnvelope = suggestions.entrySet().stream()
                        .max(Map.Entry.comparingByValue())
                        .filter(e -> e.getValue() > 0.7) // Minimum confidence threshold
                        .map(Map.Entry::getKey)
                        .orElse(defaultEnvelope);

                    // Instead of manually constructing and saving the transaction,
                    // call recordTransaction to let it update balances appropriately.
                    transactionService.recordTransaction(
                        targetEnvelope.getId(),
                        account.getId(),
                        date,
                        description,
                        amount,
                        txType
                    );
                    
                    result.incrementSuccessful();
                    
                } catch (Exception e) {
                    result.addError("Error processing line: " + line + " - " + e.getMessage());
                    result.incrementFailed();
                }
            }
        } catch (Exception e) {
            throw new RuntimeException("Error processing CSV file: " + e.getMessage(), e);
        }

        return result;
    }

    private LocalDateTime parseDate(String value, String format) {
        return LocalDateTime.parse(value, DateTimeFormatter.ofPattern(format));
    }

    private BigDecimal parseAmount(String value, double multiplier) {
        // Remove currency symbols and spaces.
        String cleaned = value.replaceAll("[^\\d.-]", "");
        return new BigDecimal(cleaned).multiply(BigDecimal.valueOf(multiplier));
    }

    // Record to define CSV column mapping.
    public record CSVMapping(
        boolean hasHeader,
        String delimiter,
        int dateColumnIndex,
        String dateFormat,
        int descriptionColumnIndex,
        int amountColumnIndex,
        double amountMultiplier
    ) {
        // Predefined mappings for common bank formats.
        public static CSVMapping CHASE = new CSVMapping(
            true, ",", 0, "MM/dd/yyyy", 2, 3, 1.0
        );
        
        public static CSVMapping BANK_OF_AMERICA = new CSVMapping(
            true, ",", 0, "MM/dd/yyyy", 1, 2, 1.0
        );
        
        // Add more presets as needed.
    }

    // Class to hold import results.
    public static class ImportResult {
        private int successful = 0;
        private int failed = 0;
        private List<String> errors = new ArrayList<>();

        public void incrementSuccessful() { successful++; }
        public void incrementFailed() { failed++; }
        public void addError(String error) { errors.add(error); }

        public int getSuccessful() { return successful; }
        public int getFailed() { return failed; }
        public List<String> getErrors() { return errors; }
    }
}
===== ./src/main/java/org/emblow/envelopify/service/CustomUserDetailsService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.User;
import org.emblow.envelopify.repository.UserRepository;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import java.util.Collections;

@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    private final UserRepository userRepository;
    
    public CustomUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found"));
            
        return new org.springframework.security.core.userdetails.User(
            user.getUsername(),
            user.getPasswordHash(),
            Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER"))
        );
    }
}===== ./src/main/java/org/emblow/envelopify/service/llm/ChatGPTService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.llm;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.PatternService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.IntentDetectionService;
import org.emblow.envelopify.service.ml.AdvancedMLService;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;

public class ChatGPTService extends AbstractLLMService {
    private final String openaiApiKey;
    private final String openaiChatEndpoint;
    private final WebClient webClient;

    public ChatGPTService(
            TransactionService transactionService,
            EnvelopeService envelopeService,
            SpendingInsightService insightService,
            PatternService patternService,
            AdvancedMLService advancedMLService,
            IntentDetectionService intentDetectionService,
            AccountService accountService,
            String openaiApiKey,
            String openaiChatEndpoint) {
        super(transactionService, envelopeService, insightService, patternService,
              advancedMLService, intentDetectionService, accountService);
        this.openaiApiKey = openaiApiKey;
        this.openaiChatEndpoint = openaiChatEndpoint;
        this.webClient = WebClient.builder()
            .baseUrl(openaiChatEndpoint)
            .defaultHeader(HttpHeaders.AUTHORIZATION, "Bearer " + openaiApiKey)
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }

    @Override
    public String processUserQuery(String userQuery) {
        return super.processUserQuery(userQuery); // Delegate to AbstractLLMService
    }

    @Override
    protected String callLLM(String prompt) {
        try {
            ObjectNode requestBody = objectMapper.createObjectNode();
            requestBody.put("model", "gpt-3.5-turbo");
            requestBody.put("temperature", 0.0);
            requestBody.put("stream", false);
            requestBody.put("top_p", 1.0);
            requestBody.put("frequency_penalty", 0.0);
            requestBody.put("presence_penalty", 0.0);

            ArrayNode messages = objectMapper.createArrayNode();
            messages.add(createMessage("system", "You are a financial analysis assistant with direct access to the user's financial data."));
            messages.add(createMessage("user", prompt));
            requestBody.set("messages", messages);

            String responseBody = webClient.post()
                .bodyValue(requestBody)
                .retrieve()
                .bodyToMono(String.class)
                .block();

            JsonNode root = objectMapper.readTree(responseBody);
            if (root.has("choices") && root.get("choices").isArray() && root.get("choices").size() > 0) {
                return root.get("choices").get(0).get("message").get("content").asText();
            }
            return "No response received from ChatGPT.";
        } catch (Exception e) {
            throw new RuntimeException("Error during ChatGPT inference: " + e.getMessage(), e);
        }
    }

    @Override
    protected Flux<String> doStreamUserQuery(String userQuery) {
        String context = buildFinancialContext();
        String fullPrompt = buildPrompt(userQuery, context);

        ObjectNode requestBody = objectMapper.createObjectNode();
        requestBody.put("model", "gpt-3.5-turbo");
        requestBody.put("temperature", 0.0);
        requestBody.put("stream", false);
        requestBody.put("top_p", 1.0);
        requestBody.put("frequency_penalty", 0.0);
        requestBody.put("presence_penalty", 0.0);

        ArrayNode messages = objectMapper.createArrayNode();
        messages.add(createMessage("system", "You are a financial analysis assistant with direct access to the user's financial data."));
        messages.add(createMessage("user", fullPrompt));
        requestBody.set("messages", messages);

        return webClient.post()
            .bodyValue(requestBody)
            .retrieve()
            .bodyToFlux(String.class)
            .filter(chunk -> chunk.startsWith("data: ") && !chunk.contains("[DONE]"))
            .map(chunk -> {
                try {
                    String json = chunk.substring(6).trim();
                    JsonNode node = objectMapper.readTree(json);
                    if (node.has("choices") && node.get("choices").size() > 0) {
                        JsonNode delta = node.get("choices").get(0).get("delta");
                        return delta.has("content") ? delta.get("content").asText() : "";
                    }
                    return "";
                } catch (Exception e) {
                    throw new RuntimeException("Error parsing ChatGPT stream chunk: " + e.getMessage(), e);
                }
            })
            .filter(chunk -> !chunk.isEmpty());
    }

    private ObjectNode createMessage(String role, String content) {
        ObjectNode msg = objectMapper.createObjectNode();
        msg.put("role", role);
        msg.put("content", content);
        return msg;
    }

    @Override
    protected boolean supportsStreaming() {
        return true;
    }
}===== ./src/main/java/org/emblow/envelopify/service/llm/AbstractLLMService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.llm;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.PatternService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.IntentDetectionService;
import org.emblow.envelopify.service.ml.AdvancedMLService;
import org.emblow.envelopify.service.ml.SpendingInsight;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.springframework.web.client.RestTemplate;
import reactor.core.publisher.Flux;
import org.emblow.envelopify.domain.TransactionType;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.service.ml.SpendingInsightType;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public abstract class AbstractLLMService implements LLMService {

    // Common dependencies
    protected final TransactionService transactionService;
    protected final EnvelopeService envelopeService;
    protected final SpendingInsightService insightService;
    protected final PatternService patternService;
    protected final AdvancedMLService advancedMLService;
    protected final IntentDetectionService intentDetectionService;
    protected final AccountService accountService;
    
    // Common utilities
    protected final RestTemplate restTemplate;
    protected final ObjectMapper objectMapper;

    protected AbstractLLMService(
            TransactionService transactionService,
            EnvelopeService envelopeService,
            SpendingInsightService insightService,
            PatternService patternService,
            AdvancedMLService advancedMLService,
            IntentDetectionService intentDetectionService,
            AccountService accountService
    ) {
        this.transactionService = transactionService;
        this.envelopeService = envelopeService;
        this.insightService = insightService;
        this.patternService = patternService;
        this.advancedMLService = advancedMLService;
        this.intentDetectionService = intentDetectionService;
        this.accountService = accountService;
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
    }

    @Override
    public String processUserQuery(String userQuery) {
        String context = buildFinancialContext();
        String prompt = buildPrompt(userQuery, context);
        String rawResponse = callLLM(prompt);
        return processFunctionCalls(rawResponse);
    }
/************* getting issues with streaming processing function calls
    @Override
    public Flux<String> streamUserQuery(String userQuery) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (supportsStreaming()) {
            return doStreamUserQuery(userQuery)
                    .contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication));
        }
        return Flux.just(processUserQuery(userQuery))
                .contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication));
    }
***********/
    @Override
    public Flux<String> streamUserQuery(String userQuery) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        // Just return the complete response as a single element flux
        return Flux.just(processUserQuery(userQuery))
                .contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication));
    }
    protected abstract boolean supportsStreaming();

    protected Flux<String> doStreamUserQuery(String userQuery) {
        throw new UnsupportedOperationException("Streaming not supported by this implementation");
    }

    protected String buildFinancialContext() {
        Map<String, Object> realTimeData = getRealTimeFinancialData();
        StringBuilder context = new StringBuilder();

        // Add real-time account balances
        context.append("Current Account Balances:\n");
        ((List<Map<String, Object>>)realTimeData.get("accounts"))
            .forEach(acc -> context.append(String.format("- %s (%s): $%.2f\n",
                acc.get("name"),
                acc.get("type"),
                acc.get("balance"))));

        // Add real-time envelope statuses
        context.append("\nEnvelope Statuses:\n");
        ((List<Map<String, Object>>)realTimeData.get("envelopes"))
            .forEach(env -> context.append(String.format("- %s: Available $%.2f, Spent $%.2f, Allocated $%.2f\n",
                env.get("name"),
                env.get("available"),
                env.get("spent"),
                env.get("allocated"))));
        
        // Recent transactions
        LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
        List<Transaction> recentTransactions = transactionService.getRecentTransactions(
                oneMonthAgo,
                LocalDateTime.now()
        );
        
        context.append("\nRecent Transactions:\n");
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");
        for (Transaction tx : recentTransactions.stream().limit(10).collect(Collectors.toList())) {
            context.append(String.format("- %s: $%.2f in %s (%s) from %s\n",
                    tx.getDate().format(formatter),
                    tx.getAmount(),
                    tx.getEnvelope().getName(),
                    tx.getDescription(),
                    tx.getAccount().getName()));
        }

        // Merge regular insights with advanced ML insights
        List<SpendingInsight> regularInsights = insightService.generateInsights();
        List<SpendingInsight> advancedInsights = getAdvancedMLInsights();
        List<SpendingInsight> allInsights = new ArrayList<>();
        allInsights.addAll(regularInsights);
        allInsights.addAll(advancedInsights);
        
        context.append("\nFinancial Insights:\n");
        for (SpendingInsight insight : allInsights) {
            context.append("- ").append(insight.getMessage()).append("\n");
        }

        // Overall financial status
        BigDecimal totalBudget = envelopeService.getAllEnvelopes().stream()
                .map(Envelope::getMonthlyBudget)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
                
        BigDecimal totalAvailable = envelopeService.getAllEnvelopes().stream()
                .map(Envelope::getAvailable)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
                
        context.append(String.format("\nOverall Status:\n- Total Budget: $%.2f\n- Total Available: $%.2f\n",
                totalBudget, totalAvailable));

        context.append("\nSpending By Category (Last 30 Days):\n");
        Map<String, BigDecimal> categorySpending = 
            (Map<String, BigDecimal>) realTimeData.get("categorySpending");
        categorySpending.forEach((category, amount) ->
            context.append(String.format("- %s: $%.2f\n", category, amount)));
        
        return context.toString();
    }

    protected String buildPrompt(String userQuery, String context) {
        return String.format("""
            Role: You are a financial analysis assistant specializing in personal finance and budgeting.
            
            Available Financial Data:
            %s
            
            Available Functions:
            - get_envelope_balance(envelope_name): Returns the current balance of the specified envelope.
            - generate_spending_chart(start_date, end_date, chart_type): Generates a chart of spending (e.g., 'pie', 'bar').
            - generate_transaction_table(start_date, end_date, limit): Generates a table of recent transactions.
            - get_total_spent(envelope_name, start_date, end_date): Returns total spending in an envelope over a period.
            
            User Question: %s
            
            Instructions:
            1. Analyze the financial data thoroughly.
            2. Use function calls for precise data retrieval or visualization (e.g., charts, tables).
            3. Return response in this JSON format:
            {
              "text": "Your analysis in markdown format",
              "charts": [{"function": "function_name", "params": {"param1": "value1", ...}} or chart_data],
              "tables": [{"function": "function_name", "params": {"param1": "value1", ...}} or table_data]
            }
            """, context, userQuery);
    }

    protected String processFunctionCalls(String rawResponse) {
        try {
            Map<String, Object> response = objectMapper.readValue(rawResponse, Map.class);
            List<Map<String, Object>> charts = (List<Map<String, Object>>) response.getOrDefault("charts", new ArrayList<>());
            List<Map<String, Object>> tables = (List<Map<String, Object>>) response.getOrDefault("tables", new ArrayList<>());

            // Process charts
            for (Map<String, Object> chart : charts) {
                if (chart.containsKey("function")) {
                    String functionName = (String) chart.get("function");
                    Map<String, Object> params = (Map<String, Object>) chart.get("params");
                    Map<String, Object> chartData = executeFunction(functionName, params);
                    chart.clear();
                    chart.putAll(chartData);
                }
            }

            // Process tables
            for (Map<String, Object> table : tables) {
                if (table.containsKey("function")) {
                    String functionName = (String) table.get("function");
                    Map<String, Object> params = (Map<String, Object>) table.get("params");
                    Map<String, Object> tableData = executeFunction(functionName, params);
                    table.clear();
                    table.putAll(tableData);
                }
            }

            return objectMapper.writeValueAsString(response);
        } catch (Exception e) {
            return "{\"text\": \"Error processing response: " + e.getMessage() + "\", \"charts\": [], \"tables\": []}";
        }
    }

    protected Map<String, Object> executeFunction(String functionName, Map<String, Object> params) {
        switch (functionName) {
            case "generate_spending_chart": {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");
                LocalDate startDate = LocalDate.parse((String) params.get("start_date"), formatter);
                LocalDate endDate = LocalDate.parse((String) params.get("end_date"), formatter);
                LocalDateTime start = startDate.atStartOfDay();
                LocalDateTime end = endDate.atTime(23, 59, 59);
                String chartType = (String) params.get("chart_type");
                return buildSpendingChart(start, end, chartType);
            }
            case "generate_transaction_table": {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");
                LocalDate startDate = LocalDate.parse((String) params.get("start_date"), formatter);
                LocalDate endDate = LocalDate.parse((String) params.get("end_date"), formatter);
                LocalDateTime start = startDate.atStartOfDay();
                LocalDateTime end = endDate.atTime(23, 59, 59);
                int limit = params.containsKey("limit") ? ((Number) params.get("limit")).intValue() : 10;
                return buildTransactionTable(start, end, limit);
            }
            case "get_envelope_balance": {
                String envelopeName = (String) params.get("envelope_name");
                return Map.of("text", "$" + calculateAvailableInEnvelope(envelopeName).toString());
            }
            case "get_total_spent": {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");
                LocalDate startDate = LocalDate.parse((String) params.get("start_date"), formatter);
                LocalDate endDate = LocalDate.parse((String) params.get("end_date"), formatter);
                LocalDateTime start = startDate.atStartOfDay();
                LocalDateTime end = endDate.atTime(23, 59, 59);
                String envelopeName = (String) params.get("envelope_name");
                BigDecimal totalSpent = calculateTotalSpent(envelopeName, start, end);
                return Map.of("text", String.format("Total spent in %s from %s to %s: $%s",
                    envelopeName, params.get("start_date"), params.get("end_date"), totalSpent.toString()));
            }
            default:
                throw new IllegalArgumentException("Unknown function: " + functionName);
        }
    }

    protected Map<String, Object> buildSpendingChart(LocalDateTime start, LocalDateTime end, String chartType) {
        Map<String, BigDecimal> spending = getSpendingByCategory(start, end);
        List<String> labels = new ArrayList<>(spending.keySet());
        List<BigDecimal> data = new ArrayList<>(spending.values());

        Map<String, Object> chartData = new HashMap<>();
        chartData.put("type", chartType);

        Map<String, Object> dataset = new HashMap<>();
        dataset.put("label", "Spending");
        dataset.put("data", data);
        dataset.put("backgroundColor", "rgba(75, 192, 192, 0.2)");
        dataset.put("borderColor", "rgba(75, 192, 192, 1)");
        dataset.put("borderWidth", 1);

        Map<String, Object> chartDataset = new HashMap<>();
        chartDataset.put("labels", labels);
        chartDataset.put("datasets", List.of(dataset));

        chartData.put("data", chartDataset);
        chartData.put("options", Map.of("scales", Map.of("y", Map.of("beginAtZero", true))));

        return chartData;
    }

    protected Map<String, Object> buildTransactionTable(LocalDateTime start, LocalDateTime end, int limit) {
        List<Transaction> transactions = transactionService.getRecentTransactions(start, end)
            .stream()
            .limit(limit)
            .collect(Collectors.toList());

        List<String> headers = List.of("Date", "Amount", "Envelope", "Description", "Account");

        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");
        List<List<String>> rows = transactions.stream()
            .map(tx -> List.of(
                tx.getDate().format(dateFormatter),
                "$" + tx.getAmount().toString(),
                tx.getEnvelope().getName(),
                tx.getDescription(),
                tx.getAccount().getName()
            ))
            .collect(Collectors.toList());

        return Map.of(
            "headers", headers,
            "rows", rows
        );
    }

    protected BigDecimal calculateAvailableInEnvelope(String envelopeName) {
        return envelopeService.getAllEnvelopes().stream()
            .filter(env -> env.getName().equalsIgnoreCase(envelopeName))
            .findFirst()
            .map(Envelope::getAvailable)
            .orElse(BigDecimal.ZERO);
    }

    protected BigDecimal calculateTotalSpent(String envelopeName, LocalDateTime start, LocalDateTime end) {
        Envelope envelope = envelopeService.getAllEnvelopes().stream()
            .filter(env -> env.getName().equalsIgnoreCase(envelopeName))
            .findFirst()
            .orElse(null);

        if (envelope == null) {
            return BigDecimal.ZERO;
        }

        return transactionService.getRecentTransactions(start, end).stream()
            .filter(tx -> tx.getEnvelope().getId().equals(envelope.getId()))
            .filter(tx -> tx.getType() == TransactionType.EXPENSE)
            .map(Transaction::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    protected Map<String, BigDecimal> getSpendingByCategory(LocalDateTime start, LocalDateTime end) {
        return transactionService.getRecentTransactions(start, end)
            .stream()
            .filter(tx -> tx.getType() == TransactionType.EXPENSE)
            .collect(Collectors.groupingBy(
                tx -> tx.getEnvelope().getName(),
                Collectors.mapping(
                    Transaction::getAmount,
                    Collectors.reducing(BigDecimal.ZERO, BigDecimal::add)
                )
            ));
    }

    protected List<SpendingInsight> getAdvancedMLInsights() {
        List<AdvancedMLService.AccountAnalysis> analyses = advancedMLService.analyzeAccounts();
        List<SpendingInsight> mlInsights = new ArrayList<>();
        
        for (AdvancedMLService.AccountAnalysis analysis : analyses) {
            for (AdvancedMLService.AnomalyDetection anomaly : analysis.getAnomalies()) {
                if (anomaly.type() == AdvancedMLService.AnomalyType.AMOUNT) {
                    mlInsights.add(new SpendingInsight(
                            SpendingInsightType.UNUSUAL_SPENDING,
                            anomaly.description(),
                            anomaly.severity()
                    ));
                } else if (anomaly.type() == AdvancedMLService.AnomalyType.FREQUENCY) {
                    mlInsights.add(new SpendingInsight(
                            SpendingInsightType.RECURRING_PAYMENT,
                            anomaly.description(),
                            anomaly.severity()
                    ));
                }
            }

            analysis.getMerchantMetrics().forEach((merchant, metrics) -> {
                if (metrics.monthlyFrequency() >= 1.0) {
                    mlInsights.add(new SpendingInsight(
                            SpendingInsightType.RECURRING_PAYMENT,
                            String.format("Recurring payment detected at %s (monthly frequency: %.1f)",
                                merchant, metrics.monthlyFrequency()),
                            Math.min(1.0, metrics.monthlyFrequency() / 5.0)
                    ));
                }
            });

            analysis.getEnvelopeMetrics().forEach((envelope, envMetrics) -> {
                if (envMetrics.budgetUtilization() > 0.9) {
                    mlInsights.add(new SpendingInsight(
                            SpendingInsightType.BUDGET_SUGGESTION,
                            String.format("Envelope %s is at %.0f%% of budget. Consider adjustment.",
                                    envelope.getName(),
                                    envMetrics.budgetUtilization() * 100),
                            envMetrics.budgetUtilization()
                    ));
                }
            });

            if (analysis.getVolumeTrend() > 0.2) {
                mlInsights.add(new SpendingInsight(
                        SpendingInsightType.PREDICTED_EXPENSE,
                        String.format("Spending trending upward for %s account. Review budget recommended.",
                                analysis.getAccount().getName()),
                        0.8
                ));
            } else if (analysis.getVolumeTrend() < -0.2) {
                mlInsights.add(new SpendingInsight(
                        SpendingInsightType.SEASONAL_PATTERN,
                        String.format("Seasonal spending decrease detected in %s account.",
                                analysis.getAccount().getName()),
                        0.7
                ));
            }
        }
        return mlInsights;
    }
    
    protected Map<String, Object> getRealTimeFinancialData() {
        Map<String, Object> data = new HashMap<>();

        List<Envelope> envelopes = envelopeService.getAllEnvelopes();
        data.put("envelopes", envelopes.stream()
            .map(env -> Map.of(
                "name", env.getName(),
                "available", env.getAvailable(),
                "allocated", env.getAllocated(),
                "spent", env.getSpent(),
                "monthlyBudget", env.getMonthlyBudget() != null ? env.getMonthlyBudget() : BigDecimal.ZERO
            ))
            .collect(Collectors.toList()));

        List<Account> accounts = accountService.getAllAccounts();
        data.put("accounts", accounts.stream()
            .map(acc -> Map.of(
                "name", acc.getName(),
                "type", acc.getType().getDisplayName(),
                "balance", acc.getBalance(),
                "institution", acc.getInstitution() != null ? acc.getInstitution() : "N/A"
            ))
            .collect(Collectors.toList()));

        LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
        Map<String, BigDecimal> categorySpending = getSpendingByCategory(oneMonthAgo, LocalDateTime.now());
        data.put("categorySpending", categorySpending);

        List<Transaction> recentTransactions = transactionService.getRecentTransactions(
            oneMonthAgo, LocalDateTime.now()
        );
        data.put("recentTransactions", recentTransactions.stream()
            .limit(10)
            .map(tx -> Map.of(
                "date", tx.getDate().format(DateTimeFormatter.ofPattern("MM/dd/yyyy")),
                "amount", tx.getAmount(),
                "envelope", tx.getEnvelope().getName(),
                "description", tx.getDescription(),
                "account", tx.getAccount().getName(),
                "type", tx.getType().toString()
            ))
            .collect(Collectors.toList()));

        BigDecimal totalAvailable = envelopes.stream()
            .map(Envelope::getAvailable)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        BigDecimal totalBalance = accounts.stream()
            .map(Account::getBalance)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        data.put("totalAvailable", totalAvailable);
        data.put("totalBalance", totalBalance);

        return data;
    }

    protected abstract String callLLM(String prompt);
}===== ./src/main/java/org/emblow/envelopify/service/llm/LLMService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.llm;

import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;

/**
 *
 * @author Nicholas J Emblow
 */
@Service
public interface LLMService {

    /**
     * Processes the user query by building financial context, assembling a prompt, and then generating
     * a response using the JLama inference engine.
     * @param userQuery
     * @return
     */
    String processUserQuery(String userQuery);
        Flux<String> streamUserQuery(String userQuery);
}
===== ./src/main/java/org/emblow/envelopify/service/llm/GroqService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.llm;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.PatternService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.IntentDetectionService;
import org.emblow.envelopify.service.ml.AdvancedMLService;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;

public class GroqService extends AbstractLLMService {
    private final String groqApiKey;
    private final String groqBaseUrl;
    private final String groqModel;
    private final WebClient webClient;

    public GroqService(
            TransactionService transactionService,
            EnvelopeService envelopeService,
            SpendingInsightService insightService,
            PatternService patternService,
            AdvancedMLService advancedMLService,
            IntentDetectionService intentDetectionService,
            AccountService accountService,
            String groqApiKey,
            String groqBaseUrl,
            String groqModel) {
        super(transactionService, envelopeService, insightService,
              patternService, advancedMLService, intentDetectionService,
              accountService);
        this.groqApiKey = groqApiKey;
        this.groqBaseUrl = groqBaseUrl;
        this.groqModel = groqModel;
        this.webClient = WebClient.builder()
            .baseUrl(groqBaseUrl)
            .defaultHeader(HttpHeaders.AUTHORIZATION, "Bearer " + groqApiKey)
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }

    @Override
    public String processUserQuery(String userQuery) {
        return super.processUserQuery(userQuery); // Delegate to AbstractLLMService
    }

    @Override
    protected String callLLM(String prompt) {
        try {
            ObjectNode requestBody = objectMapper.createObjectNode();
            requestBody.put("model", groqModel);
            requestBody.put("temperature", 0.0);
            requestBody.put("stream", false);
            requestBody.put("top_p", 1.0);
            requestBody.put("frequency_penalty", 0.0);
            requestBody.put("presence_penalty", 0.0);

            ArrayNode messages = objectMapper.createArrayNode();
            messages.add(createMessage("system", "You are a financial analysis assistant with direct access to the user's financial data."));
            messages.add(createMessage("user", prompt));
            requestBody.set("messages", messages);

            String responseBody = webClient.post()
                .uri("/openai/v1/chat/completions")
                .bodyValue(requestBody)
                .retrieve()
                .onStatus(status -> status.value() != 200,
                    response -> response.bodyToMono(String.class)
                        .map(body -> new RuntimeException("Groq API error: " + body)))
                .bodyToMono(String.class)
                .block();

            JsonNode root = objectMapper.readTree(responseBody);
            if (root.has("choices") && root.get("choices").isArray() && root.get("choices").size() > 0) {
                return root.get("choices").get(0).get("message").get("content").asText();
            }
            return "No response received from Groq.";
        } catch (Exception e) {
            throw new RuntimeException("Error during Groq inference: " + e.getMessage(), e);
        }
    }

    @Override
    protected Flux<String> doStreamUserQuery(String userQuery) {
        String intent = intentDetectionService.detectIntent(userQuery);
        String context = buildFinancialContext();
        String fullPrompt = buildPrompt(userQuery, context);

        ObjectNode requestBody = objectMapper.createObjectNode();
        requestBody.put("model", groqModel);
        requestBody.put("temperature", 0.0);
        requestBody.put("stream", false);
        requestBody.put("top_p", 1.0);
        requestBody.put("frequency_penalty", 0.0);
        requestBody.put("presence_penalty", 0.0);

        ArrayNode messages = objectMapper.createArrayNode();
        messages.add(createMessage("system", "You are a financial analysis assistant with direct access to the user's financial data."));
        messages.add(createMessage("user", fullPrompt));
        requestBody.set("messages", messages);

        return webClient.post()
            .uri("/openai/v1/chat/completions")
            .bodyValue(requestBody)
            .retrieve()
            .bodyToFlux(String.class)
            .map(chunk -> {
                try {
                    if (chunk.trim().equals("DONE")) {
                        return "";
                    }

                    JsonNode node = objectMapper.readTree(chunk);
                    if (node.has("choices") && node.get("choices").size() > 0) {
                        JsonNode delta = node.get("choices").get(0).get("delta");
                        if (delta.has("content")) {
                            return delta.get("content").asText();
                        }
                    }
                    return "";
                } catch (JsonProcessingException e) {
                    System.err.println("Failed to parse chunk: " + chunk);
                    return "";
                }
            })
            .filter(chunk -> !chunk.isEmpty())
            .onErrorResume(e -> {
                System.err.println("Stream error: " + e.getMessage());
                return Flux.empty();
            });
    }

    private ObjectNode createMessage(String role, String content) {
        ObjectNode msg = objectMapper.createObjectNode();
        msg.put("role", role);
        msg.put("content", content);
        return msg;
    }

    @Override
    protected boolean supportsStreaming() {
        return true;
    }
}===== ./src/main/java/org/emblow/envelopify/service/llm/OllamaService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.llm;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.PatternService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.IntentDetectionService;
import org.emblow.envelopify.service.ml.AdvancedMLService;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;

public class OllamaService extends AbstractLLMService {
    private final String ollamaUrl;
    private final String ollamaModel;
    private final WebClient webClient;

    public OllamaService(
            TransactionService transactionService,
            EnvelopeService envelopeService,
            SpendingInsightService insightService,
            PatternService patternService,
            AdvancedMLService advancedMLService,
            IntentDetectionService intentDetectionService,
            AccountService accountService,
            String ollamaUrl,
            String ollamaModel) {
        super(transactionService, envelopeService, insightService, patternService,
              advancedMLService, intentDetectionService, accountService);
        this.ollamaUrl = ollamaUrl;
        this.ollamaModel = ollamaModel;
        this.webClient = WebClient.builder()
            .baseUrl(ollamaUrl)
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }

    @Override
    public String processUserQuery(String userQuery) {
        // Delegate to AbstractLLMService, which handles context, prompt, and function calls
        return super.processUserQuery(userQuery);
    }

    @Override
    protected String callLLM(String prompt) {
        try {
            ObjectNode requestBody = objectMapper.createObjectNode();
            requestBody.put("model", ollamaModel);
            requestBody.put("stream", false);
            requestBody.put("temperature", 0.0);
            requestBody.put("top_p", 1.0);
            requestBody.put("frequency_penalty", 0.0);
            requestBody.put("repeat_penalty", 1.0);
            requestBody.put("mirostat", 0);

            ArrayNode messages = objectMapper.createArrayNode();
            messages.add(createMessage("system", "You are a financial analysis assistant with direct access to the user's financial data."));
            messages.add(createMessage("user", prompt));
            requestBody.set("messages", messages);

            String responseBody = webClient.post()
                .uri("/api/chat")
                .bodyValue(requestBody)
                .retrieve()
                .bodyToMono(String.class)
                .block();

            JsonNode root = objectMapper.readTree(responseBody);
            if (root.has("message") && root.get("message").has("content")) {
                return root.get("message").get("content").asText();
            }
            return "No response received from Ollama.";
        } catch (Exception e) {
            throw new RuntimeException("Error during Ollama inference: " + e.getMessage(), e);
        }
    }

    @Override
    protected Flux<String> doStreamUserQuery(String userQuery) {
        String context = buildFinancialContext();
        String fullPrompt = buildPrompt(userQuery, context);

        ObjectNode requestBody = objectMapper.createObjectNode();
        requestBody.put("model", ollamaModel);
        requestBody.put("stream", false);
        requestBody.put("temperature", 0.0);
        requestBody.put("top_p", 1.0);
        requestBody.put("frequency_penalty", 0.0);
        requestBody.put("repeat_penalty", 1.0);
        requestBody.put("mirostat", 0);

        ArrayNode messages = objectMapper.createArrayNode();
        messages.add(createMessage("system", "You are a financial analysis assistant with direct access to the user's financial data."));
        messages.add(createMessage("user", fullPrompt));
        requestBody.set("messages", messages);

        return webClient.post()
            .uri("/api/chat")
            .bodyValue(requestBody)
            .retrieve()
            .bodyToFlux(String.class)
            .map(chunk -> {
                try {
                    JsonNode node = objectMapper.readTree(chunk);
                    if (node.has("message") && node.get("message").has("content")) {
                        return node.get("message").get("content").asText();
                    }
                    return "";
                } catch (Exception e) {
                    throw new RuntimeException("Error parsing Ollama stream chunk: " + e.getMessage(), e);
                }
            })
            .filter(chunk -> !chunk.isEmpty());
    }

    private ObjectNode createMessage(String role, String content) {
        ObjectNode msg = objectMapper.createObjectNode();
        msg.put("role", role);
        msg.put("content", content);
        return msg;
    }

    @Override
    protected boolean supportsStreaming() {
        return true;
    }
}===== ./src/main/java/org/emblow/envelopify/service/llm/JllamaService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.llm;

import com.github.tjake.jlama.model.AbstractModel;
import com.github.tjake.jlama.model.ModelSupport;
import com.github.tjake.jlama.safetensors.DType;
import com.github.tjake.jlama.safetensors.prompt.PromptContext;
import com.github.tjake.jlama.util.Downloader;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.PatternService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.IntentDetectionService;
import org.emblow.envelopify.service.ml.AdvancedMLService;
import org.emblow.envelopify.service.ml.SpendingInsightService;

import java.io.File;
import java.io.IOException;
import java.util.UUID;

public class JllamaService extends AbstractLLMService {

    private final String modelName;
    private final String workingDirectory;
    private AbstractModel model;

    public JllamaService(
            TransactionService transactionService,
            EnvelopeService envelopeService,
            SpendingInsightService insightService,
            PatternService patternService,
            AdvancedMLService advancedMLService,
            IntentDetectionService intentDetectionService,
            AccountService accountService,
            String modelName,
            String workingDirectory
    ) {
        super(transactionService, envelopeService, insightService, patternService,
              advancedMLService, intentDetectionService, accountService);
        this.modelName = modelName;
        this.workingDirectory = workingDirectory;
    }

    @Override
    public String processUserQuery(String userQuery) {
        return super.processUserQuery(userQuery); // Delegate to AbstractLLMService
    }

    @Override
    protected String callLLM(String prompt) {
        try {
            AbstractModel localModel = getModel();

            PromptContext ctx;
            if (localModel.promptSupport().isPresent()) {
                ctx = localModel.promptSupport()
                        .get()
                        .builder()
                        .addSystemMessage("You are a financial analysis assistant with direct access to the user's financial data.")
                        .addUserMessage(prompt)
                        .build();
            } else {
                ctx = PromptContext.of(prompt);
            }

            return localModel.generateBuilder()
                .session(UUID.randomUUID())
                .promptContext(ctx)
                .ntokens(8096)
                .temperature(0.0f)
                .generate()
                .responseText;
        } catch (IOException e) {
            throw new RuntimeException("Error during JLlama inference: " + e.getMessage(), e);
        }
    }

    private synchronized AbstractModel getModel() throws IOException {
        if (model == null) {
            File localModelPath = new Downloader(workingDirectory, modelName).huggingFaceModel();
            model = ModelSupport.loadModel(localModelPath, DType.F32, DType.I8);
        }
        return model;
    }

    @Override
    protected boolean supportsStreaming() {
        return false;
    }
}===== ./src/main/java/org/emblow/envelopify/service/RecurringTransactionService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.scheduling.annotation.Scheduled;
import org.emblow.envelopify.domain.RecurringTransaction;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.repository.RecurringTransactionRepository;
import org.emblow.envelopify.repository.AccountRepository;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.TransactionType;
import org.emblow.envelopify.domain.User;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class RecurringTransactionService {
    private static final Logger log = LoggerFactory.getLogger(RecurringTransactionService.class);
    
    private final RecurringTransactionRepository repository;
    private final TransactionService transactionService;
    private final SecurityService securityService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;

    public RecurringTransactionService(
        RecurringTransactionRepository repository,
        TransactionService transactionService,
        SecurityService securityService,
        EnvelopeService envelopeService,
        AccountService accountService
    ) {
        this.repository = repository;
        this.transactionService = transactionService;
        this.securityService = securityService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;
    }

    @Transactional
    public RecurringTransaction create(RecurringTransaction recurring, Long accountId) {
        try {
            // Validate ownership of both envelope and account
            Envelope envelope = envelopeService.getEnvelope(recurring.getEnvelope().getId());
            Account account = accountService.getAccount(accountId);
            
            recurring.setAccount(account);
            recurring.setEnvelope(envelope);
            recurring.setNextDueDate(recurring.calculateNextDueDate());
            
            return repository.save(recurring);
            
        } catch (Exception e) {
            log.error("Error creating recurring transaction", e);
            throw new RuntimeException("Could not create recurring transaction: " + e.getMessage());
        }
    }

    @Transactional
    public void update(Long id, RecurringTransaction updated, Long accountId) {
        try {
            RecurringTransaction existing = repository.findById(id)
                .orElseThrow(() -> new RuntimeException("Recurring transaction not found"));
                
            // Validate ownership
            Envelope envelope = envelopeService.getEnvelope(updated.getEnvelope().getId());
            Account account = accountService.getAccount(accountId);
            
            // Update fields
            existing.setDescription(updated.getDescription());
            existing.setAmount(updated.getAmount());
            existing.setPattern(updated.getPattern());
            existing.setEnvelope(envelope);
            existing.setAccount(account);
            existing.setType(updated.getType());
            
            repository.save(existing);
            
        } catch (Exception e) {
            log.error("Error updating recurring transaction", e);
            throw new RuntimeException("Could not update recurring transaction: " + e.getMessage());
        }
    }

    @Transactional
    public void delete(Long id) {
        try {
            RecurringTransaction recurring = repository.findById(id)
                .orElseThrow(() -> new RuntimeException("Recurring transaction not found"));
                
            // Validate ownership through envelope
            envelopeService.getEnvelope(recurring.getEnvelope().getId());
            repository.deleteById(id);
            
        } catch (Exception e) {
            log.error("Error deleting recurring transaction", e);
            throw new RuntimeException("Could not delete recurring transaction: " + e.getMessage());
        }
    }

    public List<RecurringTransaction> getAllForEnvelope(Long envelopeId) {
        try {
            // This validates ownership
            envelopeService.getEnvelope(envelopeId);
            return repository.findByEnvelopeId(envelopeId);
            
        } catch (Exception e) {
            log.error("Error retrieving recurring transactions for envelope", e);
            throw new RuntimeException("Could not retrieve recurring transactions: " + e.getMessage());
        }
    }

    public List<RecurringTransaction> getAllForAccount(Long accountId) {
        try {
            // This validates ownership
            accountService.getAccount(accountId);
            return repository.findByAccountId(accountId);
            
        } catch (Exception e) {
            log.error("Error retrieving recurring transactions for account", e);
            throw new RuntimeException("Could not retrieve recurring transactions: " + e.getMessage());
        }
    }

    @Scheduled(cron = "0 0 * * * *") // Run every hour
    @Transactional
    public void processRecurringTransactions() {
        try {
            LocalDateTime now = LocalDateTime.now();
            List<RecurringTransaction> due = repository.findByNextDueDateBefore(now);
            
            for (RecurringTransaction recurring : due) {
                try {
                    // Validate ownership through envelope
                    envelopeService.getEnvelope(recurring.getEnvelope().getId());
                    
                    // Record the transaction
                    transactionService.recordTransaction(
                        recurring.getEnvelope().getId(),
                        recurring.getAccount().getId(),
                        recurring.getNextDueDate(),
                        recurring.getDescription(),
                        recurring.getAmount(),
                        recurring.getType()
                    );
                    
                    // Update the recurring transaction
                    recurring.setLastProcessed(recurring.getNextDueDate());
                    recurring.setNextDueDate(recurring.calculateNextDueDate());
                    repository.save(recurring);
                    
                    log.info("Processed recurring transaction: {} for amount: {}", 
                        recurring.getDescription(), 
                        recurring.getAmount());
                        
                } catch (Exception e) {
                    log.error("Error processing recurring transaction: {}", recurring.getId(), e);
                }
            }
        } catch (Exception e) {
            log.error("Error in recurring transaction processor", e);
        }
    }

    public List<RecurringTransaction> getByType(TransactionType type) {
        try {
            User currentUser = securityService.getCurrentUser();
            return repository.findByType(type).stream()
                .filter(tx -> tx.getEnvelope().getOwner().getId().equals(currentUser.getId()))
                .collect(Collectors.toList());
                
        } catch (Exception e) {
            log.error("Error retrieving recurring transactions by type", e);
            throw new RuntimeException("Could not retrieve recurring transactions: " + e.getMessage());
        }
    }

    public List<RecurringTransaction> getByAccountAndType(Long accountId, TransactionType type) {
        try {
            // Validate account ownership
            accountService.getAccount(accountId);
            return repository.findByAccountIdAndType(accountId, type);
            
        } catch (Exception e) {
            log.error("Error retrieving recurring transactions by account and type", e);
            throw new RuntimeException("Could not retrieve recurring transactions: " + e.getMessage());
        }
    }
}
===== ./src/main/java/org/emblow/envelopify/service/AccountService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.User;
import org.emblow.envelopify.repository.AccountRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.emblow.envelopify.exception.AccountException;
import org.emblow.envelopify.exception.BusinessException;
import org.emblow.envelopify.exception.ValidationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.DataIntegrityViolationException;

@Service
public class AccountService {
    private static final Logger log = LoggerFactory.getLogger(AccountService.class);

    private final AccountRepository accountRepository;
    private final SecurityService securityService;

    public AccountService(AccountRepository accountRepository, SecurityService securityService) {
        this.accountRepository = accountRepository;
        this.securityService = securityService;
    }

    public List<Account> getAllAccounts() {
        User currentUser = securityService.getCurrentUser();
        return accountRepository.findByOwner(currentUser);
    }

    @Transactional(readOnly = true)
    public Account getAccount(Long id) {
        User currentUser = securityService.getCurrentUser();

        return accountRepository.findByIdWithTransactions(id)
            .filter(account -> account.getOwner().getId().equals(currentUser.getId()))
            .orElseThrow(() -> new AccountException(
                AccountException.ACCOUNT_NOT_FOUND,
                String.format("Account %d not found or access denied", id)
            ));
    }
   
    @Transactional
    public Account createAccount(String name, Account.AccountType type, 
                               String institution, String accountNumber) {
        validateAccountCreation(name, type, institution, accountNumber);
        
        User currentUser = securityService.getCurrentUser();
        Account account = new Account(name, type, institution, currentUser);
        account.setAccountNumber(accountNumber);
        
        try {
            return accountRepository.save(account);
        } catch (DataIntegrityViolationException e) {
            throw new AccountException(AccountException.DUPLICATE_ACCOUNT, 
                "An account with this name already exists");
        }
    }
    private void validateAccountCreation(String name, Account.AccountType type, 
                                      String institution, String accountNumber) {
        Map<String, String> violations = new HashMap<>();
        
        if (name == null || name.trim().isEmpty()) {
            violations.put("name", "Name is required");
        } else if (name.length() > 100) {
            violations.put("name", "Name must be less than 100 characters");
        }
        
        if (type == null) {
            violations.put("type", "Account type is required");
        }
        
        if (accountNumber != null && !accountNumber.matches("\\d{4}")) {
            violations.put("accountNumber", "Account number must be exactly 4 digits");
        }
        
        if (!violations.isEmpty()) {
            throw new ValidationException(violations);
        }
    }
    
    @Transactional
    public void updateBalance(Long accountId, BigDecimal amount, boolean isCredit) {
        validateBalanceUpdate(accountId, amount);
        
        Account account = getAccount(accountId);
        
        if (!isCredit && account.getBalance().subtract(amount).compareTo(BigDecimal.ZERO) < 0 
            && account.getType() != Account.AccountType.CREDIT_CARD) {
            throw new AccountException(AccountException.INSUFFICIENT_BALANCE,
                String.format("Insufficient balance in account %s: required %.2f, available %.2f",
                    account.getName(), amount, account.getBalance()));
        }
        
        if (isCredit) {
            account.credit(amount);
        } else {
            account.debit(amount);
        }
        
        accountRepository.save(account);
    }
    
    private void validateBalanceUpdate(Long accountId, BigDecimal amount) {
        Map<String, String> violations = new HashMap<>();
        
        if (accountId == null) {
            violations.put("accountId", "Account ID is required");
        }
        
        if (amount == null) {
            violations.put("amount", "Amount is required");
        } else if (amount.compareTo(BigDecimal.ZERO) <= 0) {
            violations.put("amount", "Amount must be positive");
        }
        
        if (!violations.isEmpty()) {
            throw new ValidationException(violations);
        }
    }
    
    @Transactional
    public void transferBetweenAccounts(Long sourceId, Long targetId, BigDecimal amount) {
        validateTransfer(sourceId, targetId, amount);
        
        Account source = getAccount(sourceId);
        Account target = getAccount(targetId);
        
        if (sourceId.equals(targetId)) {
            throw new BusinessException("INVALID_OPERATION", 
                "Cannot transfer to the same account");
        }

        if (source.getBalance().subtract(amount).compareTo(BigDecimal.ZERO) < 0 
            && source.getType() != Account.AccountType.CREDIT_CARD) {
            throw new AccountException(AccountException.INSUFFICIENT_BALANCE,
                String.format("Insufficient balance in account %s: required %.2f, available %.2f",
                    source.getName(), amount, source.getBalance()));
        }
        
        source.debit(amount);
        target.credit(amount);
        
        accountRepository.save(source);
        accountRepository.save(target);
    }
    
    private void validateTransfer(Long sourceId, Long targetId, BigDecimal amount) {
        Map<String, String> violations = new HashMap<>();
        
        if (sourceId == null) {
            violations.put("sourceId", "Source account ID is required");
        }
        
        if (targetId == null) {
            violations.put("targetId", "Target account ID is required");
        }
        
        if (amount == null) {
            violations.put("amount", "Amount is required");
        } else if (amount.compareTo(BigDecimal.ZERO) <= 0) {
            violations.put("amount", "Amount must be positive");
        }
        
        if (!violations.isEmpty()) {
            throw new ValidationException(violations);
        }
    }
    
    /**
     * Saves the given account. If the account already exists, it validates that
     * the current user is the owner before saving the changes.
     */
    @Transactional
    public Account save(Account account) {
        // If the account has an ID, assume it's an update and validate ownership.
        if (account.getId() != null) {
            securityService.validateOwnership(account.getOwner());
        } else {
            // For a new account, enforce that the owner is the current user.
            User currentUser = securityService.getCurrentUser();
            if (!currentUser.getId().equals(account.getOwner().getId())) {
                throw new RuntimeException("Cannot assign account owner to another user.");
            }
        }
        return accountRepository.save(account);
    }

    @Transactional
    public void deleteAccount(Long id) {
        Account account = getAccount(id);
        
        if (!account.getTransactions().isEmpty()) {
            throw new BusinessException("ACCOUNT_IN_USE",
                "Cannot delete account that has transactions. " +
                "Transfer or delete transactions first.");
        }
        
        accountRepository.delete(account);
    }
}
===== ./src/main/java/org/emblow/envelopify/service/SettingService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.annotation.PostConstruct;
import java.util.ArrayList;
import org.emblow.envelopify.domain.Setting;
import org.emblow.envelopify.repository.SettingRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.context.event.EventListener;
import org.springframework.core.env.Environment;

import java.util.List;
import java.util.Optional;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.stream.Collectors;
import org.emblow.envelopify.domain.User;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.cloud.context.refresh.ContextRefresher;
import org.springframework.security.core.context.SecurityContextHolder;

@Service
public class SettingService {
    private static final Logger log = LoggerFactory.getLogger(SettingService.class);
    
    private final SettingRepository settingRepository;
    private final SecurityService securityService;
    private final Environment environment;
    private final ContextRefresher contextRefresher;

    public SettingService(
        SettingRepository settingRepository,
        SecurityService securityService,
        Environment environment,
        ContextRefresher contextRefresher
    ) {
        this.settingRepository = settingRepository;
        this.securityService = securityService;
        this.environment = environment;
        this.contextRefresher = contextRefresher;
    }

    @PostConstruct
    public void init() {
        try {
            initializeDefaultSettings();
        } catch (Exception e) {
            log.error("Error initializing settings", e);
        }
    }

    private void initializeDefaultSettings() {
        // Initialize LLM settings (system-wide)
        saveSettingIfNotExists(
            "llm.service.type",
            environment.getProperty("llm.service.type", "jllama"),
            Setting.SettingType.STRING,
            Setting.SettingCategory.LLM,
            "Type of LLM service to use"
        );
        
        saveSettingIfNotExists(
            "openai.api.key",
            environment.getProperty("openai.api.key", ""),
            Setting.SettingType.PASSWORD,
            Setting.SettingCategory.LLM,
            "OpenAI API Key"
        );
        
        // More system-wide settings...
        
        // Initialize default appearance settings (these will be overridden per user)
        saveSettingIfNotExists(
            "appearance.theme.default",
            "light",
            Setting.SettingType.STRING,
            Setting.SettingCategory.APPEARANCE,
            "Default UI Theme"
        );
    }

    @Transactional
    private void saveSettingIfNotExists(
        String key,
        String defaultValue,
        Setting.SettingType type,
        Setting.SettingCategory category,
        String description
    ) {
        try {
            if (!settingRepository.existsById(key)) {
                Setting setting = new Setting(key, defaultValue, type, category, description);
                settingRepository.save(setting);
                log.debug("Created setting: {}", key);
            }
        } catch (Exception e) {
            log.error("Error creating setting: {}", key, e);
        }
    }

    @Transactional
    public void saveSetting(String key, String value) {
        try {
            // Get current user if needed for user-specific setting
            final String settingKey;
            if (isUserSpecificSetting(key)) {
                User currentUser = securityService.getCurrentUser();
                settingKey = getUserSettingKey(currentUser.getId(), key);
            } else {
                settingKey = key;
            }

            // Lookup or create the setting
            Setting setting = settingRepository.findById(settingKey)
                .orElseGet(() -> createNewSetting(settingKey, key));

            setting.setValue(value);
            settingRepository.save(setting);

            // Refresh configuration if needed
            Set<String> refreshedKeys = contextRefresher.refresh();
            log.debug("Refreshed properties: {}", refreshedKeys);

        } catch (Exception e) {
            log.error("Error saving setting: {}", key, e);
            throw new RuntimeException("Could not save setting: " + e.getMessage());
        }
    }

    private Setting createNewSetting(String newKey, String originalKey) {
        Setting newSetting = new Setting();
        newSetting.setKey(newKey);

        // Try to get properties from default setting
        Setting defaultSetting = settingRepository.findById(originalKey).orElse(null);
        if (defaultSetting != null) {
            newSetting.setType(defaultSetting.getType());
            newSetting.setCategory(defaultSetting.getCategory());
            newSetting.setDescription(defaultSetting.getDescription());
        } else {
            // Set some reasonable defaults if no template exists
            newSetting.setType(Setting.SettingType.STRING);
            newSetting.setCategory(Setting.SettingCategory.GENERAL);
        }

        return newSetting;
    }
    public String getSetting(String key) {
        try {
            // For user-specific settings, try user's setting first
            if (isUserSpecificSetting(key)) {
                User currentUser = securityService.getCurrentUser();
                String userKey = getUserSettingKey(currentUser.getId(), key);
                Optional<Setting> userSetting = settingRepository.findById(userKey);
                if (userSetting.isPresent()) {
                    return userSetting.get().getValue();
                }
            }
            
            // Fall back to default setting
            return settingRepository.findById(key)
                .map(Setting::getValue)
                .orElse(null);
                
        } catch (Exception e) {
            log.error("Error retrieving setting: {}", key, e);
            throw new RuntimeException("Could not retrieve setting: " + e.getMessage());
        }
    }

    public String getSetting(String key, String defaultValue) {
        return Optional.ofNullable(getSetting(key)).orElse(defaultValue);
    }

    public Map<String, String> getSettingsByCategory(Setting.SettingCategory category) {
        try {
            Map<String, String> settings = new HashMap<>();
            List<Setting> categorySettings = settingRepository.findByCategory(category);
            
            // First add all non-user-specific settings
            categorySettings.stream()
                .filter(s -> !isUserSpecificSettingKey(s.getKey()))
                .forEach(s -> settings.put(s.getKey(), s.getValue()));
            
            // Then override with user-specific settings if they exist
            if (SecurityContextHolder.getContext().getAuthentication() != null) {
                User currentUser = securityService.getCurrentUser();
                String userPrefix = getUserPrefix(currentUser.getId());
                
                categorySettings.stream()
                    .filter(s -> s.getKey().startsWith(userPrefix))
                    .forEach(s -> {
                        String originalKey = s.getKey().substring(userPrefix.length());
                        settings.put(originalKey, s.getValue());
                    });
            }
            
            return settings;
            
        } catch (Exception e) {
            log.error("Error retrieving settings for category: {}", category, e);
            throw new RuntimeException("Could not retrieve settings: " + e.getMessage());
        }
    }

    @Transactional
    public void resetToDefaults() {
        try {
            User currentUser = securityService.getCurrentUser();
            String userPrefix = getUserPrefix(currentUser.getId());
            
            // Find and delete all settings with user's prefix
            settingRepository.findAll().stream()
                .filter(s -> s.getKey().startsWith(userPrefix))
                .forEach(s -> settingRepository.deleteById(s.getKey()));
                
            log.info("Reset user-specific settings for user ID: {}", currentUser.getId());
        } catch (Exception e) {
            log.error("Error resetting settings to defaults", e);
            throw new RuntimeException("Could not reset settings: " + e.getMessage());
        }
    }

    // Helper methods
    private boolean isUserSpecificSetting(String key) {
        return key.startsWith("appearance.") || 
               key.startsWith("preference.") ||
               key.startsWith("notification.");
    }

    private boolean isUserSpecificSettingKey(String key) {
        return key.matches("user\\.[0-9]+\\..*");
    }

    private String getUserPrefix(Long userId) {
        return String.format("user.%d.", userId);
    }

    private String getUserSettingKey(Long userId, String key) {
        return getUserPrefix(userId) + key;
    }
}===== ./src/main/java/org/emblow/envelopify/service/TestDataService.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.annotation.Propagation;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Random;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class TestDataService {
    private static final Logger log = LoggerFactory.getLogger(TestDataService.class);
    
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final TransactionService transactionService;
    private final Random random = new Random();

    public TestDataService(
        EnvelopeService envelopeService,
        AccountService accountService,
        TransactionService transactionService
    ) {
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.transactionService = transactionService;
    }

    /**
     * Creates test data in several steps:
     * 
     * 1. Create the accounts.
     * 2. Create the envelopes (for expense categories) with an initial allocation of zero.
     * 3. For each month in the past 6 months, simulate a transfer from the checking account
     *    into each envelope (i.e. the monthly allocation) and then record expense transactions
     *    against the envelopes.
     * 4. Record a few unusual oneâ€‘off transactions.
     */
    @Transactional
    public void createTestData() {
        // --- Step 1: Create accounts ---
        Account checking = accountService.createAccount(
            "Main Checking",
            Account.AccountType.CHECKING,
            "Chase Bank",
            "1234"
        );
        
        Account savings = accountService.createAccount(
            "Emergency Fund",
            Account.AccountType.SAVINGS,
            "Ally Bank",
            "5678"
        );
        
        Account creditCard = accountService.createAccount(
            "Rewards Card",
            Account.AccountType.CREDIT_CARD,
            "Capital One",
            "9012"
        );
        
        // --- Step 2: Create envelopes for expense categories.
        // (We create them with 0 initial funds; funds will be added monthly.)
        Envelope rent = envelopeService.createEnvelope("Rent", BigDecimal.ZERO);
        Envelope utilities = envelopeService.createEnvelope("Utilities", BigDecimal.ZERO);
        Envelope groceries = envelopeService.createEnvelope("Groceries", BigDecimal.ZERO);
        Envelope entertainment = envelopeService.createEnvelope("Entertainment", BigDecimal.ZERO);
        Envelope transport = envelopeService.createEnvelope("Transport", BigDecimal.ZERO);
        envelopeService.flush();
        
        // --- Step 3: For each of the past 6 months, simulate monthly transfers and expense transactions.
        LocalDateTime now = LocalDateTime.now();
        // Define monthly allocation amounts for each envelope.
        BigDecimal rentAllocation = new BigDecimal("2000.00");
        BigDecimal utilitiesAllocation = new BigDecimal("300.00");
        BigDecimal groceriesAllocation = new BigDecimal("600.00");
        BigDecimal entertainmentAllocation = new BigDecimal("200.00");
        BigDecimal transportAllocation = new BigDecimal("150.00");
        
        // Loop over the past 6 months (month = 5 is the oldest, month = 0 is the current month)
        for (int month = 5; month >= 0; month--) {
            // Determine a transfer date for this month (e.g., the first day)
            LocalDateTime transferDate = now.minusMonths(month).withDayOfMonth(1);
            
            // Simulate a transfer into each envelope from the checking account.
            createTransaction(rent.getId(), checking.getId(), transferDate,
                "Monthly Rent Transfer", rentAllocation, TransactionType.INCOME);
            createTransaction(utilities.getId(), checking.getId(), transferDate,
                "Monthly Utilities Transfer", utilitiesAllocation, TransactionType.INCOME);
            createTransaction(groceries.getId(), checking.getId(), transferDate,
                "Monthly Groceries Transfer", groceriesAllocation, TransactionType.INCOME);
            createTransaction(entertainment.getId(), checking.getId(), transferDate,
                "Monthly Entertainment Transfer", entertainmentAllocation, TransactionType.INCOME);
            createTransaction(transport.getId(), checking.getId(), transferDate,
                "Monthly Transport Transfer", transportAllocation, TransactionType.INCOME);
            envelopeService.flush();
            
            // Now record expense transactions for this month.
            // Rent: one expense on the transfer date.
            createTransaction(rent.getId(), checking.getId(), transferDate,
                "Monthly Rent Payment", new BigDecimal("1800.00"), TransactionType.EXPENSE);
            
            // Utilities: expense on the 15th of the month.
            LocalDateTime utilitiesExpenseDate = now.minusMonths(month).withDayOfMonth(15);
            int monthValue = utilitiesExpenseDate.getMonthValue();
            BigDecimal utilitiesExpense = (monthValue <= 3 || monthValue >= 11)
                ? new BigDecimal("280.00")
                : new BigDecimal("180.00");
            createTransaction(utilities.getId(), checking.getId(), utilitiesExpenseDate,
                "Power and Water Bill", utilitiesExpense, TransactionType.EXPENSE);
            
            // Groceries: simulate roughly 4 weekly expenses per month.
            for (int week = 0; week < 4; week++) {
                LocalDateTime weekDate = transferDate.plusDays(week * 7);
                // Randomly choose between checking and credit card.
                Account selectedAccount = random.nextBoolean() ? checking : creditCard;
                createTransaction(groceries.getId(), selectedAccount.getId(), weekDate,
                    "Weekly Groceries", randomAmount(120, 160), TransactionType.EXPENSE);
            }
            
            // Entertainment: simulate 1 to 3 random expense events within the month on the credit card.
            int entertainmentCount = random.nextInt(3) + 1;
            for (int j = 0; j < entertainmentCount; j++) {
                LocalDateTime entDate = transferDate.plusDays(random.nextInt(28));
                createTransaction(entertainment.getId(), creditCard.getId(), entDate,
                    randomEntertainmentDescription(), randomAmount(20, 80), TransactionType.EXPENSE);
            }
            
            // Transport: simulate a monthly bus pass expense and a couple of rideshare expenses.
            createTransaction(transport.getId(), checking.getId(), transferDate,
                "Monthly Bus Pass", new BigDecimal("60.00"), TransactionType.EXPENSE);
            for (int j = 0; j < 2; j++) {
                LocalDateTime rideDate = transferDate.plusDays(random.nextInt(28));
                createTransaction(transport.getId(), creditCard.getId(), rideDate,
                    "Uber Ride", randomAmount(15, 35), TransactionType.EXPENSE);
            }
            
            envelopeService.flush();
        }
        
        // --- Step 4: Record a few unusual oneâ€‘off expense transactions.
        createTransaction(groceries.getId(), creditCard.getId(), now.minusDays(5),
            "Big Party Shopping", new BigDecimal("450.00"), TransactionType.EXPENSE);
        createTransaction(entertainment.getId(), creditCard.getId(), now.minusDays(10),
            "Concert Tickets", new BigDecimal("180.00"), TransactionType.EXPENSE);
        envelopeService.flush();
    }
    
    /**
     * Creates a transaction in its own transaction boundary.
     * For expense transactions, it verifies that the envelope has sufficient funds and deducts the amount;
     * for income transactions, it increases the envelopeâ€™s allocation.
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    private boolean createTransaction(
        Long envelopeId,
        Long accountId,
        LocalDateTime date,
        String description,
        BigDecimal amount,
        TransactionType type
    ) {
        Envelope envelope;
        try {
            envelope = envelopeService.getEnvelope(envelopeId);
        } catch (RuntimeException ex) {
            log.error("Failed to retrieve envelope with id " + envelopeId, ex);
            envelope = null;
        }
        if (envelope == null) {
            log.error("Failed to create test transaction '{}': Envelope not found", description);
            return false;
        }
        
        if (type == TransactionType.EXPENSE) {
            if (!envelope.canSpend(amount)) {
                log.error("Failed to create test transaction '{}': Insufficient funds in envelope '{}' for amount: {}",
                    description, envelope.getName(), amount);
                return false;
            }
            envelope.spend(amount);
        } else if (type == TransactionType.INCOME) {
            envelope.allocate(amount);
        }
        
        try {
            transactionService.recordTransaction(envelopeId, accountId, date, description, amount, type);
            log.debug("Created test transaction: {} for ${}", description, amount);
            return true;
        } catch (Exception e) {
            log.warn("Failed to create test transaction: {} - {}", description, e.getMessage());
            return false;
        }
    }
    
    private BigDecimal randomAmount(double min, double max) {
        double amt = min + (random.nextDouble() * (max - min));
        return BigDecimal.valueOf(amt).setScale(2, BigDecimal.ROUND_HALF_UP);
    }
    
    private String randomEntertainmentDescription() {
        String[] options = {
            "Movie Tickets",
            "Restaurant Dinner",
            "Bowling Night",
            "Board Game Cafe",
            "Bar Tab",
            "Coffee and Dessert",
            "Arcade Games",
            "Mini Golf"
        };
        return options[random.nextInt(options.length)];
    }
}
===== ./src/main/java/org/emblow/envelopify/config/LLMConfig.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.config;

import org.emblow.envelopify.service.AccountService;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.emblow.envelopify.service.SettingService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.emblow.envelopify.service.PatternService;
import org.emblow.envelopify.service.IntentDetectionService;
import org.emblow.envelopify.service.ml.AdvancedMLService;
import org.emblow.envelopify.service.llm.LLMService;
import org.emblow.envelopify.service.llm.ChatGPTService;
import org.emblow.envelopify.service.llm.JllamaService;
import org.emblow.envelopify.service.llm.OllamaService;
import org.emblow.envelopify.service.llm.GroqService;

@Configuration
public class LLMConfig {

    private final SettingService settingService;

    public LLMConfig(SettingService settingService) {
        this.settingService = settingService;
    }

    @Bean
    @Primary
    @RefreshScope
    public LLMService llmService(
            TransactionService transactionService,
            EnvelopeService envelopeService,
            SpendingInsightService insightService,
            PatternService patternService,
            AdvancedMLService advancedMLService,
            IntentDetectionService intentDetectionService,
            AccountService accountService
    ) {
        String type = settingService.getSetting("llm.service.type", "jllama").trim().toLowerCase();
        switch (type) {
            case "chatgpt":
                String openaiApiKey = settingService.getSetting("openai.api.key", "sk-default");
                String openaiChatEndpoint = settingService.getSetting("openai.chat.endpoint", "https://api.openai.com/v1/chat/completions");
                return new ChatGPTService(
                    transactionService, envelopeService, insightService, patternService, 
                    advancedMLService, intentDetectionService, accountService,
                    openaiApiKey, openaiChatEndpoint
                );
            case "jllama":
                String jllamaDirectory = settingService.getSetting("jllama.model.directory", "./models");
                String jllamaModelName = settingService.getSetting("jllama.model.name", "tjake/Llama-3.2-1B-Instruct-JQ4");
                return new JllamaService(
                    transactionService, envelopeService, insightService, patternService, 
                    advancedMLService, intentDetectionService, accountService,
                    jllamaModelName, jllamaDirectory
                );
            case "ollama":
                String ollamaUrl = settingService.getSetting("ollama.url", "http://localhost:11434");
                String ollamaModel = settingService.getSetting("ollama.model", "dolphin3:latest");
                return new OllamaService(
                    transactionService, envelopeService, insightService, patternService, 
                    advancedMLService, intentDetectionService, accountService,
                    ollamaUrl, ollamaModel
                );
            case "groq":
                String groqApiKey = settingService.getSetting("groq.api.key", "gsk-default");
                String groqBaseUrl = settingService.getSetting("groq.base.url", "https://api.groq.com");
                String groqModel = settingService.getSetting("groq.chat.model", "mixtral-8x7b-32768");
                return new GroqService(
                    transactionService, envelopeService, insightService, patternService, 
                    advancedMLService, intentDetectionService, accountService,
                    groqApiKey, groqBaseUrl, groqModel
                );
            default:
                throw new IllegalArgumentException("Unknown LLM service type: " + type);
        }
    }
}===== ./src/main/java/org/emblow/envelopify/config/GlobalExceptionHandler.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.config;

import org.emblow.envelopify.domain.InsufficientFundsException;
import org.emblow.envelopify.exception.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(InsufficientFundsException.class)
    public ResponseEntity<ErrorResponse> handleInsufficientFunds(InsufficientFundsException ex) {
        ErrorResponse error = new ErrorResponse(
            "INSUFFICIENT_FUNDS",
            ex.getMessage()
        );
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidation(ValidationException ex) {
        return new ResponseEntity<>(
            new ErrorResponse(ex.getCode(), ex.getMessage(), ex.getDetails()),
            HttpStatus.BAD_REQUEST
        );
    }

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusiness(BusinessException ex) {
        return new ResponseEntity<>(
            new ErrorResponse(ex.getCode(), ex.getMessage()),
            HttpStatus.BAD_REQUEST
        );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex) {
        log.error("Unexpected error", ex);
        return new ResponseEntity<>(
            new ErrorResponse("INTERNAL_ERROR", "An unexpected error occurred"),
            HttpStatus.INTERNAL_SERVER_ERROR
        );
    }
}===== ./src/main/java/org/emblow/envelopify/config/SecurityConfig.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.config;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .headers(headers -> headers
                .frameOptions(frame -> frame.sameOrigin())
            )
            .authorizeHttpRequests(authorize -> authorize
                // Vaadin Flow static resources
                .requestMatchers(
                    "/VAADIN/**",
                    "/vaadinServlet/**",
                    "/frontend/**",
                    "/frontend-es6/**",
                    "/frontend-es5/**",
                    "/icons/**",
                    "/images/**",
                    "/themes/**",
                    "/*.txt",
                    "/favicon.ico",
                    "/*.js",
                    "/*.ts",
                    "/*.json",
                    "/sw.js",
                    "/offline.html",
                    "/manifest.json",
                    "/robots.txt",
                    "/@vite/**",
                    "/@fs/**",
                    "/src/**"
                ).permitAll()
                // Login and registration views
                .requestMatchers(
                    new AntPathRequestMatcher("/login"),
                    new AntPathRequestMatcher("/register"),
                    new AntPathRequestMatcher("/"),
                    new AntPathRequestMatcher("/error")
                ).permitAll()
                // Everything else needs authentication
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/login")
                .loginProcessingUrl("/login")
                .defaultSuccessUrl("/dashboard", true)
                .permitAll()
            )
            .logout(logout -> logout
                .logoutSuccessUrl("/login")
                .permitAll()
            );

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}===== ./src/main/java/org/emblow/envelopify/config/DatabaseConfig.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.config;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableJpaAuditing
@EnableTransactionManagement
public class DatabaseConfig {
    // Additional database configuration if needed
}===== ./src/main/java/org/emblow/envelopify/config/ApplicationConfig.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.config;

import org.springframework.boot.web.servlet.ServletListenerRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.web.session.HttpSessionEventPublisher;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 *
 * @author Nicholas J Emblow
 */
@Configuration
public class ApplicationConfig {
    @Bean
    public ServletListenerRegistrationBean<HttpSessionEventPublisher> httpSessionEventPublisher() {
        return new ServletListenerRegistrationBean<>(new HttpSessionEventPublisher());
    }
}
===== ./src/main/java/org/emblow/envelopify/EnvelopifyApplication.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.dependency.NpmPackage;
import com.vaadin.flow.component.page.AppShellConfigurator;
import com.vaadin.flow.component.page.Push;
import com.vaadin.flow.server.AppShellSettings;
import com.vaadin.flow.theme.Theme;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@Theme(value = "envelopify")
@Push
@NpmPackage(value = "@vaadin/vaadin-lumo-styles", version = "24.2.5")
public class EnvelopifyApplication implements AppShellConfigurator {
    
    @Override
    public void configurePage(AppShellSettings settings) {
        settings.addMetaTag("viewport", "width=device-width, initial-scale=1.0");
        settings.addFavIcon("icon", "icons/favicon.ico", "256x256");
    }

    public static void main(String[] args) {
        SpringApplication.run(EnvelopifyApplication.class, args);
    }
}
===== ./src/main/java/org/emblow/envelopify/repository/AccountRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Account;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;
import org.emblow.envelopify.domain.User;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
    List<Account> findByType(Account.AccountType type);
    List<Account> findByInstitution(String institution);
    List<Account> findByOwner(User owner);
    List<Account> findByOwnerAndType(User owner, Account.AccountType type);
    List<Account> findByOwnerAndInstitution(User owner, String institution);
    Optional<Account> findByIdAndOwner(Long id, User owner);
        @Query("SELECT a FROM Account a LEFT JOIN FETCH a.transactions " +
           "WHERE a.id = :id")
    Optional<Account> findByIdWithTransactions(@Param("id") Long id);
}

===== ./src/main/java/org/emblow/envelopify/repository/RecurringTransactionRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

import org.emblow.envelopify.domain.RecurringTransaction;
import org.emblow.envelopify.domain.TransactionType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.time.LocalDateTime;
import java.util.List;
import org.emblow.envelopify.domain.TransactionType;

@Repository
public interface RecurringTransactionRepository extends JpaRepository<RecurringTransaction, Long> {
    List<RecurringTransaction> findByNextDueDateBefore(LocalDateTime date);
    List<RecurringTransaction> findByEnvelopeId(Long envelopeId);
    List<RecurringTransaction> findByAccountId(Long accountId);
    List<RecurringTransaction> findByType(TransactionType type);
    List<RecurringTransaction> findByAccountIdAndType(Long accountId, TransactionType type);
}
===== ./src/main/java/org/emblow/envelopify/repository/EnvelopeRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

/**
 *
 * @author Nicholas J Emblow
 */
import java.util.List;
import java.util.Optional;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface EnvelopeRepository extends JpaRepository<Envelope, Long> {
@Query("SELECT e FROM Envelope e LEFT JOIN FETCH e.transactions WHERE e.id = :id")
Optional<Envelope> findByIdWithTransactions(@Param("id") Long id);
    List<Envelope> findByOwner(User owner);
    Optional<Envelope> findByIdAndOwner(Long id, User owner);
    
    @Query("SELECT e FROM Envelope e LEFT JOIN FETCH e.transactions WHERE e.id = :id AND e.owner = :owner")
    Optional<Envelope> findByIdAndOwnerWithTransactions(@Param("id") Long id, @Param("owner") User owner);
}
===== ./src/main/java/org/emblow/envelopify/repository/TransactionRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Transaction;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.time.LocalDateTime;
import java.util.List;
import org.emblow.envelopify.domain.User;

@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    List<Transaction> findByDateBetweenOrderByDateDesc(LocalDateTime start, LocalDateTime end);
    
    // New methods
    List<Transaction> findByDateAfterOrderByDateDesc(LocalDateTime date);
    
    @Query("SELECT t FROM Transaction t WHERE t.envelope.name = :envelopeName")
    List<Transaction> findByEnvelopeName(String envelopeName);
    
    List<Transaction> findByDateBetweenAndEnvelope_OwnerOrderByDateDesc(
        LocalDateTime start, 
        LocalDateTime end, 
        User owner
    );
    
    List<Transaction> findByDateAfterAndEnvelope_OwnerOrderByDateDesc(
        LocalDateTime date,
        User owner
    );

}

===== ./src/main/java/org/emblow/envelopify/repository/BillReminderRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.BillReminder;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;

@Repository
public interface BillReminderRepository extends JpaRepository<BillReminder, Long> {
    List<BillReminder> findByPaidFalseAndDueDateBefore(LocalDate date);
    List<BillReminder> findByEnvelopeId(Long envelopeId);
    List<BillReminder> findByPaidFalseOrderByDueDateAsc();
}
===== ./src/main/java/org/emblow/envelopify/repository/SettingRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Setting;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import org.springframework.transaction.annotation.Transactional;

@Repository
@Transactional
public interface SettingRepository extends JpaRepository<Setting, String> {
    List<Setting> findByCategory(Setting.SettingCategory category);
    List<Setting> findByType(Setting.SettingType type);
}
===== ./src/main/java/org/emblow/envelopify/repository/PatternRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

import org.emblow.envelopify.domain.Pattern;
import org.emblow.envelopify.domain.Category;
import org.emblow.envelopify.domain.Pattern.PatternType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface PatternRepository extends JpaRepository<Pattern, Long> {
    List<Pattern> findByCategory(Category category);
    List<Pattern> findByType(PatternType type);
    Optional<Pattern> findByPatternAndType(String pattern, PatternType type);
    
    @Query("SELECT p FROM Pattern p WHERE p.category.owner.id = :userId")
    List<Pattern> findByUserId(@Param("userId") Long userId);
    
    @Query("SELECT p FROM Pattern p WHERE p.category.owner.id = :userId AND p.confidence >= :minConfidence")
    List<Pattern> findConfidentPatterns(@Param("userId") Long userId, @Param("minConfidence") Double minConfidence);
    
    @Query("SELECT p FROM Pattern p WHERE p.category.id = :categoryId AND p.type = :type ORDER BY p.confidence DESC")
    List<Pattern> findByCategoryAndType(@Param("categoryId") Long categoryId, @Param("type") PatternType type);
}===== ./src/main/java/org/emblow/envelopify/repository/CategoryRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Category;
import org.emblow.envelopify.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
    List<Category> findByOwner(User owner);
    Optional<Category> findByNameAndOwner(String name, User owner);
}

===== ./src/main/java/org/emblow/envelopify/repository/ChatSessionRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

/**
 *
 * @author Nicholas J Emblow
 */

import org.emblow.envelopify.domain.ChatSession;
import org.emblow.envelopify.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ChatSessionRepository extends JpaRepository<ChatSession, Long> {
    List<ChatSession> findByOwnerOrderByCreatedAtDesc(User owner);
}
===== ./src/main/java/org/emblow/envelopify/repository/ChartArtifactRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

import org.emblow.envelopify.domain.ChartArtifact;
import org.emblow.envelopify.domain.ChatSession;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ChartArtifactRepository extends JpaRepository<ChartArtifact, Long> {
    List<ChartArtifact> findBySession(ChatSession session);
    List<ChartArtifact> findBySessionOrderByCreatedAtDesc(ChatSession session);
    List<ChartArtifact> findBySession_IdOrderByCreatedAtDesc(Long sessionId);
    void deleteBySession(ChatSession session);
}
===== ./src/main/java/org/emblow/envelopify/repository/UserRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    boolean existsByUsername(String username);
    boolean existsByEmail(String email);
}===== ./src/main/java/org/emblow/envelopify/repository/ChatMessageRepository.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repository;

/**
 *
 * @author Nicholas J Emblow
 */

import org.emblow.envelopify.domain.ChatMessage;
import org.emblow.envelopify.domain.ChatSession;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ChatMessageRepository extends JpaRepository<ChatMessage, Long> {
    List<ChatMessage> findBySessionOrderByTimestampAsc(ChatSession session);
}
===== ./src/main/java/org/emblow/envelopify/domain/Account.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Entity
public class Account {
    @Id 
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String name;
    
    @NotNull
    private AccountType type;
    
    @NotNull
    private BigDecimal balance = BigDecimal.ZERO;
    

    @ManyToOne
    @NotNull
    private User owner;    
    
    private String accountNumber; // Last 4 digits for reference
    private String institution;
     @OneToMany(mappedBy = "account")
    private List<RecurringTransaction> recurringTransactions = new ArrayList<>();   
    @OneToMany(mappedBy = "account")
    private List<Transaction> transactions = new ArrayList<>();
    
    public enum AccountType {
        CHECKING("Checking"),
        SAVINGS("Savings"),
        CREDIT_CARD("Credit Card"),
        CASH("Cash"),
        INVESTMENT("Investment");
        
        private final String displayName;
        
        AccountType(String displayName) {
            this.displayName = displayName;
        }
        
        public String getDisplayName() {
            return displayName;
        }
    }

    // Constructors
    public Account() {}
    
    public Account(String name, AccountType type, String institution, User owner) {
        this.name = name;
        this.type = type;
        this.institution = institution;
        this.owner = owner;
    }
    
    // Balance management methods
    public void credit(BigDecimal amount) {
        this.balance = this.balance.add(amount);
    }
    
    public void debit(BigDecimal amount) {
        this.balance = this.balance.subtract(amount);
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public AccountType getType() { return type; }
    public void setType(AccountType type) { this.type = type; }
    
    public BigDecimal getBalance() { return balance; }
    public void setBalance(BigDecimal balance) { this.balance = balance; }
    
    public String getAccountNumber() { return accountNumber; }
    public void setAccountNumber(String accountNumber) { this.accountNumber = accountNumber; }
    
    public String getInstitution() { return institution; }
    public void setInstitution(String institution) { this.institution = institution; }
    
    public List<Transaction> getTransactions() { return transactions; }
    public void setTransactions(List<Transaction> transactions) { this.transactions = transactions; }

    public User getOwner() { return owner; }
    public void setOwner(User owner) { this.owner = owner; }
}
===== ./src/main/java/org/emblow/envelopify/domain/ChatSession.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "chat_session")
public class ChatSession {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    private String title;

    @NotNull
    @ManyToOne
    private User owner;

    @NotNull
    private LocalDateTime createdAt;

    @OneToMany(mappedBy = "session", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ChatMessage> messages = new ArrayList<>();

    // Constructors
    public ChatSession() {}

    public ChatSession(String title, User owner) {
        this.title = title;
        this.owner = owner;
        this.createdAt = LocalDateTime.now();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public User getOwner() { return owner; }
    public void setOwner(User owner) { this.owner = owner; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public List<ChatMessage> getMessages() { return messages; }
    public void setMessages(List<ChatMessage> messages) { this.messages = messages; }

    public void addMessage(ChatMessage message) {
        messages.add(message);
        message.setSession(this);
    }
}
===== ./src/main/java/org/emblow/envelopify/domain/RecurringTransaction.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import org.emblow.envelopify.domain.TransactionType;  

@Entity
public class RecurringTransaction {
    @Id 
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String description;
    
    @NotNull
    private BigDecimal amount;
    
    @NotNull
    @ManyToOne
    private Envelope envelope;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    private RecurrencePattern pattern;
    
    private LocalDateTime nextDueDate;
    private LocalDateTime lastProcessed;
    
    @NotNull
    @ManyToOne
    private Account account;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    private TransactionType type;  // New field for classification (e.g., INCOME or EXPENSE)
    
    public enum RecurrencePattern {
        DAILY,
        WEEKLY,
        BIWEEKLY,
        MONTHLY,
        YEARLY
    }
    
    // Default constructor
    public RecurringTransaction() {}
    
    // Full constructor updated to include transaction type
    public RecurringTransaction(
        String description,
        BigDecimal amount,
        Envelope envelope,
        Account account,
        RecurrencePattern pattern,
        TransactionType type
    ) {
        this.description = description;
        this.amount = amount;
        this.envelope = envelope;
        this.account = account;
        this.pattern = pattern;
        this.type = type;
        this.nextDueDate = calculateNextDueDate();
    }
    
    public LocalDateTime calculateNextDueDate() {
        LocalDateTime base = (lastProcessed != null) ? lastProcessed : LocalDateTime.now();
        return switch (pattern) {
            case DAILY -> base.plusDays(1);
            case WEEKLY -> base.plusWeeks(1);
            case BIWEEKLY -> base.plusWeeks(2);
            case MONTHLY -> base.plusMonths(1);
            case YEARLY -> base.plusYears(1);
        };
    }
    
    // Getters and Setters
    
    public Long getId() { 
        return id; 
    }
    
    public void setId(Long id) { 
        this.id = id; 
    }
    
    public String getDescription() { 
        return description; 
    }
    
    public void setDescription(String description) { 
        this.description = description; 
    }
    
    public BigDecimal getAmount() { 
        return amount; 
    }
    
    public void setAmount(BigDecimal amount) { 
        this.amount = amount; 
    }
    
    public Envelope getEnvelope() { 
        return envelope; 
    }
    
    public void setEnvelope(Envelope envelope) { 
        this.envelope = envelope; 
    }
    
    public RecurrencePattern getPattern() { 
        return pattern; 
    }
    
    public void setPattern(RecurrencePattern pattern) { 
        this.pattern = pattern; 
    }
    
    public LocalDateTime getNextDueDate() { 
        return nextDueDate; 
    }
    
    public void setNextDueDate(LocalDateTime nextDueDate) { 
        this.nextDueDate = nextDueDate; 
    }
    
    public LocalDateTime getLastProcessed() { 
        return lastProcessed; 
    }
    
    public void setLastProcessed(LocalDateTime lastProcessed) { 
        this.lastProcessed = lastProcessed; 
    }
    
    public Account getAccount() { 
        return account; 
    }
    
    public void setAccount(Account account) { 
        this.account = account; 
    }
    
    public TransactionType getType() { 
        return type; 
    }
    
    public void setType(TransactionType type) { 
        this.type = type; 
    }
}
===== ./src/main/java/org/emblow/envelopify/domain/Category.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.validation.constraints.NotNull;
import java.util.List;

@Entity
public class Category {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String name;
    
    @NotNull
    private String description;
    
    @ManyToOne
    @NotNull
    private User owner;
    
    @OneToMany(mappedBy = "category")
    private List<Pattern> patterns;
    
    @OneToOne
    private Envelope envelope;
    
    // Constructors
    public Category() {}
    
    public Category(String name, String description) {
        this.name = name;
        this.description = description;
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public User getOwner() { return owner; }
    public void setOwner(User owner) { this.owner = owner; }
    
    public List<Pattern> getPatterns() { return patterns; }
    public void setPatterns(List<Pattern> patterns) { this.patterns = patterns; }
    
    public Envelope getEnvelope() { return envelope; }
    public void setEnvelope(Envelope envelope) { this.envelope = envelope; }
}


===== ./src/main/java/org/emblow/envelopify/domain/User.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotNull;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "app_user")  // avoid reserved word "user"
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(unique = true)
    private String username;

    @NotNull
    private String passwordHash;

    @Email
    @Column(unique = true)
    private String email;

    private String fullName;

    @OneToMany(mappedBy = "owner", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Account> accounts = new ArrayList<>();

    @OneToMany(mappedBy = "owner", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Envelope> envelopes = new ArrayList<>();

    // Default timezone for date/time formatting
    private String timezone = "UTC";

    // Default currency code (ISO 4217)
    private String currencyCode = "USD";

    // Constructor
    public User() {}

    public User(String username, String passwordHash, String email) {
        this.username = username;
        this.passwordHash = passwordHash;
        this.email = email;
    }

    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }

    public String getPasswordHash() { return passwordHash; }
    public void setPasswordHash(String passwordHash) { this.passwordHash = passwordHash; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getFullName() { return fullName; }
    public void setFullName(String fullName) { this.fullName = fullName; }

    public List<Account> getAccounts() { return accounts; }
    public void setAccounts(List<Account> accounts) { this.accounts = accounts; }

    public List<Envelope> getEnvelopes() { return envelopes; }
    public void setEnvelopes(List<Envelope> envelopes) { this.envelopes = envelopes; }

    public String getTimezone() { return timezone; }
    public void setTimezone(String timezone) { this.timezone = timezone; }

    public String getCurrencyCode() { return currencyCode; }
    public void setCurrencyCode(String currencyCode) { this.currencyCode = currencyCode; }
}===== ./src/main/java/org/emblow/envelopify/domain/ChatMessage.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;

@Entity
@Table(name = "chat_message")
public class ChatMessage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    private String role; // "user" or "assistant"

    @NotNull
    @Column(length = 7000) // Adjust based on token limit
    private String content;

 
    @Column(columnDefinition = "TEXT") // For chart JSON, no strict length limit
    private String chartData;
    
    @NotNull
    private LocalDateTime timestamp;

    @ManyToOne
    @NotNull
    private ChatSession session;

    // Constructors
    public ChatMessage() {}

    public ChatMessage(String role, String content) {
        this.role = role;
        this.content = content;
        this.timestamp = LocalDateTime.now();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getRole() { return role; }
    public void setRole(String role) { this.role = role; }

    public String getContent() { return content; }
    public void setContent(String content) { this.content = content; }

    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public ChatSession getSession() { return session; }
    public void setSession(ChatSession session) { this.session = session; }

    public int estimateTokens() {
        return content.length() / 4; // Rough estimate: 4 chars per token
    }
    public String getChartData() { return chartData; }
    public void setChartData(String chartData) { this.chartData = chartData; }

}
===== ./src/main/java/org/emblow/envelopify/domain/TransactionType.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
public enum TransactionType {
    INCOME, EXPENSE;
}===== ./src/main/java/org/emblow/envelopify/domain/BillReminder.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
public class BillReminder {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String description;
    
    @NotNull
    private BigDecimal amount;
    
    @NotNull
    @ManyToOne
    private Envelope envelope;
    
    @NotNull
    @ManyToOne
    private Account account;
    
    @NotNull
    private LocalDate dueDate;
    
    private int reminderDays = 7;
    private boolean paid = false;
    
    // Default constructor
    public BillReminder() {}
    
    // Full constructor
    public BillReminder(
        String description,
        BigDecimal amount,
        Envelope envelope,
        Account account,
        LocalDate dueDate,
        int reminderDays
    ) {
        this.description = description;
        this.amount = amount;
        this.envelope = envelope;
        this.account = account;
        this.dueDate = dueDate;
        this.reminderDays = reminderDays;
    }
    
    // Add account getter/setter
    public Account getAccount() { return account; }
    public void setAccount(Account account) { this.account = account; }
    
    // Existing methods...
    public boolean isOverdue() {
        return !paid && LocalDate.now().isAfter(dueDate);
    }
    
    public boolean needsReminder() {
        if (paid) return false;
        LocalDate reminderDate = dueDate.minusDays(reminderDays);
        return LocalDate.now().isAfter(reminderDate) && !isOverdue();
    }
    
    // Rest of existing getters/setters...
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public BigDecimal getAmount() { return amount; }
    public void setAmount(BigDecimal amount) { this.amount = amount; }
    
    public Envelope getEnvelope() { return envelope; }
    public void setEnvelope(Envelope envelope) { this.envelope = envelope; }
    
    public LocalDate getDueDate() { return dueDate; }
    public void setDueDate(LocalDate dueDate) { this.dueDate = dueDate; }
    
    public int getReminderDays() { return reminderDays; }
    public void setReminderDays(int reminderDays) { this.reminderDays = reminderDays; }
    
    public boolean isPaid() { return paid; }
    public void setPaid(boolean paid) { this.paid = paid; }
}===== ./src/main/java/org/emblow/envelopify/domain/ChartArtifact.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;

@Entity
@Table(name = "chart_artifact")
public class ChartArtifact {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    @Column(columnDefinition = "TEXT")
    private String chartData;  // JSON string of the chart data

    @NotNull
    @ManyToOne
    private ChatSession session;  // Link to the chat session that created it

    @NotNull
    private LocalDateTime createdAt;

    private String title;  // Optional title for the chart

    private String description;  // Optional description

    // Constructors
    public ChartArtifact() {}

    public ChartArtifact(String chartData, ChatSession session) {
        this.chartData = chartData;
        this.session = session;
        this.createdAt = LocalDateTime.now();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getChartData() { return chartData; }
    public void setChartData(String chartData) { this.chartData = chartData; }

    public ChatSession getSession() { return session; }
    public void setSession(ChatSession session) { this.session = session; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
}===== ./src/main/java/org/emblow/envelopify/domain/InsufficientFundsException.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import java.math.BigDecimal;

public class InsufficientFundsException extends RuntimeException {
    public InsufficientFundsException(String envelopeName, BigDecimal amount) {
        super("Insufficient funds in envelope '" + envelopeName + 
              "' for amount: " + amount);
    }
}===== ./src/main/java/org/emblow/envelopify/domain/Transaction.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
public class Transaction {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    private LocalDateTime date;

    @NotNull
    private String description;

    @NotNull
    private BigDecimal amount;

    @ManyToOne
    @NotNull
    private Envelope envelope;

    @ManyToOne
    @NotNull
    private Account account;
 
    @NotNull
    @Enumerated(EnumType.STRING)
    private TransactionType type;
    
    // Default constructor for JPA
    public Transaction() {}

   public Transaction(LocalDateTime date, String description, BigDecimal amount, 
                       Envelope envelope, Account account, TransactionType type) {
        this.date = date;
        this.description = description;
        this.amount = amount;
        this.envelope = envelope;
        this.account = account;
        this.type = type;
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDate() { return date; }
    public void setDate(LocalDateTime date) { this.date = date; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public BigDecimal getAmount() { return amount; }
    public void setAmount(BigDecimal amount) { this.amount = amount; }

    public Envelope getEnvelope() { return envelope; }
    public void setEnvelope(Envelope envelope) { this.envelope = envelope; }

    // Helper method to get the category name (which is the envelope name)
    public String getCategory() {
        return envelope != null ? envelope.getName() : null;
    }
    public Account getAccount() { return account; }
    public void setAccount(Account account) { this.account = account; }
    public TransactionType getType() {
        return type;
    }
    public void setType(TransactionType type) {
        this.type = type;
    }

    @Override
    public String toString() {
        return "Transaction{" +
                "id=" + id +
                ", type="+type +
                ", date=" + date +
                ", description='" + description + '\'' +
                ", amount=" + amount +
                ", envelope=" + (envelope != null ? envelope.getName() : "null") +
                '}';
    }
}===== ./src/main/java/org/emblow/envelopify/domain/Setting.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;

@Entity
@Table(name = "app_setting")
public class Setting {
    @Id
    @Column(name = "setting_key")  // Avoid using reserved word 'key'
    private String key;
    
    @NotNull
    @Column(name = "setting_value", length = 1000)
    private String value;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "setting_type")  // More explicit column naming
    private SettingType type;
    
    @Column(length = 500)  // Set appropriate length for description
    private String description;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "setting_category")  // More explicit column naming
    private SettingCategory category = SettingCategory.GENERAL;

    
    public enum SettingType {
        STRING,
        PASSWORD,
        NUMBER,
        BOOLEAN,
        URL
    }
    
    public enum SettingCategory {
        GENERAL,
        LLM,
        APPEARANCE,
        SECURITY,
        INTEGRATION
    }
    
    // Constructors
    public Setting() {}
    
    public Setting(String key, String value, SettingType type, SettingCategory category) {
        this.key = key;
        this.value = value;
        this.type = type;
        this.category = category;
    }
    
    public Setting(String key, String value, SettingType type, SettingCategory category, String description) {
        this(key, value, type, category);
        this.description = description;
    }
    
    // Getters and Setters
    public String getKey() { return key; }
    public void setKey(String key) { this.key = key; }
    
    public String getValue() { return value; }
    public void setValue(String value) { this.value = value; }
    
    public SettingType getType() { return type; }
    public void setType(SettingType type) { this.type = type; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public SettingCategory getCategory() { return category; }
    public void setCategory(SettingCategory category) { this.category = category; }
}===== ./src/main/java/org/emblow/envelopify/domain/Envelope.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
public class Envelope {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String name;
    
    @NotNull
    private BigDecimal allocated = BigDecimal.ZERO;
    
    @NotNull
    private BigDecimal spent = BigDecimal.ZERO;
    
    @OneToMany(mappedBy = "envelope")
    private List<Transaction> transactions;

    @ManyToOne
    @NotNull
    private User owner;
        
    @NotNull
    private BigDecimal monthlyBudget = BigDecimal.ZERO;
    
    private LocalDate budgetResetDate = LocalDate.now().withDayOfMonth(1);
    
    @OneToMany(mappedBy = "envelope", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<RecurringTransaction> recurringTransactions = new ArrayList<>();
    
    @OneToMany(mappedBy = "envelope", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<BillReminder> billReminders = new ArrayList<>();
    
    // Constructors
    public Envelope() {}
    
    public Envelope(String name, BigDecimal allocated, User owner) {
        this.name = name;
        this.allocated = allocated;
        this.owner = owner;
    }
    
    // Smart methods
    public boolean canSpend(BigDecimal amount) {
        return getAvailable().compareTo(amount) >= 0;
    }
    
    
    public BigDecimal getAvailable() {
        return allocated.subtract(spent);
    }
    
    public void spend(BigDecimal amount) {
        if (!canSpend(amount)) {
            throw new InsufficientFundsException(name, amount);
        }
        spent = spent.add(amount);
    }
    
    public void unspend(BigDecimal amount) {
        if (!canSpend(amount)) {
            throw new InsufficientFundsException(name, amount);
        }
        spent = spent.subtract(amount);
    }
    
    public void unallocate(BigDecimal amount) {
        this.allocated = this.allocated.subtract(amount);
    }
    
    public void allocate(BigDecimal amount) {
        this.allocated = this.allocated.add(amount);
    }
    
    public void withdraw(BigDecimal amount) {
        if (amount.compareTo(getAvailable()) > 0) {
            throw new InsufficientFundsException(name, amount);
        }
        this.allocated = this.allocated.subtract(amount);
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public BigDecimal getAllocated() { return allocated; }
    public BigDecimal getSpent() { return spent; }
    public List<Transaction> getTransactions() { return transactions; }
    public void setTransactions(List<Transaction> transactions) { 
        this.transactions = transactions; 
    }
    
    public double getSpentPercentage() {
        if (allocated.compareTo(BigDecimal.ZERO) == 0) return 0.0;
        return spent.divide(allocated, 4, BigDecimal.ROUND_HALF_UP)
                   .multiply(BigDecimal.valueOf(100))
                   .doubleValue();
    }
    
    public void setMonthlyBudget(BigDecimal amount) {
        this.monthlyBudget = amount;
    }
    
    public BigDecimal getMonthlyBudget() {
        return monthlyBudget;
    }
    
    public double getBudgetUtilization() {
        if (monthlyBudget.compareTo(BigDecimal.ZERO) == 0) return 0.0;
        return getCurrentMonthSpent()
            .divide(monthlyBudget, 4, RoundingMode.HALF_UP)
            .doubleValue();
    }
    
    public BigDecimal getCurrentMonthSpent() {
        return transactions.stream()
            .filter(tx -> tx.getDate().isAfter(budgetResetDate.atStartOfDay()))
            .map(Transaction::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    public BigDecimal getRemainingBudget() {
        return monthlyBudget.subtract(getCurrentMonthSpent());
    }  
    
    @OneToOne(mappedBy = "envelope")
    private Category category;
    
    // Add getter/setter
    public Category getCategory() { return category; }
    public void setCategory(Category category) { this.category = category; }
    
    public User getOwner() { return owner; }
    public void setOwner(User owner) { this.owner = owner; }

}===== ./src/main/java/org/emblow/envelopify/domain/Pattern.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Enumerated;
import jakarta.persistence.EnumType;
import jakarta.validation.constraints.NotNull;

@Entity
public class Pattern {
    @Id 
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String pattern;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    private PatternType type;
    
    @ManyToOne
    @NotNull
    private Category category;
    
    private Double confidence;
    
    @NotNull
    private Integer matchCount = 0;
    
    @NotNull
    private Double accuracy = 1.0;
    
    public enum PatternType {
        MERCHANT("Merchant name pattern"),
        TEMPORAL("Timing pattern"),
        AMOUNT("Amount pattern");
        
        private final String description;
        
        PatternType(String description) {
            this.description = description;
        }
        
        public String getDescription() {
            return description;
        }
    }
    
    // Constructors
    public Pattern() {}
    
    public Pattern(String pattern, PatternType type, Category category) {
        this.pattern = pattern;
        this.type = type;
        this.category = category;
        this.confidence = 1.0;
    }
    
    // Business methods
    public void incrementMatch(boolean wasAccurate) {
        matchCount++;
        if (wasAccurate) {
            // Weighted moving average for accuracy
            accuracy = (accuracy * (matchCount - 1) + 1.0) / matchCount;
        } else {
            accuracy = (accuracy * (matchCount - 1)) / matchCount;
        }
        // Update confidence based on matches and accuracy
        confidence = (1.0 - (1.0 / matchCount)) * accuracy;
    }
    
    public boolean appliesTo(Transaction transaction) {
        return switch (type) {
            case MERCHANT -> matchesMerchant(transaction.getDescription());
            case TEMPORAL -> matchesTiming(transaction.getDate());
            case AMOUNT -> matchesAmount(transaction.getAmount());
        };
    }
    
    private boolean matchesMerchant(String description) {
        return description.toLowerCase().contains(pattern.toLowerCase());
    }
    
    private boolean matchesTiming(java.time.LocalDateTime date) {
        try {
            // Pattern format: DOW:HH or DOM:HH
            String[] parts = pattern.split(":");
            if (parts[0].startsWith("DOW")) {
                int dayOfWeek = Integer.parseInt(parts[0].substring(3));
                return date.getDayOfWeek().getValue() == dayOfWeek;
            } else if (parts[0].startsWith("DOM")) {
                int dayOfMonth = Integer.parseInt(parts[0].substring(3));
                return date.getDayOfMonth() == dayOfMonth;
            }
            return false;
        } catch (NumberFormatException e) {
            return false;
        }
    }
    
    private boolean matchesAmount(java.math.BigDecimal amount) {
        try {
            // Pattern format: [operator][amount], e.g. >100 or =50.00
            char operator = pattern.charAt(0);
            double value = Double.parseDouble(pattern.substring(1));
            double txAmount = amount.doubleValue();
            
            return switch (operator) {
                case '>' -> txAmount > value;
                case '<' -> txAmount < value;
                case '=' -> Math.abs(txAmount - value) < 0.01;
                default -> false;
            };
        } catch (NumberFormatException e) {
            return false;
        }
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getPattern() { return pattern; }
    public void setPattern(String pattern) { this.pattern = pattern; }
    
    public PatternType getType() { return type; }
    public void setType(PatternType type) { this.type = type; }
    
    public Category getCategory() { return category; }
    public void setCategory(Category category) { this.category = category; }
    
    public Double getConfidence() { return confidence; }
    public void setConfidence(Double confidence) { this.confidence = confidence; }
    
    public Integer getMatchCount() { return matchCount; }
    public void setMatchCount(Integer matchCount) { this.matchCount = matchCount; }
    
    public Double getAccuracy() { return accuracy; }
    public void setAccuracy(Double accuracy) { this.accuracy = accuracy; }
}===== ./src/main/java/org/emblow/envelopify/exception/AccountException.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.exception;

public class AccountException extends BusinessException {
    public static final String ACCOUNT_NOT_FOUND = "ACCOUNT_NOT_FOUND";
    public static final String INSUFFICIENT_BALANCE = "INSUFFICIENT_BALANCE";
    public static final String DUPLICATE_ACCOUNT = "DUPLICATE_ACCOUNT";
    
    public AccountException(String code, String message) {
        super(code, message);
    }
}===== ./src/main/java/org/emblow/envelopify/exception/EnvelopeException.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.exception;

public class EnvelopeException extends BusinessException {
    public static final String INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS";
    public static final String INVALID_ALLOCATION = "INVALID_ALLOCATION";
    public static final String ENVELOPE_NOT_FOUND = "ENVELOPE_NOT_FOUND";
    
    public EnvelopeException(String code, String message) {
        super(code, message);
    }
}===== ./src/main/java/org/emblow/envelopify/exception/BusinessException.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.exception;

import java.util.Collections;

public class BusinessException extends BaseException {
    public BusinessException(String code, String message) {
        super(code, message, Collections.emptyMap());
    }
}===== ./src/main/java/org/emblow/envelopify/exception/ErrorResponse.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.exception;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.Map;

public class ErrorResponse {
    private final String code;
    private final String message;
    private final LocalDateTime timestamp;
    private final Map<String, Object> details;

    public ErrorResponse(String code, String message) {
        this(code, message, Collections.emptyMap());
    }

    public ErrorResponse(String code, String message, Map<String, Object> details) {
        this.code = code;
        this.message = message;
        this.timestamp = LocalDateTime.now();
        this.details = details;
    }

    // Getters
    public String getCode() { return code; }
    public String getMessage() { return message; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public Map<String, Object> getDetails() { return details; }
}===== ./src/main/java/org/emblow/envelopify/exception/BaseException.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.exception;


import java.util.Map;

public abstract class BaseException extends RuntimeException {
    private final String code;
    private final String message;
    private final Map<String, Object> details;

    protected BaseException(String code, String message, Map<String, Object> details) {
        super(message);
        this.code = code;
        this.message = message;
        this.details = details;
    }

    public String getCode() { return code; }
    @Override
    public String getMessage() { return message; }
    public Map<String, Object> getDetails() { return details; }
}
===== ./src/main/java/org/emblow/envelopify/exception/ValidationException.java =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.exception;

import java.util.Collections;
import java.util.Map;

public class ValidationException extends BaseException {
    public ValidationException(Map<String, String> violations) {
        super("VALIDATION_ERROR", "Validation failed", Collections.singletonMap("violations", violations));
    }
}===== src/main/resources/application.properties =====
# Application
spring.application.name=Envelopify
server.port=8081

# Database
spring.datasource.url=jdbc:h2:file:./envelopifydb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

# JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.generate-ddl=true
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.defer-datasource-initialization=true
spring.jpa.properties.hibernate.id.new_generator_mappings=true
spring.jpa.properties.hibernate.physical_naming_strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# Initialize schema
spring.sql.init.mode=always
spring.sql.init.schema-locations=classpath:schema.sql

# H2 Console
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
spring.h2.console.settings.web-allow-others=false

# Logging
logging.level.org.emblow.envelopify=DEBUG
logging.level.org.springframework.security=DEBUG
logging.level.com.vaadin=DEBUG
logging.level.org.atmosphere=DEBUG

# Vaadin
vaadin.urlMapping=/*
vaadin.whitelisted-packages=org.emblow.envelopify,com.vaadin,org.vaadin
vaadin.pnpm.enable=true
vaadin.productionMode=false
# Disable dev server and hot-deploy features
vaadin.useDevServer=false
# vaadin.frontend.hotdeploy and vaadin.devmode.transpile are no longer needed
vaadin.connect.javaEnabled=true
vaadin.compatibilityMode=false
vaadin.original.frontend.resources=true
# Adjusted exclude URLs \u2013 note that we no longer exclude the entire /VAADIN/** path
vaadin.exclude-urls=/icons/**,/images/**,/*.txt,/h2-console/**
vaadin.async-supported=true
vaadin.heartbeatInterval=300
vaadin.closeIdleSessions=false
# Disable live reload since we are not using a dev server
vaadin.devmode.liveReload.enabled=false
spring.mustache.check-template-location=false

# Spring Security
spring.security.user.name=user
spring.security.user.password=password
security.basic.enabled=false
spring.security.csrf.disabled=true

# Session Configuration
server.servlet.session.timeout=30m
server.servlet.session.cookie.http-only=true
server.servlet.session.cookie.secure=false
server.servlet.session.tracking-modes=cookie

# Server Configuration
server.compression.enabled=true
server.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain,application/javascript,text/css
server.compression.min-response-size=1024

# Dev Tools
spring.devtools.restart.enabled=true
spring.devtools.livereload.enabled=true
spring.devtools.restart.poll-interval=2s
spring.devtools.restart.quiet-period=1s

# Actuator
management.endpoints.web.exposure.include=refresh,health,info
management.endpoint.health.show-details=always

# Headers
server.forward-headers-strategy=FRAMEWORK

# Error Handling
server.error.include-message=always
server.error.include-binding-errors=always
server.error.include-stacktrace=never
server.error.include-exception=false

# MIME Type Configuration
spring.web.resources.chain.strategy.content.enabled=true
spring.web.resources.chain.strategy.content.paths=/**
spring.mvc.contentnegotiation.favor-parameter=true
spring.mvc.contentnegotiation.media-types.js=application/javascript
spring.mvc.contentnegotiation.media-types.ts=application/typescript
spring.mvc.contentnegotiation.media-types.json=application/json
===== src/main/resources/schema.sql =====
/* 
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * Author:  Nicholas J Emblow
 * Created: 12 Feb 2025
 */

CREATE TABLE IF NOT EXISTS app_setting (
    setting_key VARCHAR(255) PRIMARY KEY,
    setting_value VARCHAR(1000),
    setting_type VARCHAR(50),
    setting_category VARCHAR(50),
    description VARCHAR(500)
);

CREATE TABLE IF NOT EXISTS chat_session (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    owner_id BIGINT NOT NULL,
    created_at TIMESTAMP NOT NULL,
    FOREIGN KEY (owner_id) REFERENCES app_user(id)
);

CREATE TABLE IF NOT EXISTS chat_message (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    role VARCHAR(50) NOT NULL,
    content VARCHAR(4000) NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    session_id BIGINT NOT NULL,
    FOREIGN KEY (session_id) REFERENCES chat_session(id)
);===== frontend/data-table.js =====
/* 
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


export default class DataTable extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
    }

    connectedCallback() {
        this._updateTable();
    }

    _updateTable() {
        try {
            const headers = JSON.parse(this.headers || '[]');
            const rows = JSON.parse(this.rows || '[]');
            
            // Create table element
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.style.marginBottom = '1rem';
            
            // Add headers
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                th.style.padding = '0.75rem';
                th.style.borderBottom = '2px solid var(--lumo-contrast-10pct)';
                th.style.textAlign = 'left';
                th.style.fontWeight = 'bold';
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Add data rows
            const tbody = document.createElement('tbody');
            rows.forEach(row => {
                const tr = document.createElement('tr');
                row.forEach(cell => {
                    const td = document.createElement('td');
                    td.textContent = cell;
                    td.style.padding = '0.75rem';
                    td.style.borderBottom = '1px solid var(--lumo-contrast-10pct)';
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            
            // Clear and update shadow root
            while (this.shadowRoot.firstChild) {
                this.shadowRoot.removeChild(this.shadowRoot.firstChild);
            }
            this.shadowRoot.appendChild(table);
            
        } catch (e) {
            console.error('Error updating table:', e);
        }
    }

    set headers(value) {
        this._headers = value;
        this._updateTable();
    }

    get headers() {
        return this._headers;
    }

    set rows(value) {
        this._rows = value;
        this._updateTable();
    }

    get rows() {
        return this._rows;
    }
}

customElements.define('data-table', DataTable);===== frontend/index.html =====
<!DOCTYPE html>
<!--
This file is auto-generated by Vaadin.
-->

<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.js"></script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body, #outlet {
      height: 100vh;
      width: 100%;
      margin: 0;
    }
  </style>
  <!-- index.ts is included here automatically (either by the dev server or during the build) -->
</head>
<body>
  <!-- This outlet div is where the views are rendered -->
  <div id="outlet"></div>
</body>
</html>
===== frontend/account-balance-chart.js =====
/* 
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


// account-balance-chart.js
import * as echarts from 'echarts';

export default class AccountBalanceChart extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.chart = null;
  }

  connectedCallback() {
    const chartDiv = document.createElement('div');
    chartDiv.style.width = '100%';
    chartDiv.style.height = '100%';
    this.shadowRoot.appendChild(chartDiv);
    this.chart = echarts.init(chartDiv);
    this._updateChart();
  }

  disconnectedCallback() {
    if (this.chart) {
      this.chart.dispose();
      this.chart = null;
    }
  }

  _updateChart() {
    if (!this.chart) return;
    try {
      const labels = JSON.parse(this.labels || '[]');
      const data = JSON.parse(this.data || '[]');
      
      const option = {
        tooltip: {
          trigger: 'axis'
        },
        xAxis: {
          type: 'category',
          data: labels
        },
        yAxis: {
          type: 'value',
          axisLabel: {
            formatter: '${value}'
          }
        },
        series: [{
          name: 'Account Balance',
          data: data,
          type: 'line',
          smooth: true,
          lineStyle: {
            color: '#007bff'
          },
          areaStyle: {
            color: 'rgba(0, 123, 255, 0.1)'
          }
        }]
      };
      this.chart.setOption(option);
    } catch (e) {
      console.error('Error updating chart:', e);
    }
  }

  set labels(value) {
    this._labels = value;
    this._updateChart();
  }

  get labels() {
    return this._labels;
  }

  set data(value) {
    this._data = value;
    this._updateChart();
  }

  get data() {
    return this._data;
  }
}

customElements.define('account-balance-chart', AccountBalanceChart);

===== frontend/unusual-spending-chart.js =====
/* 
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


import * as echarts from 'echarts';

// Export the module directly without using customElements.define
export default class UnusualSpendingChart extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.chart = null;
    }

    connectedCallback() {
        const chartDiv = document.createElement('div');
        chartDiv.style.width = '100%';
        chartDiv.style.height = '100%';
        this.shadowRoot.appendChild(chartDiv);
        
        this.chart = echarts.init(chartDiv);
        this._updateChart();
    }

    disconnectedCallback() {
        if (this.chart) {
            this.chart.dispose();
            this.chart = null;
        }
    }

    _updateChart() {
        if (!this.chart) return;

        try {
            const labels = JSON.parse(this.labels || '[]');
            const data = JSON.parse(this.data || '[]');

            const option = {
                tooltip: {
                    trigger: 'axis'
                },
                xAxis: {
                    type: 'category',
                    data: labels
                },
                yAxis: {
                    type: 'value',
                    name: 'Confidence (%)',
                    max: 100
                },
                series: [{
                    type: 'bar',
                    data: data,
                    itemStyle: {
                        color: '#f56c6c'
                    }
                }]
            };
            
            this.chart.setOption(option);
        } catch (e) {
            console.error('Error updating chart:', e);
        }
    }

    set labels(value) {
        this._labels = value;
        this._updateChart();
    }

    get labels() {
        return this._labels;
    }

    set data(value) {
        this._data = value;
        this._updateChart();
    }

    get data() {
        return this._data;
    }
}
customElements.define('unusual-spending-chart', UnusualSpendingChart);
===== frontend/spending-trends-chart-accounts.js =====
/* 
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


import { LitElement, html } from 'lit-element';
import * as echarts from 'echarts';

class SpendingTrendsChart_Accounts extends LitElement {
    static get properties() {
        return {
            chartData: { type: Object }
        };
    }

    constructor() {
        super();
        this.chart = null;
        this.chartDiv = null;
    }

    render() {
        return html`<div style="width: 100%; height: 100%;"></div>`;
    }

    firstUpdated() {
        this.chartDiv = this.shadowRoot.querySelector('div');
        this.chart = echarts.init(this.chartDiv);
        console.log('SpendingTrendsChart_Accounts - firstUpdated, chartData:', this.chartData);
        this._updateChart();
    }

    updated(changedProperties) {
        if (changedProperties.has('chartData') && this.chart) {
            console.log('SpendingTrendsChart_Accounts - updated, chartData:', this.chartData);
            this._updateChart();
        }
    }

    disconnectedCallback() {
        if (this.chart) {
            this.chart.dispose();
            this.chart = null;
        }
        super.disconnectedCallback();
    }

    _updateChart() {
        if (!this.chart || !this.chartData) {
            console.log('SpendingTrendsChart_Accounts - Skipping update: chart or chartData not ready', {
                chart: !!this.chart,
                chartData: this.chartData
            });
            return;
        }

        // Handle case where chartData is a JSON string
        let data = this.chartData;
        if (typeof this.chartData === 'string') {
            try {
                data = JSON.parse(this.chartData);
                console.log('SpendingTrendsChart_Accounts - Parsed string chartData:', data);
            } catch (e) {
                console.error('SpendingTrendsChart_Accounts - Failed to parse chartData string:', this.chartData, e);
                return;
            }
        }

        if (!data.datasets || !Array.isArray(data.datasets) || data.datasets.length === 0) {
            console.error('SpendingTrendsChart_Accounts - Invalid chartData: datasets issue', {
                hasDatasets: !!data.datasets,
                isArray: Array.isArray(data.datasets),
                length: data.datasets ? data.datasets.length : 'N/A',
                chartData: data
            });
            return;
        }

        const labels = data.labels || [];
        const series = data.datasets.map(dataset => {
            if (!dataset.data || !dataset.label) {
                console.warn('SpendingTrendsChart_Accounts - Dataset missing required fields', dataset);
            }
            return {
                name: dataset.label || 'Unnamed Series',
                type: 'line',
                data: dataset.data || []
            };
        });

        if (labels.length === 0 || series.every(s => s.data.length === 0)) {
            console.warn('SpendingTrendsChart_Accounts - No data to display', { labels, series });
            return;
        }

        const option = {
            tooltip: {
                trigger: 'axis',
                formatter: function(params) {
                    let result = params[0].name + '<br/>';
                    params.forEach(param => {
                        const value = new Intl.NumberFormat('en-US', {
                            style: 'currency',
                            currency: 'USD'
                        }).format(param.value || 0);
                        result += param.marker + param.seriesName + ': ' + value + '<br/>';
                    });
                    return result;
                }
            },
            xAxis: {
                type: 'category',
                data: labels
            },
            yAxis: {
                type: 'value',
                axisLabel: {
                    formatter: function(value) {
                        return new Intl.NumberFormat('en-US', {
                            style: 'currency',
                            currency: 'USD',
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 0
                        }).format(value);
                    }
                }
            },
            series: series
        };

        this.chart.setOption(option);
    }
}

customElements.define('spending-trends-chart-accounts', SpendingTrendsChart_Accounts);===== frontend/spending-trends-chart.js =====
/* 
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


import * as echarts from 'echarts';

export default class SpendingTrendsChart extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.chart = null;
    }

    connectedCallback() {
        const chartDiv = document.createElement('div');
        chartDiv.style.width = '100%';
        chartDiv.style.height = '100%';
        this.shadowRoot.appendChild(chartDiv);
        
        this.chart = echarts.init(chartDiv);
        this._updateChart();
    }

    disconnectedCallback() {
        if (this.chart) {
            this.chart.dispose();
            this.chart = null;
        }
    }

    _updateChart() {
        if (!this.chart) return;

        try {
            const labels = JSON.parse(this.labels || '[]');
            const series = JSON.parse(this.series || '[]');

            const option = {
                tooltip: {
                    trigger: 'axis'
                },
                legend: {
                    data: series.map(s => s.name),
                    top: 'top'
                },
                xAxis: {
                    type: 'category',
                    data: labels
                },
                yAxis: {
                    type: 'value',
                    axisLabel: {
                        formatter: '${value}'
                    }
                },
                series: series.map(s => ({
                    ...s,
                    type: 'bar',
                    stack: 'total'
                }))
            };
            
            this.chart.setOption(option);
        } catch (e) {
            console.error('Error updating chart:', e);
        }
    }

    set labels(value) {
        this._labels = value;
        this._updateChart();
    }

    get labels() {
        return this._labels;
    }

    set series(value) {
        this._series = value;
        this._updateChart();
    }

    get series() {
        return this._series;
    }
}
customElements.define('spending-trends-chart', SpendingTrendsChart);
===== frontend/ml-spending-prediction-chart.js =====
/* 
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


import * as echarts from 'echarts';

export default class MLSpendingPredictionChart extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.chart = null;
    }

    connectedCallback() {
        const chartDiv = document.createElement('div');
        chartDiv.style.width = '100%';
        chartDiv.style.height = '100%';
        this.shadowRoot.appendChild(chartDiv);
        
        this.chart = echarts.init(chartDiv);
        this._updateChart();
    }

    disconnectedCallback() {
        if (this.chart) {
            this.chart.dispose();
            this.chart = null;
        }
    }

    _updateChart() {
        if (!this.chart) return;

        try {
            const labels = JSON.parse(this.labels || '[]');
            const data = JSON.parse(this.data || '[]');

            const option = {
                tooltip: {
                    trigger: 'axis'
                },
                xAxis: {
                    type: 'category',
                    data: labels
                },
                yAxis: {
                    type: 'value',
                    axisLabel: {
                        formatter: '${value}'
                    }
                },
                series: [{
                    data: data,
                    type: 'line',
                    smooth: true,
                    areaStyle: {},
                    itemStyle: {
                        color: '#409EFF'
                    }
                }]
            };
            
            this.chart.setOption(option);
        } catch (e) {
            console.error('Error updating chart:', e);
        }
    }

    set labels(value) {
        this._labels = value;
        this._updateChart();
    }

    get labels() {
        return this._labels;
    }

    set data(value) {
        this._data = value;
        this._updateChart();
    }

    get data() {
        return this._data;
    }
}

customElements.define('ml-spending-prediction-chart', MLSpendingPredictionChart);
===== frontend/spending-category-chart.js =====
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import { LitElement, html } from 'lit-element';
import * as echarts from 'echarts';

class SpendingCategoryChart extends LitElement {
    static get properties() {
        return {
            chartData: { type: Object }
        };
    }

    constructor() {
        super();
        this.chart = null;
    }

    render() {
        return html`<div style="width: 100%; height: 100%;"></div>`;
    }

    firstUpdated() {
        const chartDiv = this.shadowRoot.querySelector('div');
        this.chart = echarts.init(chartDiv);
        console.log('SpendingCategoryChart - firstUpdated, chartData:', this.chartData);
        this._updateChart();
    }

    updated(changedProperties) {
        if (changedProperties.has('chartData') && this.chart) {
            console.log('SpendingCategoryChart - updated, chartData:', this.chartData);
            this._updateChart();
        }
    }

    disconnectedCallback() {
        if (this.chart) {
            this.chart.dispose();
            this.chart = null;
        }
        super.disconnectedCallback();
    }

    _updateChart() {
        if (!this.chart || !this.chartData) {
            console.log('SpendingCategoryChart - Skipping update: chart or chartData not ready', {
                chart: !!this.chart,
                chartData: this.chartData
            });
            return;
        }

        // Handle case where chartData is a JSON string
        let data = this.chartData;
        if (typeof this.chartData === 'string') {
            try {
                data = JSON.parse(this.chartData);
                console.log('SpendingCategoryChart - Parsed string chartData:', data);
            } catch (e) {
                console.error('SpendingCategoryChart - Failed to parse chartData string:', this.chartData, e);
                return;
            }
        }

        if (!data.datasets || !Array.isArray(data.datasets) || data.datasets.length === 0) {
            console.error('SpendingCategoryChart - Invalid chartData: datasets issue', {
                hasDatasets: !!data.datasets,
                isArray: Array.isArray(data.datasets),
                length: data.datasets ? data.datasets.length : 'N/A',
                chartData: data
            });
            return;
        }

        const labels = data.labels || [];
        const dataset = data.datasets[0] || {};
        const values = dataset.data || [];
        const colors = dataset.backgroundColor || [];

        if (labels.length === 0 || values.length === 0) {
            console.warn('SpendingCategoryChart - No data to display', { labels, values });
            return;
        }

        const pieData = labels.map((label, index) => ({
            name: label,
            value: values[index] || 0
        }));

        const option = {
            tooltip: {
                trigger: 'item',
                formatter: function(params) {
                    const value = params.value || 0;
                    const formattedValue = new Intl.NumberFormat('en-US', {
                        style: 'currency',
                        currency: 'USD'
                    }).format(value);
                    return `${params.name}: ${formattedValue}`;
                }
            },
            legend: {
                orient: 'vertical',
                left: 'right'
            },
            series: [{
                type: 'pie',
                data: pieData,
                color: colors
            }]
        };

        this.chart.setOption(option);
    }
}

customElements.define('spending-category-chart', SpendingCategoryChart);