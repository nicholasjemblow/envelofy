
=== ./src/main/java/org/emblow/envelopify/ui/components/InsightsPanel.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import org.emblow.envelopify.service.ml.SpendingInsight;
import org.emblow.envelopify.service.ml.SpendingInsightType;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class InsightsPanel extends VerticalLayout {
    
    public InsightsPanel() {
        addClassName("insights-panel");
        setSpacing(true);
        setPadding(true);
        
        getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("box-shadow", "var(--lumo-box-shadow-s)");
    }
    
    public void setInsights(List<SpendingInsight> insights) {
        removeAll();
        
        add(new H3("Smart Insights"));
        
        if (insights.isEmpty()) {
            add(new Span("No insights available yet. Add more transactions to get personalized insights."));
            return;
        }

        // Group insights by type
        Map<SpendingInsightType, List<SpendingInsight>> groupedInsights = insights.stream()
            .collect(Collectors.groupingBy(SpendingInsight::getType));

        // Add insights by type in a specific order
        addInsightGroup(groupedInsights, SpendingInsightType.UNUSUAL_SPENDING, 
            VaadinIcon.EXCLAMATION_CIRCLE, "var(--lumo-error-color)");
        addInsightGroup(groupedInsights, SpendingInsightType.RECURRING_PAYMENT, 
            VaadinIcon.CLOCK, "var(--lumo-primary-color)");
        addInsightGroup(groupedInsights, SpendingInsightType.PREDICTED_EXPENSE, 
            VaadinIcon.CHART_TIMELINE, "var(--lumo-success-color)");
        addInsightGroup(groupedInsights, SpendingInsightType.BUDGET_SUGGESTION, 
            VaadinIcon.PIGGY_BANK, "var(--lumo-primary-color)");
        addInsightGroup(groupedInsights, SpendingInsightType.SEASONAL_PATTERN, 
            VaadinIcon.CALENDAR, "var(--lumo-contrast-color)");
        addInsightGroup(groupedInsights, SpendingInsightType.REALLOCATION_SUGGESTION, 
            VaadinIcon.EXCHANGE, "var(--lumo-primary-color)");
    }
    
    private void addInsightGroup(
        Map<SpendingInsightType, List<SpendingInsight>> groupedInsights,
        SpendingInsightType type,
        VaadinIcon icon,
        String color
    ) {
        List<SpendingInsight> insights = groupedInsights.get(type);
        if (insights != null && !insights.isEmpty()) {
            insights.forEach(insight -> {
                Div card = createInsightCard(insight, icon, color);
                add(card);
            });
        }
    }
    
    private Div createInsightCard(SpendingInsight insight, VaadinIcon iconType, String color) {
        Div card = new Div();
        card.addClassName("insight-card");
        card.getStyle()
            .set("padding", "var(--lumo-space-m)")
            .set("border-radius", "var(--lumo-border-radius-m)")
            .set("background-color", "var(--lumo-base-color)")
            .set("border-left", "4px solid " + color)
            .set("margin-bottom", "var(--lumo-space-m)")
            .set("box-shadow", "var(--lumo-box-shadow-xs)");
        
        Icon icon = iconType.create();
        icon.setColor(color);
        icon.getStyle().set("margin-right", "var(--lumo-space-s)");
        
        Span message = new Span(insight.getMessage());
        message.getStyle()
            .set("color", "var(--lumo-body-text-color)")
            .set("font-size", "var(--lumo-font-size-s)");
        
        Div confidenceIndicator = new Div();
        confidenceIndicator.getStyle()
            .set("height", "4px")
            .set("background-color", color)
            .set("margin-top", "var(--lumo-space-s)")
            .set("border-radius", "var(--lumo-border-radius-s)")
            .set("opacity", String.valueOf(insight.getConfidence()));
        
        card.add(icon, message, confidenceIndicator);
        return card;
    }
}



=== ./src/main/java/org/emblow/envelopify/ui/components/CSVImportDialog.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Paragraph;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.upload.Upload;
import com.vaadin.flow.component.upload.receivers.MemoryBuffer;
import com.vaadin.flow.component.textfield.NumberField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.select.Select;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.service.CSVImportService;
import org.emblow.envelopify.service.CSVImportService.CSVMapping;
import org.emblow.envelopify.service.EnvelopeService;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.AccountService;



public class CSVImportDialog extends Dialog {
    private final CSVImportService csvImportService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final Runnable onSuccess;

    private final MemoryBuffer buffer;
    private final Upload upload;
    private final ComboBox<Envelope> defaultEnvelopeField;
    private final ComboBox<Account> accountField;
    private final Select<String> presetMappingField;
    private final TextField delimiterField;
    private final NumberField dateColumnField;
    private final TextField dateFormatField;
    private final NumberField descriptionColumnField;
    private final NumberField amountColumnField;
    private final NumberField amountMultiplierField;

    public CSVImportDialog(
        CSVImportService csvImportService,
        EnvelopeService envelopeService,
        AccountService accountService,
        Runnable onSuccess
    ) {
        this.csvImportService = csvImportService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.onSuccess = onSuccess;

        setModal(true);
        setDraggable(true);
        setResizable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);

        // Title
        H3 title = new H3("Import Transactions from CSV");
        layout.add(title);

        // File upload
        buffer = new MemoryBuffer();
        upload = new Upload(buffer);
        upload.setAcceptedFileTypes(".csv");
        upload.addSucceededListener(event -> {
            Notification.show(
                "File uploaded successfully: " + event.getFileName(),
                3000,
                Notification.Position.MIDDLE
            );
        });
        layout.add(upload);

        // Account selection
        accountField = new ComboBox<>("Account");
        accountField.setItemLabelGenerator(account -> 
            String.format("%s (%s)", 
                account.getName(),
                account.getType().getDisplayName()
            )
        );
        accountField.setItems(accountService.getAllAccounts());
        accountField.setRequired(true);
        accountField.setWidthFull();
        layout.add(accountField);

        // Preset mappings dropdown
        presetMappingField = new Select<>();
        presetMappingField.setLabel("Preset Format");
        presetMappingField.setItems("Custom", "Chase", "Bank of America");
        presetMappingField.setValue("Custom");
        presetMappingField.addValueChangeListener(e -> updateMappingFields(e.getValue()));
        layout.add(presetMappingField);

        // CSV mapping fields
        delimiterField = new TextField("Delimiter");
        delimiterField.setValue(",");

        dateColumnField = new NumberField("Date Column Index");
        dateColumnField.setValue(0.0);
        dateColumnField.setStep(1.0);
        dateColumnField.setMin(0);

        dateFormatField = new TextField("Date Format");
        dateFormatField.setValue("MM/dd/yyyy");

        descriptionColumnField = new NumberField("Description Column Index");
        descriptionColumnField.setValue(1.0);
        descriptionColumnField.setStep(1.0);
        descriptionColumnField.setMin(0);

        amountColumnField = new NumberField("Amount Column Index");
        amountColumnField.setValue(2.0);
        amountColumnField.setStep(1.0);
        amountColumnField.setMin(0);

        amountMultiplierField = new NumberField("Amount Multiplier");
        amountMultiplierField.setValue(1.0);
        amountMultiplierField.setHelperText("Use -1 if amounts need to be reversed");

        layout.add(
            delimiterField,
            dateColumnField,
            dateFormatField,
            descriptionColumnField,
            amountColumnField,
            amountMultiplierField
        );

        // Default envelope selector
        defaultEnvelopeField = new ComboBox<>("Default Envelope");
        defaultEnvelopeField.setItemLabelGenerator(Envelope::getName);
        defaultEnvelopeField.setItems(envelopeService.getAllEnvelopes());
        defaultEnvelopeField.setRequired(true);
        layout.add(defaultEnvelopeField);

        // Help text
        Paragraph help = new Paragraph(
            "Column indices start at 0. Date format should match the pattern in your CSV file."
        );
        layout.add(help);

        // Buttons
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> close());

        Button importButton = new Button("Import", e -> importData());
        importButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        buttons.add(cancelButton, importButton);
        layout.add(buttons);

        add(layout);
    }

    private void updateMappingFields(String preset) {
        switch (preset) {
            case "Chase" -> {
                delimiterField.setValue(",");
                dateColumnField.setValue(0.0);
                dateFormatField.setValue("MM/dd/yyyy");
                descriptionColumnField.setValue(2.0);
                amountColumnField.setValue(3.0);
                amountMultiplierField.setValue(1.0);
            }
            case "Bank of America" -> {
                delimiterField.setValue(",");
                dateColumnField.setValue(0.0);
                dateFormatField.setValue("MM/dd/yyyy");
                descriptionColumnField.setValue(1.0);
                amountColumnField.setValue(2.0);
                amountMultiplierField.setValue(1.0);
            }
            // Add more presets as needed
        }
    }

    private void importData() {
        try {
            if (defaultEnvelopeField.isEmpty()) {
                throw new IllegalArgumentException("Please select a default envelope");
            }
            if (accountField.isEmpty()) {
                throw new IllegalArgumentException("Please select an account");
            }

            // Read file content
            InputStream is = buffer.getInputStream();
            String content = new Scanner(is, StandardCharsets.UTF_8)
                .useDelimiter("\\A")
                .next();

            // Create mapping from form fields
            CSVMapping mapping = new CSVMapping(
                true, // Assume headers for now
                delimiterField.getValue(),
                dateColumnField.getValue().intValue(),
                dateFormatField.getValue(),
                descriptionColumnField.getValue().intValue(),
                amountColumnField.getValue().intValue(),
                amountMultiplierField.getValue()
            );

            // Import data
            CSVImportService.ImportResult result = csvImportService.importTransactions(
                content,
                mapping,
                defaultEnvelopeField.getValue().getId(),
                accountField.getValue().getId()
            );

            // Show results
            String message = String.format(
                "Imported %d transactions successfully. %d failed.",
                result.getSuccessful(),
                result.getFailed()
            );

            if (result.getFailed() > 0) {
                message += "\nErrors:\n" + String.join("\n", result.getErrors());
            }

            Notification notification = Notification.show(
                message,
                5000,
                Notification.Position.MIDDLE
            );

            if (result.getFailed() > 0) {
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            } else {
                notification.addThemeVariants(NotificationVariant.LUMO_SUCCESS);
            }

            // Close dialog and refresh parent view
            close();
            onSuccess.run();

        } catch (IllegalArgumentException ex) {
            Notification notification = Notification.show(
                "Error importing data: " + ex.getMessage(),
                5000,
                Notification.Position.MIDDLE
            );
            notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
        }
    }
}


=== ./src/main/java/org/emblow/envelopify/ui/components/TransactionManagementDialogs.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

import com.vaadin.flow.component.ClickEvent;
import com.vaadin.flow.component.ComponentEventListener;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import com.vaadin.flow.component.textfield.BigDecimalField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.datepicker.DatePicker;
import com.vaadin.flow.component.timepicker.TimePicker;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.confirmdialog.ConfirmDialog;
import com.vaadin.flow.spring.annotation.SpringComponent;
import com.vaadin.flow.spring.annotation.UIScope;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.service.PatternService;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@SpringComponent
@UIScope
public class TransactionManagementDialogs {

    private final TransactionService transactionService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final PatternService patternService;

    public TransactionManagementDialogs(
        TransactionService transactionService,
        EnvelopeService envelopeService,
        AccountService accountService,
        PatternService patternService
    ) {
        this.transactionService = transactionService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.patternService = patternService;
    }

    public void showNewTransactionDialog(Runnable onSuccess) {
        showTransactionDialog(null, onSuccess);
    }

    public void showEditTransactionDialog(Transaction transaction, Runnable onSuccess) {
        showTransactionDialog(transaction, onSuccess);
    }

    private void showTransactionDialog(Transaction transaction, Runnable onSuccess) {
        boolean isEdit = transaction != null;
        
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);

        H3 title = new H3(isEdit ? "Edit Transaction" : "New Transaction");

        // Date and time pickers
        DatePicker datePicker = new DatePicker("Date");
        TimePicker timePicker = new TimePicker("Time");
        
        if (isEdit) {
            datePicker.setValue(transaction.getDate().toLocalDate());
            timePicker.setValue(transaction.getDate().toLocalTime());
        } else {
            datePicker.setValue(java.time.LocalDate.now());
            timePicker.setValue(java.time.LocalTime.now());
        }

        // Description field
        TextField descriptionField = new TextField("Description");
        descriptionField.setWidthFull();
        descriptionField.setRequired(true);
        if (isEdit) {
            descriptionField.setValue(transaction.getDescription());
        }

        // Amount field
        BigDecimalField amountField = new BigDecimalField("Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setWidthFull();
        if (isEdit) {
            amountField.setValue(transaction.getAmount());
        } else {
            amountField.setValue(BigDecimal.ZERO);
        }

        // Transaction Type selector
        ComboBox<TransactionType> typeField = new ComboBox<>("Transaction Type");
        typeField.setItems(TransactionType.values());
        typeField.setItemLabelGenerator(tt -> tt == TransactionType.INCOME ? "Income" : "Expense");
        typeField.setWidthFull();
        typeField.setRequired(true);
        if (isEdit) {
            typeField.setValue(transaction.getType());
        } else {
            // Default to Expense for new transactions
            typeField.setValue(TransactionType.EXPENSE);
        }

        // Account selector
        ComboBox<Account> accountField = new ComboBox<>("Account");
        accountField.setItemLabelGenerator(account -> 
            String.format("%s (%s) - Balance: $%.2f", 
                account.getName(),
                account.getType().getDisplayName(),
                account.getBalance()
            )
        );
        accountField.setItems(accountService.getAllAccounts());
        accountField.setWidthFull();
        accountField.setRequired(true);
        if (isEdit) {
            accountField.setValue(transaction.getAccount());
        }

        // Envelope selector
        ComboBox<Envelope> envelopeField = new ComboBox<>("Envelope");
        envelopeField.setItemLabelGenerator(env -> 
            String.format("%s - Available: $%.2f", 
                env.getName(),
                env.getAvailable()
            )
        );
        envelopeField.setItems(envelopeService.getAllEnvelopes());
        envelopeField.setWidthFull();
        envelopeField.setRequired(true);
        if (isEdit) {
            envelopeField.setValue(transaction.getEnvelope());
        }

        // Add envelope suggestions
        EnvelopeSuggestions suggestions = new EnvelopeSuggestions(envelopeField, patternService);

        // Update suggestions when description changes
        descriptionField.addValueChangeListener(e -> {
            Transaction temp = new Transaction();
            temp.setDescription(e.getValue());
            temp.setAmount(amountField.getValue());
            temp.setDate(LocalDateTime.of(datePicker.getValue(), timePicker.getValue()));
            temp.setAccount(accountField.getValue());
            suggestions.updateSuggestions(temp);
        });

        // Buttons
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button saveButton = new Button(isEdit ? "Save" : "Create", new ComponentEventListener<ClickEvent<Button>>() {
            @Override
            public void onComponentEvent(ClickEvent<Button> e) {
                try {
                    String description = descriptionField.getValue();
                    BigDecimal amount = amountField.getValue();
                    TransactionType type = typeField.getValue();
                    Envelope envelope = envelopeField.getValue();
                    Account account = accountField.getValue();
                    LocalDateTime dateTime = LocalDateTime.of(
                            datePicker.getValue(),
                            timePicker.getValue()
                    );
                    
                    // Validation
                    if (description == null || description.trim().isEmpty()) {
                        throw new IllegalArgumentException("Please enter a description");
                    }
                    if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                        throw new IllegalArgumentException("Please enter a non-zero amount");
                    }
                    if (envelope == null) {
                        throw new IllegalArgumentException("Please select an envelope");
                    }
                    if (account == null) {
                        throw new IllegalArgumentException("Please select an account");
                    }
                    if (type == null) {
                        throw new IllegalArgumentException("Please select a transaction type");
                    }
                    
                    if (isEdit) {
                        transactionService.updateTransaction(
                                transaction.getId(),
                                envelope.getId(),
                                account.getId(),
                                dateTime,
                                description.trim(),
                                amount,
                                type
                        );
                    } else {
                        transactionService.recordTransaction(
                                envelope.getId(),
                                account.getId(),
                                dateTime,
                                description.trim(),
                                amount,
                                type
                        );
                    }
                    
                    dialog.close();
                    onSuccess.run();
                    
                    Notification.show(
                            isEdit ? "Transaction updated" : "Transaction recorded",
                            3000,
                            Notification.Position.MIDDLE
                    );
                } catch (IllegalArgumentException ex) {
                    Notification notification = Notification.show(
                            "Error: " + ex.getMessage(),
                            3000,
                            Notification.Position.MIDDLE
                    );
                    notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
                }
            }
        });
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        Button deleteButton = null;
        if (isEdit) {
            deleteButton = new Button("Delete", e -> {
                ConfirmDialog confirmDialog = new ConfirmDialog();
                confirmDialog.setHeader("Delete Transaction");
                confirmDialog.setText("Are you sure you want to delete this transaction? This cannot be undone.");
                
                confirmDialog.setCancelable(true);
                confirmDialog.setConfirmText("Delete");
                confirmDialog.setConfirmButtonTheme("error");
                
                confirmDialog.addConfirmListener(event -> {
                    try {
                        transactionService.deleteTransaction(transaction.getId());
                        dialog.close();
                        onSuccess.run();
                        Notification.show("Transaction deleted", 3000, Notification.Position.MIDDLE);
                    } catch (Exception ex) {
                        Notification.show(
                            "Error deleting transaction: " + ex.getMessage(),
                            3000,
                            Notification.Position.MIDDLE
                        );
                    }
                });
                
                confirmDialog.open();
            });
            deleteButton.addThemeVariants(ButtonVariant.LUMO_ERROR);
            buttons.add(deleteButton);
        }

        buttons.add(cancelButton, saveButton);

        layout.add(
            title,
            new HorizontalLayout(datePicker, timePicker),
            accountField,
            descriptionField,
            amountField,
            typeField,
            envelopeField,
            suggestions,
            buttons
        );

        dialog.add(layout);
        dialog.open();
    }
}



=== ./src/main/java/org/emblow/envelopify/ui/components/AccountDialog.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.AccountService;

public class AccountDialog extends Dialog {
    private final AccountService accountService;
    private final Runnable onSuccess;
    private final Account existingAccount;

    public AccountDialog(AccountService accountService, Runnable onSuccess) {
        this(accountService, onSuccess, null);
    }

    public AccountDialog(
        AccountService accountService,
        Runnable onSuccess,
        Account existingAccount
    ) {
        this.accountService = accountService;
        this.onSuccess = onSuccess;
        this.existingAccount = existingAccount;

        setModal(true);
        setDraggable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);

        H3 title = new H3(existingAccount == null ? 
            "Add New Account" : "Edit Account");

        TextField nameField = new TextField("Account Name");
        nameField.setRequired(true);
        nameField.setWidthFull();

        ComboBox<Account.AccountType> typeField = new ComboBox<>("Account Type");
        typeField.setItems(Account.AccountType.values());
        typeField.setItemLabelGenerator(Account.AccountType::getDisplayName);
        typeField.setRequired(true);

        TextField institutionField = new TextField("Financial Institution");
        institutionField.setWidthFull();

        TextField accountNumberField = new TextField("Last 4 Digits");
        accountNumberField.setHelperText("For reference only");
        accountNumberField.setPattern("[0-9]{4}");
        accountNumberField.setMaxLength(4);

        // Set existing values if editing
        if (existingAccount != null) {
            nameField.setValue(existingAccount.getName());
            typeField.setValue(existingAccount.getType());
            institutionField.setValue(existingAccount.getInstitution());
            if (existingAccount.getAccountNumber() != null) {
                accountNumberField.setValue(existingAccount.getAccountNumber());
            }
        }

        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> close());

        Button saveButton = new Button(
            existingAccount == null ? "Create" : "Save",
            e -> {
                try {
                    String name = nameField.getValue();
                    Account.AccountType type = typeField.getValue();
                    String institution = institutionField.getValue();
                    String accountNumber = accountNumberField.getValue();

                    if (name == null || name.trim().isEmpty()) {
                        throw new IllegalArgumentException("Please enter an account name");
                    }
                    if (type == null) {
                        throw new IllegalArgumentException("Please select an account type");
                    }

                    if (existingAccount == null) {
                        accountService.createAccount(
                            name.trim(),
                            type,
                            institution,
                            accountNumber
                        );
                    } else {
                        existingAccount.setName(name.trim());
                        existingAccount.setType(type);
                        existingAccount.setInstitution(institution);
                        existingAccount.setAccountNumber(accountNumber);
                        // Save changes through service
                        accountService.save(existingAccount);
                    }

                    close();
                    onSuccess.run();
                    
                    Notification.show(
                        existingAccount == null ? 
                            "Account created" : "Account updated",
                        3000,
                        Notification.Position.MIDDLE
                    );

                } catch (Exception ex) {
                    Notification notification = Notification.show(
                        "Error: " + ex.getMessage(),
                        3000,
                        Notification.Position.MIDDLE
                    );
                    notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
                }
            }
        );
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        buttons.add(cancelButton, saveButton);
        layout.add(title, nameField, typeField, institutionField, 
                  accountNumberField, buttons);
        add(layout);
    }
}


=== ./src/main/java/org/emblow/envelopify/ui/components/RecurringTransactionDialog.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.textfield.BigDecimalField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import org.emblow.envelopify.domain.RecurringTransaction;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.RecurringTransactionService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.AccountService;

import java.math.BigDecimal;

public class RecurringTransactionDialog extends Dialog {
    private final RecurringTransactionService recurringTransactionService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final Runnable onSuccess;
    private final RecurringTransaction existingTransaction;

    public RecurringTransactionDialog(
        RecurringTransactionService recurringTransactionService,
        EnvelopeService envelopeService,
        AccountService accountService,
        Runnable onSuccess
    ) {
        this(recurringTransactionService, envelopeService, accountService, onSuccess, null);
    }

    public RecurringTransactionDialog(
        RecurringTransactionService recurringTransactionService,
        EnvelopeService envelopeService,
        AccountService accountService,
        Runnable onSuccess,
        RecurringTransaction existingTransaction
    ) {
        this.recurringTransactionService = recurringTransactionService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.onSuccess = onSuccess;
        this.existingTransaction = existingTransaction;

        setModal(true);
        setDraggable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);

        H3 title = new H3(existingTransaction == null ? 
            "New Recurring Transaction" : "Edit Recurring Transaction");

        TextField descriptionField = new TextField("Description");
        descriptionField.setRequired(true);
        descriptionField.setWidthFull();

        BigDecimalField amountField = new BigDecimalField("Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setWidthFull();

        ComboBox<RecurringTransaction.RecurrencePattern> patternField = 
            new ComboBox<>("Recurrence Pattern");
        patternField.setItems(RecurringTransaction.RecurrencePattern.values());
        patternField.setRequired(true);

        // Account selector
        ComboBox<Account> accountField = new ComboBox<>("Account");
        accountField.setItemLabelGenerator(account -> 
            String.format("%s (%s) - Balance: $%.2f", 
                account.getName(),
                account.getType().getDisplayName(),
                account.getBalance()
            )
        );
        accountField.setItems(accountService.getAllAccounts());
        accountField.setRequired(true);
        accountField.setWidthFull();

        ComboBox<Envelope> envelopeField = new ComboBox<>("Envelope");
        envelopeField.setItemLabelGenerator(Envelope::getName);
        envelopeField.setItems(envelopeService.getAllEnvelopes());
        envelopeField.setRequired(true);

        // Set existing values if editing
        if (existingTransaction != null) {
            descriptionField.setValue(existingTransaction.getDescription());
            amountField.setValue(existingTransaction.getAmount());
            patternField.setValue(existingTransaction.getPattern());
            accountField.setValue(existingTransaction.getAccount());
            envelopeField.setValue(existingTransaction.getEnvelope());
        }

        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> close());

        Button saveButton = new Button(
            existingTransaction == null ? "Create" : "Save", 
            e -> {
                try {
                    String description = descriptionField.getValue();
                    BigDecimal amount = amountField.getValue();
                    RecurringTransaction.RecurrencePattern pattern = patternField.getValue();
                    Account account = accountField.getValue();
                    Envelope envelope = envelopeField.getValue();

                    // Validation
                    if (description == null || description.trim().isEmpty()) {
                        throw new IllegalArgumentException("Please enter a description");
                    }
                    if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                        throw new IllegalArgumentException("Please enter a valid amount");
                    }
                    if (pattern == null) {
                        throw new IllegalArgumentException("Please select a recurrence pattern");
                    }
                    if (account == null) {
                        throw new IllegalArgumentException("Please select an account");
                    }
                    if (envelope == null) {
                        throw new IllegalArgumentException("Please select an envelope");
                    }

                    RecurringTransaction transaction = existingTransaction != null ? 
                        existingTransaction : new RecurringTransaction();
                    transaction.setDescription(description.trim());
                    transaction.setAmount(amount);
                    transaction.setPattern(pattern);
                    transaction.setAccount(account);
                    transaction.setEnvelope(envelope);

                    if (existingTransaction != null) {
                        recurringTransactionService.update(
                            existingTransaction.getId(), 
                            transaction, 
                            account.getId()
                        );
                    } else {
                        recurringTransactionService.create(transaction, account.getId());
                    }

                    close();
                    onSuccess.run();
                    
                    Notification.show(
                        existingTransaction == null ? 
                            "Recurring transaction created" : 
                            "Recurring transaction updated",
                        3000,
                        Notification.Position.MIDDLE
                    );

                } catch (Exception ex) {
                    Notification notification = Notification.show(
                        "Error: " + ex.getMessage(),
                        3000,
                        Notification.Position.MIDDLE
                    );
                    notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
                }
            }
        );
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        buttons.add(cancelButton, saveButton);
        layout.add(title, descriptionField, amountField, patternField, 
                  accountField, envelopeField, buttons);
        add(layout);
    }
}


=== ./src/main/java/org/emblow/envelopify/ui/components/AccountCard.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.html.H4;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.confirmdialog.ConfirmDialog;
import com.vaadin.flow.component.contextmenu.MenuItem;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.orderedlayout.FlexComponent;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.menubar.MenuBar;
import com.vaadin.flow.component.contextmenu.SubMenu;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.AccountService;

public class AccountCard extends Div {
    private final AccountService accountService;
    private final Runnable onModified;

    public AccountCard(Account account, AccountService accountService, Runnable onModified) {
        this.accountService = accountService;
        this.onModified = onModified;
        
        addClassName("account-card");
        getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("box-shadow", "var(--lumo-box-shadow-s)")
            .set("padding", "var(--lumo-space-m)")
            .set("max-width", "300px")
            .set("width", "100%");

        VerticalLayout content = new VerticalLayout();
        content.setPadding(false);
        content.setSpacing(true);

        // Header with name and type
        H4 name = new H4(account.getName());
        name.getStyle().setMargin("0");

        Span type = new Span(account.getType().getDisplayName());
        type.getStyle()
            .set("color", "var(--lumo-secondary-text-color)")
            .set("font-size", "var(--lumo-font-size-s)");

        // Balance information
        Span balance = new Span(String.format("Balance: $%.2f", account.getBalance()));
        balance.getStyle()
            .set("font-weight", "bold")
            .set("color", account.getBalance().signum() >= 0 ? 
                "var(--lumo-success-color)" : "var(--lumo-error-color)");

        // Quick actions
        HorizontalLayout actions = new HorizontalLayout();
        actions.setWidthFull();
        actions.setJustifyContentMode(FlexComponent.JustifyContentMode.BETWEEN);

        Button viewButton = new Button(
            new Icon(VaadinIcon.LIST),
            e -> onViewClicked(account)
        );
        viewButton.getElement().setAttribute("title", "View transactions");

        MenuBar menuBar = new MenuBar();
        menuBar.getStyle()
            .set("min-width", "var(--lumo-button-size)")
            .set("min-height", "var(--lumo-button-size)");
        MenuItem menuItem = menuBar.addItem(new Icon(VaadinIcon.ELLIPSIS_DOTS_V));
        SubMenu subMenu = menuItem.getSubMenu();
        subMenu.addItem("Edit", e -> showEditDialog(account));
        subMenu.addItem("Delete", e -> showDeleteDialog(account));
        actions.add(viewButton, menuBar);

        // Institution info if available
        if (account.getInstitution() != null && !account.getInstitution().isEmpty()) {
            Span institution = new Span(account.getInstitution());
            institution.getStyle()
                .set("color", "var(--lumo-secondary-text-color)")
                .set("font-size", "var(--lumo-font-size-s)");
            content.add(name, type, institution, balance, actions);
        } else {
            content.add(name, type, balance, actions);
        }

        // Account number if available
        if (account.getAccountNumber() != null && !account.getAccountNumber().isEmpty()) {
            Span accountNumber = new Span("****" + account.getAccountNumber());
            accountNumber.getStyle()
                .set("color", "var(--lumo-tertiary-text-color)")
                .set("font-size", "var(--lumo-font-size-xs)");
            content.add(accountNumber);
        }

        add(content);
    }

    private void onViewClicked(Account account) {
        // TODO: Navigate to account details view when implemented
        // UI.getCurrent().navigate("accounts/" + account.getId());
        Notification.show("Account details view coming soon", 
            3000, Notification.Position.MIDDLE);
    }

    private void showEditDialog(Account account) {
        new AccountDialog(
            accountService,
            onModified,
            account
        ).open();
    }

    private void showDeleteDialog(Account account) {
        ConfirmDialog dialog = new ConfirmDialog();
        dialog.setHeader("Delete Account");
        dialog.setText(
            "Are you sure you want to delete this account? " +
            "This will affect all transactions associated with it."
        );
        
        dialog.setCancelable(true);
        dialog.setConfirmText("Delete");
        dialog.setConfirmButtonTheme("error");
        
        dialog.addConfirmListener(event -> {
            try {
                accountService.deleteAccount(account.getId());
                onModified.run();
                Notification.show(
                    "Account deleted",
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error deleting account: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        
        dialog.open();
    }
}


=== ./src/main/java/org/emblow/envelopify/ui/components/EnvelopeSchedulePanel.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.grid.Grid;
import org.emblow.envelopify.domain.RecurringTransaction;
import org.emblow.envelopify.domain.BillReminder;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.service.RecurringTransactionService;
import org.emblow.envelopify.service.BillReminderService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.AccountService;
import com.vaadin.flow.component.grid.contextmenu.GridContextMenu;
import java.time.format.DateTimeFormatter;
import java.util.List;

public class EnvelopeSchedulePanel extends VerticalLayout {
    private final RecurringTransactionService recurringTransactionService;
    private final BillReminderService billReminderService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final Grid<RecurringTransaction> recurringGrid;
    private final Grid<BillReminder> billGrid;
    private final Envelope envelope;

    public EnvelopeSchedulePanel(
        Envelope envelope,
        RecurringTransactionService recurringTransactionService,
        BillReminderService billReminderService,
        EnvelopeService envelopeService,
        AccountService accountService
    ) {
        this.envelope = envelope;
        this.recurringTransactionService = recurringTransactionService;
        this.billReminderService = billReminderService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;

        setPadding(true);
        setSpacing(true);

        // Recurring Transactions section
        H3 recurringTitle = new H3("Recurring Transactions");
        Button addRecurringButton = new Button(
            "Add Recurring",
            new Icon(VaadinIcon.PLUS),
            e -> showAddRecurringDialog()
        );
        addRecurringButton.addThemeVariants(ButtonVariant.LUMO_SUCCESS);

        recurringGrid = new Grid<>();
        configureRecurringGrid();
        
        // Bills section
        H3 billsTitle = new H3("Bills");
        Button addBillButton = new Button(
            "Add Bill",
            new Icon(VaadinIcon.PLUS),
            e -> showAddBillDialog()
        );
        addBillButton.addThemeVariants(ButtonVariant.LUMO_SUCCESS);

        billGrid = new Grid<>();
        configureBillGrid();

        add(
            recurringTitle,
            addRecurringButton,
            recurringGrid,
            billsTitle,
            addBillButton,
            billGrid
        );

        refreshData();
    }

    private void configureRecurringGrid() {
        recurringGrid.addColumn(RecurringTransaction::getDescription)
            .setHeader("Description")
            .setAutoWidth(true);
            
        recurringGrid.addColumn(tx -> 
            String.format("$%.2f", tx.getAmount()))
            .setHeader("Amount")
            .setAutoWidth(true);

        // Add account column
        recurringGrid.addColumn(tx -> 
            String.format("%s (%s)", 
                tx.getAccount().getName(),
                tx.getAccount().getType().getDisplayName()))
            .setHeader("Account")
            .setAutoWidth(true);
            
        recurringGrid.addColumn(tx -> tx.getPattern().toString())
            .setHeader("Pattern")
            .setAutoWidth(true);
            
        recurringGrid.addColumn(tx -> 
            tx.getNextDueDate().format(DateTimeFormatter.ofPattern("MM/dd/yyyy")))
            .setHeader("Next Due")
            .setAutoWidth(true);

        // Add edit/delete context menu
        GridContextMenu<RecurringTransaction> menu = new GridContextMenu<>(recurringGrid);
        menu.addItem("Edit", event -> {
            if (event.getItem().isPresent()) {
                showEditRecurringDialog(event.getItem().get());
            }
        });
        menu.addItem("Delete", event -> {
            if (event.getItem().isPresent()) {
                recurringTransactionService.delete(event.getItem().get().getId());
                refreshData();
            }
        });

        recurringGrid.setWidthFull();
    }

    private void configureBillGrid() {
        billGrid.addColumn(BillReminder::getDescription)
            .setHeader("Description")
            .setAutoWidth(true);
            
        billGrid.addColumn(bill -> 
            String.format("$%.2f", bill.getAmount()))
            .setHeader("Amount")
            .setAutoWidth(true);

        // Add account column
        billGrid.addColumn(bill -> 
            String.format("%s (%s)", 
                bill.getAccount().getName(),
                bill.getAccount().getType().getDisplayName()))
            .setHeader("Account")
            .setAutoWidth(true);
            
        billGrid.addColumn(bill -> 
            bill.getDueDate().format(DateTimeFormatter.ofPattern("MM/dd/yyyy")))
            .setHeader("Due Date")
            .setAutoWidth(true);
            
        billGrid.addColumn(BillReminder::isPaid)
            .setHeader("Paid")
            .setAutoWidth(true);

        // Add status color
        billGrid.setClassNameGenerator(bill -> {
            if (bill.isOverdue()) return "overdue";
            if (bill.needsReminder()) return "upcoming";
            if (bill.isPaid()) return "paid";
            return null;
        });

        // Add edit/delete context menu
        GridContextMenu<BillReminder> menu = new GridContextMenu<>(billGrid);
        menu.addItem("Edit", event -> {
            if (event.getItem().isPresent()) {
                showEditBillDialog(event.getItem().get());
            }
        });
        menu.addItem("Mark Paid", event -> {
            if (event.getItem().isPresent()) {
                billReminderService.markAsPaid(event.getItem().get().getId());
                refreshData();
            }
        });
        menu.addItem("Delete", event -> {
            if (event.getItem().isPresent()) {
                billReminderService.delete(event.getItem().get().getId());
                refreshData();
            }
        });

        billGrid.setWidthFull();
    }

    private void showAddRecurringDialog() {
        new RecurringTransactionDialog(
            recurringTransactionService,
            envelopeService,
            accountService,
            this::refreshData
        ).open();
    }

    private void showEditRecurringDialog(RecurringTransaction transaction) {
        new RecurringTransactionDialog(
            recurringTransactionService,
            envelopeService,
            accountService,
            this::refreshData,
            transaction
        ).open();
    }

    private void showAddBillDialog() {
        new BillReminderDialog(
            billReminderService,
            envelopeService,
            accountService,
            this::refreshData
        ).open();
    }

    private void showEditBillDialog(BillReminder bill) {
        new BillReminderDialog(
            billReminderService,
            envelopeService,
            accountService,
            this::refreshData,
            bill
        ).open();
    }

    private void refreshData() {
        List<RecurringTransaction> recurringTransactions = 
            recurringTransactionService.getAllForEnvelope(envelope.getId());
        recurringGrid.setItems(recurringTransactions);

        List<BillReminder> bills = 
            billReminderService.getAllForEnvelope(envelope.getId());
        billGrid.setItems(bills);
    }
}


=== ./src/main/java/org/emblow/envelopify/ui/components/EnvelopeCard.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.UI;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.html.H4;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.orderedlayout.FlexComponent;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.progressbar.ProgressBar;
import com.vaadin.flow.component.contextmenu.ContextMenu;
import com.vaadin.flow.component.Component;
import com.vaadin.flow.component.contextmenu.MenuItem;
import com.vaadin.flow.component.contextmenu.SubMenu;
import com.vaadin.flow.component.menubar.MenuBar;
import org.emblow.envelopify.domain.Envelope;

import java.text.NumberFormat;
import java.util.Locale;

public class EnvelopeCard extends Div {
    private final NumberFormat currencyFormat = NumberFormat.getCurrencyInstance(Locale.US);
    private final EnvelopeManagementDialogs dialogs;

    public EnvelopeCard(Envelope envelope, EnvelopeManagementDialogs dialogs) {
        this.dialogs = dialogs;
        initializeCard(envelope);
    }

    private void initializeCard(Envelope envelope) {
        addClassName("envelope-card");
        getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("box-shadow", "var(--lumo-box-shadow-s)")
            .set("padding", "var(--lumo-space-m)")
            .set("max-width", "300px")
            .set("width", "100%");

        VerticalLayout content = new VerticalLayout();
        content.setPadding(false);
        content.setSpacing(true);

        // Header with name
        H4 name = new H4(envelope.getName());
        name.getStyle().setMargin("0");

        // Balance information
        HorizontalLayout balanceLayout = new HorizontalLayout();
        balanceLayout.setWidthFull();
        balanceLayout.setJustifyContentMode(FlexComponent.JustifyContentMode.BETWEEN);

        Span available = new Span("Available: " + 
            currencyFormat.format(envelope.getAvailable()));
        Span allocated = new Span("Allocated: " + 
            currencyFormat.format(envelope.getAllocated()));

        balanceLayout.add(available, allocated);

        // Progress bar
        ProgressBar progress = new ProgressBar();
        progress.setMin(0);
        progress.setMax(100);
        progress.setValue(envelope.getSpentPercentage());
        progress.setWidthFull();

        // Quick actions
        HorizontalLayout actions = new HorizontalLayout();
        actions.setWidthFull();
        actions.setJustifyContentMode(FlexComponent.JustifyContentMode.BETWEEN);

        Button addButton = new Button(
            new Icon(VaadinIcon.PLUS),
            e -> onAddClicked(envelope)
        );
        addButton.getElement().setAttribute("title", "Add funds");

        Button moveButton = new Button(
            new Icon(VaadinIcon.EXCHANGE),
            e -> onMoveClicked(envelope)
        );
        moveButton.getElement().setAttribute("title", "Move funds");

        Button historyButton = new Button(
            new Icon(VaadinIcon.LIST),
            e -> onHistoryClicked(envelope)
        );
        historyButton.getElement().setAttribute("title", "View history");

        MenuBar menuBar = new MenuBar();
        menuBar.getStyle()
            .set("min-width", "var(--lumo-button-size)")
            .set("min-height", "var(--lumo-button-size)");
        MenuItem menuItem = menuBar.addItem(new Icon(VaadinIcon.ELLIPSIS_DOTS_V));
        SubMenu subMenu = menuItem.getSubMenu();
        subMenu.addItem("Edit Name", e -> dialogs.showEditNameDialog(envelope, () -> {
            UI.getCurrent().getPage().reload();
        }));
        subMenu.addItem("Budget Settings", e -> dialogs.showBudgetDialog(envelope, () -> {
            UI.getCurrent().getPage().reload();
        }));
        subMenu.addItem("Delete", e -> dialogs.showDeleteEnvelopeDialog(envelope, () -> {
            UI.getCurrent().getPage().reload();
        }));

        actions.add(addButton, moveButton, historyButton, menuBar);

        // Add all components
        content.add(name, balanceLayout, progress, actions);
        add(content);  // This should be the last line of initializeCard
    }

    private void onAddClicked(Envelope envelope) {
        dialogs.showAddFundsDialog(envelope, () -> {
            // Refresh the UI after success
            UI.getCurrent().getPage().reload();
        });
    }

    private void onMoveClicked(Envelope envelope) {
        dialogs.showMoveFundsDialog(envelope, () -> {
            // Refresh the UI after success
            UI.getCurrent().getPage().reload();
        });
    }

    private void onHistoryClicked(Envelope envelope) {
        UI.getCurrent().navigate("envelopes/" + envelope.getId());
    }

}


=== ./src/main/java/org/emblow/envelopify/ui/components/ChatComponent.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.orderedlayout.FlexComponent;
import com.vaadin.flow.component.notification.Notification;
import org.emblow.envelopify.service.llm.OllamaService;
import java.util.concurrent.CompletableFuture;
import com.vaadin.flow.component.Key;
import org.emblow.envelopify.service.llm.LLMService;

public class ChatComponent extends VerticalLayout {
    private final LLMService llmService;
    private final VerticalLayout messagesLayout;
    private final TextField inputField;
    private final Button sendButton;

    public ChatComponent(LLMService llmService) {

          this.llmService= llmService;

        // Configure main layout
        setHeightFull();
        setWidth("800px");
        addClassName("chat-component");
        getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("box-shadow", "var(--lumo-box-shadow-m)");

        // Messages area
        messagesLayout = new VerticalLayout();
        messagesLayout.setSpacing(true);
        messagesLayout.setPadding(true);
        messagesLayout.setHeightFull();
        messagesLayout.getStyle()
            .set("overflow-y", "auto")
            .set("flex-grow", "1");

        // Input area
        HorizontalLayout inputLayout = new HorizontalLayout();
        inputLayout.setWidthFull();
        inputLayout.setPadding(true);
        inputLayout.setSpacing(true);
        inputLayout.setAlignItems(FlexComponent.Alignment.CENTER);
        inputLayout.getStyle()
            .set("background-color", "var(--lumo-contrast-5pct)")
            .set("border-radius", "0 0 var(--lumo-border-radius-l) var(--lumo-border-radius-l)");

        inputField = new TextField();
        inputField.setWidthFull();
        inputField.setPlaceholder("Ask about your finances...");
        inputField.addKeyPressListener(Key.ENTER, e -> handleSend());

        sendButton = new Button(new Icon(VaadinIcon.PAPERPLANE));
        sendButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        sendButton.addClickListener(e -> handleSend());

        inputLayout.add(inputField, sendButton);
        inputLayout.setFlexGrow(1, inputField);

        add(messagesLayout, inputLayout);
        setFlexGrow(1, messagesLayout);
    }

    private void handleSend() {
        String message = inputField.getValue().trim();
        if (message.isEmpty()) return;

        // Add user message
        addMessage(message, true);
        inputField.clear();

        // Disable input while processing
        setInputEnabled(false);

        // Process message asynchronously
        CompletableFuture.runAsync(() -> {
            try {
                String response = llmService.processUserQuery(message);
                getUI().ifPresent(ui -> ui.access(() -> {
                    addMessage(response, false);
                    setInputEnabled(true);
                }));
            } catch (Exception e) {
                getUI().ifPresent(ui -> ui.access(() -> {
                    Notification.show("Error processing message: " + e.getMessage(),
                        3000, Notification.Position.MIDDLE);
                    setInputEnabled(true);
                }));
            }
        });
    }

    private void addMessage(String text, boolean isUser) {
        Div messageDiv = new Div();
        messageDiv.addClassName(isUser ? "user-message" : "assistant-message");
        messageDiv.getStyle()
            .set("background-color", isUser ? 
                "var(--lumo-primary-color)" : "var(--lumo-contrast-5pct)")
            .set("color", isUser ? 
                "var(--lumo-primary-contrast-color)" : "var(--lumo-body-text-color)")
            .set("padding", "var(--lumo-space-m)")
            .set("border-radius", "var(--lumo-border-radius-m)")
            .set("max-width", "80%")
            .set("margin", isUser ? "0 0 var(--lumo-space-m) auto" : "0 auto var(--lumo-space-m) 0");

        Span content = new Span(text);
        messageDiv.add(content);
        messagesLayout.add(messageDiv);
        
        // Scroll to bottom
        messagesLayout.getElement().executeJs(
            "this.scrollTop = this.scrollHeight;"
        );
    }

    private void setInputEnabled(boolean enabled) {
        inputField.setEnabled(enabled);
        sendButton.setEnabled(enabled);
    }
}



=== ./src/main/java/org/emblow/envelopify/ui/components/BillReminderDialog.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.datepicker.DatePicker;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.textfield.BigDecimalField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.textfield.IntegerField;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import org.emblow.envelopify.domain.BillReminder;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.BillReminderService;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.AccountService;

import java.math.BigDecimal;
import java.time.LocalDate;

public class BillReminderDialog extends Dialog {
    private final BillReminderService billReminderService;
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final Runnable onSuccess;
    private final BillReminder existingBill;

    public BillReminderDialog(
        BillReminderService billReminderService,
        EnvelopeService envelopeService,
        AccountService accountService,
        Runnable onSuccess
    ) {
        this(billReminderService, envelopeService, accountService, onSuccess, null);
    }

    public BillReminderDialog(
        BillReminderService billReminderService,
        EnvelopeService envelopeService,
        AccountService accountService,
        Runnable onSuccess,
        BillReminder existingBill
    ) {
        this.billReminderService = billReminderService;
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.onSuccess = onSuccess;
        this.existingBill = existingBill;

        setModal(true);
        setDraggable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);

        H3 title = new H3(existingBill == null ? "New Bill Reminder" : "Edit Bill Reminder");

        TextField descriptionField = new TextField("Description");
        descriptionField.setRequired(true);
        descriptionField.setWidthFull();

        BigDecimalField amountField = new BigDecimalField("Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setWidthFull();

        DatePicker dueDateField = new DatePicker("Due Date");
        dueDateField.setRequired(true);
        dueDateField.setMin(LocalDate.now());

        IntegerField reminderDaysField = new IntegerField("Reminder Days Before");
        reminderDaysField.setValue(7);
        reminderDaysField.setMin(0);
        reminderDaysField.setMax(60);
        reminderDaysField.setStep(1);

        // Account selector
        ComboBox<Account> accountField = new ComboBox<>("Account");
        accountField.setItemLabelGenerator(account -> 
            String.format("%s (%s) - Balance: $%.2f", 
                account.getName(),
                account.getType().getDisplayName(),
                account.getBalance()
            )
        );
        accountField.setItems(accountService.getAllAccounts());
        accountField.setRequired(true);
        accountField.setWidthFull();

        ComboBox<Envelope> envelopeField = new ComboBox<>("Envelope");
        envelopeField.setItemLabelGenerator(env -> 
            String.format("%s - Available: $%.2f", 
                env.getName(),
                env.getAvailable()
            )
        );
        envelopeField.setItems(envelopeService.getAllEnvelopes());
        envelopeField.setRequired(true);

        // Set existing values if editing
        if (existingBill != null) {
            descriptionField.setValue(existingBill.getDescription());
            amountField.setValue(existingBill.getAmount());
            dueDateField.setValue(existingBill.getDueDate());
            reminderDaysField.setValue(existingBill.getReminderDays());
            accountField.setValue(existingBill.getAccount());
            envelopeField.setValue(existingBill.getEnvelope());
        }

        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> close());

        Button saveButton = new Button(existingBill == null ? "Create" : "Save", e -> {
            try {
                String description = descriptionField.getValue();
                BigDecimal amount = amountField.getValue();
                LocalDate dueDate = dueDateField.getValue();
                int reminderDays = reminderDaysField.getValue();
                Account account = accountField.getValue();
                Envelope envelope = envelopeField.getValue();

                // Validation
                if (description == null || description.trim().isEmpty()) {
                    throw new IllegalArgumentException("Please enter a description");
                }
                if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                    throw new IllegalArgumentException("Please enter a valid amount");
                }
                if (dueDate == null) {
                    throw new IllegalArgumentException("Please select a due date");
                }
                if (account == null) {
                    throw new IllegalArgumentException("Please select an account");
                }
                if (envelope == null) {
                    throw new IllegalArgumentException("Please select an envelope");
                }

                BillReminder reminder = existingBill != null ? existingBill : new BillReminder();
                reminder.setDescription(description.trim());
                reminder.setAmount(amount);
                reminder.setDueDate(dueDate);
                reminder.setReminderDays(reminderDays);
                reminder.setAccount(account);
                reminder.setEnvelope(envelope);
                reminder.setPaid(false);

                if (existingBill != null) {
                    billReminderService.update(existingBill.getId(), reminder);
                } else {
                    billReminderService.create(reminder);
                }

                close();
                onSuccess.run();
                
                Notification.show(
                    existingBill == null ? "Bill reminder created" : "Bill reminder updated",
                    3000,
                    Notification.Position.MIDDLE
                );

            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        buttons.add(cancelButton, saveButton);
        layout.add(title, descriptionField, amountField, dueDateField, 
                  reminderDaysField, accountField, envelopeField, buttons);
        add(layout);
    }
}


=== ./src/main/java/org/emblow/envelopify/ui/components/EnvelopeSuggestions.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.service.PatternService;

import java.util.Map;

public class EnvelopeSuggestions extends HorizontalLayout {
    private final ComboBox<Envelope> envelopeField;
    private final PatternService patternService;

    public EnvelopeSuggestions(
        ComboBox<Envelope> envelopeField,
        PatternService patternService
    ) {
        this.envelopeField = envelopeField;
        this.patternService = patternService;
        
        setSpacing(true);
        setAlignItems(Alignment.CENTER);
        setVisible(false);
    }

    public void updateSuggestions(Transaction transaction) {
        removeAll();
        
        if (transaction.getDescription() == null || transaction.getDescription().trim().isEmpty()) {
            setVisible(false);
            return;
        }

        Map<Envelope, Double> suggestions = patternService.suggestEnvelopes(transaction);
        if (!suggestions.isEmpty()) {
            setVisible(true);
            
            add(new Span("Suggested: "));
            
            suggestions.entrySet().stream()
                .sorted((e1, e2) -> e2.getValue().compareTo(e1.getValue()))
                .limit(3)  // Show top 3 suggestions
                .forEach(entry -> {
                    Button suggestionButton = new Button(
                        entry.getKey().getName(),
                        click -> envelopeField.setValue(entry.getKey())
                    );
                    suggestionButton.addThemeVariants(ButtonVariant.LUMO_SMALL);
                    add(suggestionButton);
                });
        } else {
            setVisible(false);
        }
    }
}


=== ./src/main/java/org/emblow/envelopify/ui/components/SpendingTrendsChart.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.components;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.littemplate.LitTemplate;
import com.vaadin.flow.component.Tag;
import com.vaadin.flow.component.dependency.JsModule;
import com.vaadin.flow.component.dependency.NpmPackage;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.service.TransactionService;

import java.math.BigDecimal;
import java.time.YearMonth;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Tag("spending-trends-chart")
@JsModule("./spending-trends-chart.js")
@NpmPackage(value = "echarts", version = "5.4.0")
@AnonymousAllowed
public class SpendingTrendsChart extends LitTemplate {
    private final TransactionService transactionService;

    public SpendingTrendsChart(TransactionService transactionService) {
        this.transactionService = transactionService;
        // Set sizing via style
        getElement().getStyle().set("display", "block");
        getElement().getStyle().set("height", "400px");
        getElement().getStyle().set("width", "100%");
        refreshData();
    }
    

    private void refreshData() {
        LocalDateTime sixMonthsAgo = LocalDateTime.now().minusMonths(6);
        List<Transaction> transactions = transactionService.getRecentTransactions(
            sixMonthsAgo, 
            LocalDateTime.now()
        );

        // Group transactions by month and envelope
        Map<YearMonth, Map<String, BigDecimal>> monthlyEnvelopeTotals = transactions.stream()
            .collect(Collectors.groupingBy(
                tx -> YearMonth.from(tx.getDate()),
                Collectors.groupingBy(
                    tx -> tx.getEnvelope().getName(),
                    Collectors.reducing(
                        BigDecimal.ZERO,
                        Transaction::getAmount,
                        BigDecimal::add
                    )
                )
            ));

        // Get all unique envelope names
        List<String> envelopes = transactions.stream()
            .map(tx -> tx.getEnvelope().getName())
            .distinct()
            .sorted()
            .collect(Collectors.toList());

        // Build labels array
        YearMonth current = YearMonth.now().minusMonths(5);
        StringBuilder labels = new StringBuilder("[");
        for (int i = 0; i <= 5; i++) {
            if (i > 0) labels.append(",");
            labels.append("'").append(current.format(DateTimeFormatter.ofPattern("MMM yy"))).append("'");
            current = current.plusMonths(1);
        }
        labels.append("]");

        // Build series array for each envelope
        StringBuilder series = new StringBuilder("[");
        for (int i = 0; i < envelopes.size(); i++) {
            if (i > 0) series.append(",");
            String envelope = envelopes.get(i);
            
            series.append("{")
                .append("name:'").append(envelope).append("',")
                .append("type:'bar',")
                .append("stack:'total',")
                .append("data:[");

            current = YearMonth.now().minusMonths(5);
            for (int j = 0; j <= 5; j++) {
                if (j > 0) series.append(",");
                BigDecimal amount = monthlyEnvelopeTotals
                    .getOrDefault(current, Map.of())
                    .getOrDefault(envelope, BigDecimal.ZERO);
                series.append(amount.doubleValue());
                current = current.plusMonths(1);
            }
            series.append("]}");
        }
        series.append("]");

        // Update chart properties
        getElement().setProperty("labels", labels.toString());
        getElement().setProperty("series", series.toString());
        getElement().setProperty("envelopes", envelopes.toString());
    }
}


=== ./src/main/java/org/emblow/envelopify/ui/components/EnvelopeManagementDialogs.java ===
/*
* Copyright (C) 2025 Nicholas J Emblow
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
package org.emblow.envelopify.ui.components;
/**
*
* @author Nicholas J Emblow
*/
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.dialog.Dialog;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.html.Span;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import com.vaadin.flow.component.textfield.BigDecimalField;
import com.vaadin.flow.component.textfield.TextField;
import com.vaadin.flow.component.combobox.ComboBox;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.notification.NotificationVariant;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.service.EnvelopeService;
import java.math.BigDecimal;
import java.util.List;

public class EnvelopeManagementDialogs {
    private final EnvelopeService envelopeService;
    
    public EnvelopeManagementDialogs(EnvelopeService envelopeService) {
        this.envelopeService = envelopeService;
    }

    public void showAddFundsDialog(Envelope envelope, Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);
        
        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);
        
        H3 title = new H3("Add Funds to " + envelope.getName());
        
        BigDecimalField amountField = new BigDecimalField("Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setValue(BigDecimal.ZERO);
        amountField.setWidthFull();
        
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();
        
        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button addButton = new Button("Add Funds", e -> {
            try {
                BigDecimal amount = amountField.getValue();
                if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                    throw new IllegalArgumentException("Please enter a valid amount");
                }
                envelope.allocate(amount);
                envelopeService.save(envelope);
                dialog.close();
                onSuccess.run();
                Notification.show(
                    "Added " + amount + " to " + envelope.getName(),
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        addButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        
        buttons.add(cancelButton, addButton);
        layout.add(title, amountField, buttons);
        dialog.add(layout);
        dialog.open();
    }

    public void showMoveFundsDialog(Envelope sourceEnvelope, Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);
        
        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);
        
        H3 title = new H3("Move Funds from " + sourceEnvelope.getName());
        
        // Target envelope selector
        ComboBox<Envelope> targetEnvelopeField = new ComboBox<>("To Envelope");
        targetEnvelopeField.setItemLabelGenerator(Envelope::getName);
        List<Envelope> otherEnvelopes = envelopeService.getAllEnvelopes().stream()
            .filter(e -> !e.getId().equals(sourceEnvelope.getId()))
            .toList();
        targetEnvelopeField.setItems(otherEnvelopes);
        targetEnvelopeField.setWidthFull();
        
        // Amount field
        BigDecimalField amountField = new BigDecimalField("Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setValue(BigDecimal.ZERO);
        amountField.setWidthFull();
        
        // Available amount display
        Span availableAmount = new Span(
            "Available: $" + sourceEnvelope.getAvailable()
        );
        
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();
        
        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button moveButton = new Button("Move Funds", e -> {
            try {
                Envelope targetEnvelope = targetEnvelopeField.getValue();
                BigDecimal amount = amountField.getValue();
                
                if (targetEnvelope == null) {
                    throw new IllegalArgumentException("Please select a target envelope");
                }
                if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
                    throw new IllegalArgumentException("Please enter a valid amount");
                }
                
                envelopeService.reallocate(
                    sourceEnvelope.getId(),
                    targetEnvelope.getId(),
                    amount
                );
                dialog.close();
                onSuccess.run();
                Notification.show(
                    "Moved " + amount + " from " + sourceEnvelope.getName() +
                    " to " + targetEnvelope.getName(),
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        moveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        
        buttons.add(cancelButton, moveButton);
        layout.add(title, targetEnvelopeField, amountField, availableAmount, buttons);
        dialog.add(layout);
        dialog.open();
    }

    public void showNewEnvelopeDialog(Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);
        
        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);
        
        H3 title = new H3("Create New Envelope");
        
        TextField nameField = new TextField("Name");
        nameField.setWidthFull();
        nameField.setRequired(true);
        
        BigDecimalField amountField = new BigDecimalField("Initial Amount");
        amountField.setPrefixComponent(new Span("$"));
        amountField.setValue(BigDecimal.ZERO);
        amountField.setWidthFull();
        
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();
        
        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button createButton = new Button("Create", e -> {
            try {
                String name = nameField.getValue();
                BigDecimal amount = amountField.getValue();
                
                if (name == null || name.trim().isEmpty()) {
                    throw new IllegalArgumentException("Please enter a name for the envelope");
                }
                if (amount == null || amount.compareTo(BigDecimal.ZERO) < 0) {
                    throw new IllegalArgumentException("Amount cannot be negative");
                }
                
                Envelope envelope = envelopeService.createEnvelope(name.trim(), amount);
                dialog.close();
                onSuccess.run();
                Notification.show(
                    "Created new envelope: " + envelope.getName(),
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        createButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        
        buttons.add(cancelButton, createButton);
        layout.add(title, nameField, amountField, buttons);
        dialog.add(layout);
        dialog.open();
    }

    public void showEditNameDialog(Envelope envelope, Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);
        
        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);
        
        H3 title = new H3("Edit Envelope Name");
        
        TextField nameField = new TextField("New Name", envelope.getName());
        nameField.setWidthFull();
        nameField.setRequired(true);
        
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();
        
        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button saveButton = new Button("Save", e -> {
            try {
                String newName = nameField.getValue();
                if (newName == null || newName.trim().isEmpty()) {
                    throw new IllegalArgumentException("Please enter a valid name");
                }
                envelope.setName(newName.trim());
                envelopeService.save(envelope);
                dialog.close();
                onSuccess.run();
                Notification.show(
                    "Envelope name updated to " + newName,
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        
        buttons.add(cancelButton, saveButton);
        layout.add(title, nameField, buttons);
        dialog.add(layout);
        dialog.open();
    }

    public void showDeleteEnvelopeDialog(Envelope envelope, Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);
        
        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);
        
        H3 title = new H3("Delete Envelope: " + envelope.getName());
        
        // Warning text
        Span warningText = new Span("Please select where to move the existing transactions:");
        
        // Target envelope selector (excluding current envelope)
        ComboBox<Envelope> targetEnvelopeField = new ComboBox<>("Move transactions to");
        targetEnvelopeField.setItemLabelGenerator(Envelope::getName);
        List<Envelope> otherEnvelopes = envelopeService.getAllEnvelopes().stream()
            .filter(e -> !e.getId().equals(envelope.getId()))
            .toList();
        targetEnvelopeField.setItems(otherEnvelopes);
        targetEnvelopeField.setWidthFull();
        targetEnvelopeField.setRequired(true);
        
        // Display current balance
        Span balanceInfo = new Span(
            "Current balance: $" + envelope.getAvailable()
        );
        
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();
        
        Button cancelButton = new Button("Cancel", e -> dialog.close());
        
        Button deleteButton = new Button("Delete", e -> {
            try {
                Envelope targetEnvelope = targetEnvelopeField.getValue();
                if (targetEnvelope == null) {
                    throw new IllegalArgumentException("Please select a target envelope for the transactions");
                }
                
                envelopeService.deleteEnvelope(envelope.getId(), targetEnvelope.getId());
                dialog.close();
                onSuccess.run();
                
                Notification.show(
                    "Envelope deleted and transactions moved to " + targetEnvelope.getName(),
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        deleteButton.addThemeVariants(ButtonVariant.LUMO_ERROR);
        
        buttons.add(cancelButton, deleteButton);
        layout.add(title, warningText, targetEnvelopeField, balanceInfo, buttons);
        dialog.add(layout);
        dialog.open();
    }
    
    public void showBudgetDialog(Envelope envelope, Runnable onSuccess) {
        Dialog dialog = new Dialog();
        dialog.setModal(true);
        dialog.setDraggable(true);

        VerticalLayout layout = new VerticalLayout();
        layout.setPadding(true);
        layout.setSpacing(true);
        layout.setAlignItems(Alignment.STRETCH);

        H3 title = new H3("Budget Settings: " + envelope.getName());

        // Monthly budget field
        BigDecimalField monthlyBudgetField = new BigDecimalField("Monthly Budget Target");
        monthlyBudgetField.setPrefixComponent(new Span("$"));
        monthlyBudgetField.setValue(envelope.getMonthlyBudget());
        monthlyBudgetField.setWidthFull();

        // Current allocation field
        BigDecimalField allocationField = new BigDecimalField("Current Allocation");
        allocationField.setPrefixComponent(new Span("$"));
        allocationField.setValue(envelope.getAllocated());
        allocationField.setWidthFull();

        // Helper text
        Span helpText = new Span("The monthly budget is your target spending. The allocation is your currently available funds.");
        helpText.getStyle().set("color", "var(--lumo-secondary-text-color)");

        // Buttons
        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setJustifyContentMode(JustifyContentMode.END);
        buttons.setWidthFull();

        Button cancelButton = new Button("Cancel", e -> dialog.close());

        Button saveButton = new Button("Save", e -> {
            try {
                BigDecimal newBudget = monthlyBudgetField.getValue();
                BigDecimal newAllocation = allocationField.getValue();

                if (newBudget == null || newBudget.compareTo(BigDecimal.ZERO) < 0) {
                    throw new IllegalArgumentException("Please enter a valid budget amount");
                }
                if (newAllocation == null || newAllocation.compareTo(BigDecimal.ZERO) < 0) {
                    throw new IllegalArgumentException("Please enter a valid allocation amount");
                }

                // Update budget
                envelope.setMonthlyBudget(newBudget);

                // Handle allocation change
                BigDecimal currentAllocation = envelope.getAllocated();
                if (newAllocation.compareTo(currentAllocation) > 0) {
                    envelope.allocate(newAllocation.subtract(currentAllocation));
                } else if (newAllocation.compareTo(currentAllocation) < 0) {
                    envelope.withdraw(currentAllocation.subtract(newAllocation));
                }

                envelopeService.save(envelope);
                dialog.close();
                onSuccess.run();

                Notification.show(
                    "Budget settings updated",
                    3000,
                    Notification.Position.MIDDLE
                );
            } catch (Exception ex) {
                Notification notification = Notification.show(
                    "Error: " + ex.getMessage(),
                    3000,
                    Notification.Position.MIDDLE
                );
                notification.addThemeVariants(NotificationVariant.LUMO_ERROR);
            }
        });
        saveButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        buttons.add(cancelButton, saveButton);
        layout.add(title, monthlyBudgetField, allocationField, helpText, buttons);
        dialog.add(layout);
        dialog.open();
    }
}


=== ./src/main/java/org/emblow/envelopify/ui/MainLayout.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.UI;
import com.vaadin.flow.component.applayout.AppLayout;
import com.vaadin.flow.component.applayout.DrawerToggle;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.html.H1;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.Scroller;
import com.vaadin.flow.component.sidenav.SideNav;
import com.vaadin.flow.component.sidenav.SideNavItem;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.theme.lumo.LumoUtility;
import org.emblow.envelopify.ui.views.DashboardView;
import com.vaadin.flow.server.auth.AnonymousAllowed;  
import com.vaadin.flow.theme.Theme;
import com.vaadin.flow.theme.lumo.Lumo;
import org.emblow.envelopify.ui.views.ChatView;
import org.emblow.envelopify.ui.views.EnvelopeView;
import org.emblow.envelopify.ui.views.InsightsView;

@PageTitle("Envelopify")
@AnonymousAllowed 
public class MainLayout extends AppLayout {

    private Button toggleDarkMode;

    public MainLayout() {
        createHeader();
        createDrawer();
    }

    private void createHeader() {
        // Create a logo
        H1 logo = new H1("Envelopify");
        logo.addClassNames(
            LumoUtility.FontSize.LARGE,
            LumoUtility.Margin.MEDIUM
        );

        // Create a drawer toggle button
        DrawerToggle drawerToggle = new DrawerToggle();

        // Create the dark mode toggle button
        toggleDarkMode = new Button("Toggle Dark Mode", e -> {
            String currentTheme = UI.getCurrent().getElement().getAttribute("theme");
            if (currentTheme != null && currentTheme.contains("dark")) {
                UI.getCurrent().getElement().setAttribute("theme", "light");
            } else {
                UI.getCurrent().getElement().setAttribute("theme", "dark");
            }
        });

        // Create a horizontal layout for header components
        HorizontalLayout headerLayout = new HorizontalLayout(drawerToggle, logo, toggleDarkMode);
        headerLayout.setWidthFull();
        headerLayout.setDefaultVerticalComponentAlignment(Alignment.CENTER);
        headerLayout.expand(logo);

        // Optionally add some spacing or styling to headerLayout as needed.
        headerLayout.addClassNames(
            LumoUtility.Background.BASE,
            LumoUtility.BoxSizing.BORDER,
            LumoUtility.Display.FLEX,
            LumoUtility.AlignItems.CENTER,
            LumoUtility.Padding.MEDIUM,
            LumoUtility.Width.FULL
        );

        // Add the header layout to the navbar
        addToNavbar(headerLayout);
    }


    private void createDrawer() {
        var nav = new SideNav();
        
        nav.addItem(new SideNavItem("Dashboard", DashboardView.class, VaadinIcon.DASHBOARD.create()));
        nav.addItem(new SideNavItem("Smart Insights", InsightsView.class, VaadinIcon.CHART.create()));
        nav.addItem(new SideNavItem("Chat Assistant", ChatView.class, VaadinIcon.CHAT.create()));
 
        
        Scroller scroller = new Scroller(nav);
   
        addToDrawer(scroller);
    }
}



=== ./src/main/java/org/emblow/envelopify/ui/views/EnvelopeView.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.tabs.Tab;
import com.vaadin.flow.component.tabs.Tabs;
import com.vaadin.flow.router.BeforeEvent;
import com.vaadin.flow.router.HasUrlParameter;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.grid.Grid;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.grid.GridSortOrder;
import com.vaadin.flow.component.grid.GridVariant;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.data.provider.SortDirection;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.service.RecurringTransactionService;
import org.emblow.envelopify.service.BillReminderService;
import org.emblow.envelopify.ui.MainLayout;
import org.emblow.envelopify.ui.components.EnvelopeSchedulePanel;
import org.emblow.envelopify.ui.components.TransactionManagementDialogs;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.math.BigDecimal;

@Route(value = "envelopes", layout = MainLayout.class)
@AnonymousAllowed
public class EnvelopeView extends VerticalLayout implements HasUrlParameter<Long> {
    
    private final EnvelopeService envelopeService;
    private final TransactionService transactionService;
    private final AccountService accountService;
    private final RecurringTransactionService recurringTransactionService;
    private final BillReminderService billReminderService;
    private final TransactionManagementDialogs transactionDialogs;
    
    private final VerticalLayout contentLayout = new VerticalLayout();
    private Envelope currentEnvelope;
    private final Grid<Transaction> transactionGrid;

    public EnvelopeView(
        EnvelopeService envelopeService,
        TransactionService transactionService,
        AccountService accountService,
        RecurringTransactionService recurringTransactionService,
        BillReminderService billReminderService,
        TransactionManagementDialogs transactionDialogs
    ) {
        this.envelopeService = envelopeService;
        this.transactionService = transactionService;
        this.accountService = accountService;
        this.recurringTransactionService = recurringTransactionService;
        this.billReminderService = billReminderService;
        this.transactionDialogs = transactionDialogs;
        
        setPadding(true);
        setSpacing(true);
        
        // Initialize transaction grid
        transactionGrid = new Grid<>();
        configureTransactionGrid();
        
        // Initialize layout
        contentLayout.setPadding(false);
        contentLayout.setSpacing(true);
        
        add(contentLayout);
    }

    @Override
    public void setParameter(BeforeEvent event, Long envelopeId) {
        currentEnvelope = envelopeService.getEnvelope(envelopeId);
        updateView();
    }
    
    private void updateView() {
        contentLayout.removeAll();
        
        // Header section
        HorizontalLayout header = new HorizontalLayout();
        header.setWidthFull();
        header.setAlignItems(Alignment.CENTER);
        header.setJustifyContentMode(JustifyContentMode.BETWEEN);
        
        H2 title = new H2(currentEnvelope.getName());
        
        Button newTransactionButton = new Button(
            "New Transaction", 
            new Icon(VaadinIcon.PLUS),
            e -> transactionDialogs.showNewTransactionDialog(this::refreshData)
        );
        newTransactionButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        
        header.add(title, newTransactionButton);
        
        // Overview Panel
        Div overviewPanel = createOverviewPanel();
        
        // Tabs for different sections
        Tab overviewTab = new Tab("Overview");
        Tab scheduleTab = new Tab("Schedule");
        Tab historyTab = new Tab("History");
        Tab analyticsTab = new Tab("Analytics");
        
        Tabs tabs = new Tabs(overviewTab, scheduleTab, historyTab, analyticsTab);
        tabs.addSelectedChangeListener(event -> {
            updateContent(event.getSelectedTab());
        });
        
        contentLayout.add(header, overviewPanel, tabs);
        
        // Show initial content
        updateContent(overviewTab);
    }
    
    private Div createOverviewPanel() {
        Div panel = new Div();
        panel.addClassName("overview-panel");
        panel.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("padding", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-m)");
        
        // General stats
        H3 statsTitle = new H3("Envelope Statistics");
        Div statsGrid = new Div();
        statsGrid.getStyle()
            .set("display", "grid")
            .set("grid-template-columns", "repeat(auto-fit, minmax(200px, 1fr))")
            .set("gap", "var(--lumo-space-m)");
        
        addStatCard(statsGrid, "Monthly Budget", 
            String.format("$%.2f", currentEnvelope.getMonthlyBudget()));
        addStatCard(statsGrid, "Available", 
            String.format("$%.2f", currentEnvelope.getAvailable()));
        addStatCard(statsGrid, "Spent This Month", 
            String.format("$%.2f", currentEnvelope.getCurrentMonthSpent()));
        
        // Account breakdown
        H3 accountsTitle = new H3("Account Breakdown");
        Div accountsGrid = new Div();
        accountsGrid.getStyle()
            .set("display", "grid")
            .set("grid-template-columns", "repeat(auto-fit, minmax(250px, 1fr))")
            .set("gap", "var(--lumo-space-m)");
        
        // Calculate spending by account
        Map<Account, BigDecimal> spendingByAccount = calculateSpendingByAccount();
        
        spendingByAccount.forEach((account, amount) -> {
            addAccountCard(accountsGrid, account, amount);
        });
        
        panel.add(statsTitle, statsGrid, accountsTitle, accountsGrid);
        return panel;
    }
    
    private void addStatCard(Div container, String label, String value) {
        Div card = new Div();
        card.getStyle()
            .set("background-color", "var(--lumo-contrast-5pct)")
            .set("padding", "var(--lumo-space-m)")
            .set("border-radius", "var(--lumo-border-radius-m)")
            .set("text-align", "center");
        
        Div labelDiv = new Div();
        labelDiv.setText(label);
        labelDiv.getStyle().set("color", "var(--lumo-secondary-text-color)");
        
        Div valueDiv = new Div();
        valueDiv.setText(value);
        valueDiv.getStyle()
            .set("font-size", "var(--lumo-font-size-xl)")
            .set("font-weight", "bold");
        
        card.add(labelDiv, valueDiv);
        container.add(card);
    }
    
    private void addAccountCard(Div container, Account account, BigDecimal amount) {
        Div card = new Div();
        card.getStyle()
            .set("background-color", "var(--lumo-contrast-5pct)")
            .set("padding", "var(--lumo-space-m)")
            .set("border-radius", "var(--lumo-border-radius-m)");
        
        H3 accountName = new H3(account.getName());
        accountName.getStyle()
            .set("margin", "0")
            .set("margin-bottom", "var(--lumo-space-s)");
        
        Div typeLabel = new Div();
        typeLabel.setText(account.getType().getDisplayName());
        typeLabel.getStyle()
            .set("color", "var(--lumo-secondary-text-color)")
            .set("margin-bottom", "var(--lumo-space-s)");
        
        Div amountLabel = new Div();
        amountLabel.setText(String.format("Spent: $%.2f", amount));
        amountLabel.getStyle()
            .set("font-weight", "bold")
            .set("color", "var(--lumo-primary-text-color)");
        
        card.add(accountName, typeLabel, amountLabel);
        container.add(card);
    }
    
    private Map<Account, BigDecimal> calculateSpendingByAccount() {
        LocalDateTime monthStart = LocalDateTime.now().withDayOfMonth(1).withHour(0).withMinute(0);
        List<Transaction> transactions = transactionService.getRecentTransactions(
            monthStart, 
            LocalDateTime.now()
        );
        
        return transactions.stream()
            .filter(tx -> tx.getEnvelope().getId().equals(currentEnvelope.getId()))
            .collect(Collectors.groupingBy(
                Transaction::getAccount,
                Collectors.reducing(
                    BigDecimal.ZERO,
                    Transaction::getAmount,
                    BigDecimal::add
                )
            ));
    }
    
    private void configureTransactionGrid() {
        transactionGrid.addThemeVariants(GridVariant.LUMO_ROW_STRIPES);
        
        transactionGrid.addColumn(tx -> 
            tx.getDate().format(DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm")))
            .setHeader("Date")
            .setSortable(true)
            .setAutoWidth(true);
            
        transactionGrid.addColumn(Transaction::getDescription)
            .setHeader("Description")
            .setAutoWidth(true);
            
        transactionGrid.addColumn(tx -> 
            String.format("$%.2f", tx.getAmount()))
            .setHeader("Amount")
            .setAutoWidth(true);
        
        // NEW: Add a column to show the transaction type (Income/Expense)
        transactionGrid.addColumn(tx -> 
            tx.getType().toString())
            .setHeader("Type")
            .setAutoWidth(true);
            
        transactionGrid.addColumn(tx -> 
            String.format("%s (%s)", 
                tx.getAccount().getName(),
                tx.getAccount().getType().getDisplayName()))
            .setHeader("Account")
            .setAutoWidth(true);
            
        // Add double-click listener for editing
        transactionGrid.addItemDoubleClickListener(event -> {
            transactionDialogs.showEditTransactionDialog(event.getItem(), this::refreshData);
        });
        
        // Set default sort on the Date column
        GridSortOrder<Transaction> order = new GridSortOrder<>(
            transactionGrid.getColumns().get(0), 
            SortDirection.DESCENDING
        );
        transactionGrid.sort(List.of(order));
    }
    
    private void updateContent(Tab selectedTab) {
        // Remove old content (after header and tabs)
        while (contentLayout.getComponentCount() > 3) {
            contentLayout.remove(contentLayout.getComponentAt(3));
        }
        
        if (selectedTab.getLabel().equals("Overview")) {
            contentLayout.add(createOverviewContent());
        } else if (selectedTab.getLabel().equals("Schedule")) {
            contentLayout.add(new EnvelopeSchedulePanel(
                currentEnvelope,
                recurringTransactionService,
                billReminderService,
                envelopeService,
                accountService
            ));
        } else if (selectedTab.getLabel().equals("History")) {
            contentLayout.add(createHistoryContent());
        } else if (selectedTab.getLabel().equals("Analytics")) {
            contentLayout.add(createAnalyticsContent());
        }
    }
    
    private VerticalLayout createOverviewContent() {
        VerticalLayout layout = new VerticalLayout();
        layout.setSpacing(true);
        layout.setPadding(false);
        
        // Add recent transactions
        H3 recentTitle = new H3("Recent Transactions");
        layout.add(recentTitle, transactionGrid);
        
        refreshData();
        return layout;
    }
    
    private VerticalLayout createHistoryContent() {
        VerticalLayout layout = new VerticalLayout();
        layout.add(transactionGrid);
        refreshData();
        return layout;
    }
    
    private VerticalLayout createAnalyticsContent() {
        VerticalLayout layout = new VerticalLayout();
        // Add spending trends, patterns, etc.
        return layout;
    }
    
    private void refreshData() {
        LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
        List<Transaction> transactions = transactionService.getRecentTransactions(
            oneMonthAgo,
            LocalDateTime.now()
        ).stream()
        .filter(tx -> tx.getEnvelope().getId().equals(currentEnvelope.getId()))
        .collect(Collectors.toList());
        
        transactionGrid.setItems(transactions);
    }
}



=== ./src/main/java/org/emblow/envelopify/ui/views/ChatView.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.service.llm.LLMService;
import org.emblow.envelopify.ui.MainLayout;
import org.emblow.envelopify.ui.components.ChatComponent;


@Route(value = "chat", layout = MainLayout.class)
@PageTitle("Financial Assistant | Envelopify")
@AnonymousAllowed
public class ChatView extends VerticalLayout {
    
    public ChatView(LLMService llmService) {
        addClassName("chat-view");
        setSizeFull();
        setAlignItems(Alignment.CENTER);
        
        H2 header = new H2("Financial Assistant");
        header.getStyle().set("margin-top", "var(--lumo-space-m)");
        
        ChatComponent chat = new ChatComponent(llmService);
        
        add(header, chat);
        setFlexGrow(1, chat);
    }
}



=== ./src/main/java/org/emblow/envelopify/ui/views/DashboardView.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.grid.Grid;
import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.html.H3;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.notification.Notification;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.FlexComponent.Alignment;
import com.vaadin.flow.component.orderedlayout.FlexComponent.JustifyContentMode;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.router.RouteAlias;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.AccountService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.PatternService;
import org.emblow.envelopify.ui.MainLayout;
import org.emblow.envelopify.ui.components.EnvelopeCard;
import org.emblow.envelopify.ui.components.AccountCard;
import org.emblow.envelopify.ui.components.EnvelopeManagementDialogs;
import org.emblow.envelopify.ui.components.AccountDialog;
import java.time.LocalDateTime;
import java.util.List;
import org.emblow.envelopify.ui.components.TransactionManagementDialogs;
import org.emblow.envelopify.service.CSVImportService;
import org.emblow.envelopify.ui.components.CSVImportDialog;
import org.emblow.envelopify.ui.components.SpendingTrendsChart;

@Route(value = "dashboard", layout = MainLayout.class)
@RouteAlias(value = "", layout = MainLayout.class)
@PageTitle("Dashboard | Envelopify")
@AnonymousAllowed
public class DashboardView extends VerticalLayout {
    
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final TransactionService transactionService;
    private final PatternService patternService;
    private final CSVImportService csvImportService;  
    private final Grid<Transaction> transactionGrid = new Grid<>(Transaction.class);
    private final VerticalLayout envelopesLayout = new VerticalLayout();
    private final VerticalLayout accountsLayout = new VerticalLayout();
    private final EnvelopeManagementDialogs envelopeDialogs;
    private final TransactionManagementDialogs txDialogs;
    private final SpendingTrendsChart trendsChart; 

    public DashboardView(
        EnvelopeService envelopeService,
        AccountService accountService,
        TransactionService transactionService,
        PatternService patternService,
        CSVImportService csvImportService  
    ) {
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.transactionService = transactionService;
        this.patternService = patternService;
        this.csvImportService = csvImportService;  
        this.envelopeDialogs = new EnvelopeManagementDialogs(envelopeService);
        this.txDialogs = new TransactionManagementDialogs(
            transactionService, 
            envelopeService,
            accountService,
            patternService
        );
        
        addClassName("dashboard-view");
        setPadding(true);
        setSpacing(true);

        add(createHeader());
        add(createAccountsSection());
        add(createEnvelopesSection());
        add(createRecentTransactionsSection());
        
       trendsChart = new SpendingTrendsChart(transactionService);
       add(trendsChart);  //chart doesnt work
        
        // Initial data load
        refreshData();
    }

    private HorizontalLayout createHeader() {
        HorizontalLayout header = new HorizontalLayout();
        header.setWidthFull();
        header.setPadding(true);
        header.setAlignItems(Alignment.CENTER);
        header.setJustifyContentMode(JustifyContentMode.BETWEEN);

        H2 title = new H2("Welcome to Envelopify");

        HorizontalLayout buttons = new HorizontalLayout();
        buttons.setSpacing(true);

        Button newTransactionButton = new Button(
            "New Transaction", 
            new Icon(VaadinIcon.PLUS_CIRCLE),
            e -> showNewTransactionDialog()
        );
        newTransactionButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);

        Button newEnvelopeButton = new Button(
            "New Envelope", 
            new Icon(VaadinIcon.FOLDER_O),
            e -> showNewEnvelopeDialog()
        );
        newEnvelopeButton.addThemeVariants(ButtonVariant.LUMO_SUCCESS);

        Button newAccountButton = new Button(
            "New Account",
            new Icon(VaadinIcon.PIGGY_BANK),
            e -> showNewAccountDialog()
        );
        newAccountButton.addThemeVariants(ButtonVariant.LUMO_CONTRAST);

        Button importButton = new Button(
            "Import CSV",
            new Icon(VaadinIcon.UPLOAD),
            e -> showImportDialog()
        );
        importButton.addThemeVariants(ButtonVariant.LUMO_CONTRAST);

        buttons.add(importButton, newAccountButton, newTransactionButton, newEnvelopeButton);
        header.add(title, buttons);
        return header;
    }

    private VerticalLayout createAccountsSection() {
        VerticalLayout section = new VerticalLayout();
        section.setPadding(false);
        section.setSpacing(true);
        section.setWidthFull();

        H3 title = new H3("Your Accounts");
        
        accountsLayout.setPadding(false);
        accountsLayout.setSpacing(true);
        accountsLayout.setWidthFull();
        
        section.add(title, accountsLayout);
        return section;
    }

    private VerticalLayout createEnvelopesSection() {
        VerticalLayout section = new VerticalLayout();
        section.setPadding(false);
        section.setSpacing(true);
        section.setWidthFull();

        H3 title = new H3("Your Envelopes");
        
        envelopesLayout.setPadding(false);
        envelopesLayout.setSpacing(true);
        envelopesLayout.setWidthFull();
        
        section.add(title, envelopesLayout);
        return section;
    }

    private VerticalLayout createRecentTransactionsSection() {
        VerticalLayout section = new VerticalLayout();
        section.setPadding(false);
        section.setSpacing(true);
        section.setWidthFull();

        H3 title = new H3("Recent Transactions");

        configureTransactionGrid();

        section.add(title, transactionGrid);
        return section;
    }

    private void configureTransactionGrid() {
        // Configure columns
        transactionGrid.setColumns("date", "description", "amount");
        transactionGrid.addColumn(tx -> tx.getAccount().getName())
            .setHeader("Account")
            .setKey("account");
        transactionGrid.addColumn(tx -> tx.getEnvelope().getName())
            .setHeader("Envelope")
            .setKey("envelope");
        transactionGrid.getColumns().forEach(col -> col.setAutoWidth(true));
        
        // Enable selection
        transactionGrid.setSelectionMode(Grid.SelectionMode.SINGLE);
        
        // Add double-click listener for editing
        transactionGrid.addItemDoubleClickListener(event -> {
            txDialogs.showEditTransactionDialog(event.getItem(), this::refreshData);
        });
        
        transactionGrid.setWidthFull();
    }

    private void showNewTransactionDialog() {
        txDialogs.showNewTransactionDialog(this::refreshData);
    }

    private void showNewEnvelopeDialog() {
        envelopeDialogs.showNewEnvelopeDialog(this::refreshData);
    }

    private void showNewAccountDialog() {
        new AccountDialog(accountService, this::refreshData).open();
    }

    private void showImportDialog() {
        new CSVImportDialog(csvImportService, envelopeService, accountService, this::refreshData).open();
    }

    private void refreshData() {
        try {
            // Load accounts
            List<Account> accounts = accountService.getAllAccounts();
            refreshAccounts(accounts);

            // Load envelopes
            List<Envelope> envelopes = envelopeService.getAllEnvelopes();
            refreshEnvelopes(envelopes);

            // Load recent transactions
            LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
            List<Transaction> recentTransactions = 
                transactionService.getRecentTransactions(oneMonthAgo, LocalDateTime.now());
            transactionGrid.setItems(recentTransactions);
        } catch (Exception e) {
            Notification.show(
                "Error loading dashboard data: " + e.getMessage(),
                3000,
                Notification.Position.MIDDLE
            );
        }
    }

    private void refreshAccounts(List<Account> accounts) {
        accountsLayout.removeAll();
        
        if (accounts.isEmpty()) {
            accountsLayout.add(
                new H3("No accounts yet. Add your first account to get started!")
            );
            return;
        }

        HorizontalLayout row = new HorizontalLayout();
        row.setWidthFull();
        row.setSpacing(true);
        
        for (Account account : accounts) {
            if (row.getComponentCount() >= 3) {
                accountsLayout.add(row);
                row = new HorizontalLayout();
                row.setWidthFull();
                row.setSpacing(true);
            }
            row.add(new AccountCard(account, accountService, this::refreshData));
        }
        
        if (row.getComponentCount() > 0) {
            accountsLayout.add(row);
        }
    }

    private void refreshEnvelopes(List<Envelope> envelopes) {
        envelopesLayout.removeAll();
        
        if (envelopes.isEmpty()) {
            envelopesLayout.add(
                new H3("No envelopes yet. Create your first envelope to get started!")
            );
            return;
        }

        HorizontalLayout row = new HorizontalLayout();
        row.setWidthFull();
        row.setSpacing(true);
        
        for (Envelope envelope : envelopes) {
            if (row.getComponentCount() >= 3) {
                envelopesLayout.add(row);
                row = new HorizontalLayout();
                row.setWidthFull();
                row.setSpacing(true);
            }
            row.add(new EnvelopeCard(envelope, envelopeDialogs));
        }
        
        if (row.getComponentCount() > 0) {
            envelopesLayout.add(row);
        }
    }
}


=== ./src/main/java/org/emblow/envelopify/ui/views/InsightsView.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.ui.views;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.html.H2;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.component.orderedlayout.HorizontalLayout;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import com.vaadin.flow.server.auth.AnonymousAllowed;
import org.emblow.envelopify.ui.MainLayout;
import org.emblow.envelopify.ui.components.InsightsPanel;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.emblow.envelopify.service.ml.SpendingInsight;

import java.util.List;
import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.button.ButtonVariant;
import com.vaadin.flow.component.html.Div;
import com.vaadin.flow.component.icon.Icon;
import com.vaadin.flow.component.icon.VaadinIcon;
import com.vaadin.flow.component.notification.Notification;
import java.util.ArrayList;
import java.util.stream.Collectors;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.ml.AdvancedMLService;
import org.emblow.envelopify.service.ml.SpendingInsightType;
import org.emblow.envelopify.ui.components.SpendingTrendsChart;

@Route(value = "insights", layout = MainLayout.class)
@PageTitle("Smart Insights | Envelopify")
@AnonymousAllowed
public class InsightsView extends VerticalLayout {
    
    private final SpendingInsightService insightService;
    private final TransactionService transactionService;
    private final InsightsPanel regularInsights;
    private final InsightsPanel predictiveInsights;
//    private final SpendingTrendsChart trendsChart; //chart looks shit
    private final AdvancedMLService mlService;
    
     public InsightsView(SpendingInsightService insightService, 
                       TransactionService transactionService,
                       AdvancedMLService mlService) { // Add to constructor
        this.mlService = mlService;
        this.insightService = insightService;
        this.transactionService = transactionService;
        
        addClassName("insights-view");
        setSizeFull();
        setSpacing(true);
        setPadding(true);

        // Header with refresh button
        HorizontalLayout header = new HorizontalLayout();
        header.setWidthFull();
        header.setJustifyContentMode(JustifyContentMode.BETWEEN);
        header.setAlignItems(Alignment.CENTER);

        H2 title = new H2("Smart Insights");
        Button refreshButton = new Button(
            "Refresh Insights", 
            new Icon(VaadinIcon.REFRESH),
            e -> refreshInsights()
        );
        refreshButton.addThemeVariants(ButtonVariant.LUMO_PRIMARY);
        header.add(title, refreshButton);
/** chart looks shit
        // Create spending trends chart card
        Div chartCard = new Div();
        chartCard.addClassName("chart-card");
        chartCard.getStyle()
            .set("background-color", "var(--lumo-base-color)")
            .set("border-radius", "var(--lumo-border-radius-l)")
            .set("box-shadow", "var(--lumo-box-shadow-s)")
            .set("padding", "var(--lumo-space-m)")
            .set("margin-bottom", "var(--lumo-space-m)");

        H2 chartTitle = new H2("Monthly Spending Trends");
        chartTitle.getStyle()
            .set("margin-top", "0")
            .set("margin-bottom", "var(--lumo-space-m)");

        trendsChart = new SpendingTrendsChart(transactionService);

        chartCard.add(chartTitle, trendsChart);
        **/
        // Create layout for insights panels
        HorizontalLayout content = new HorizontalLayout();
        content.setWidthFull();
        content.setSpacing(true);
        
        // Create two columns for different types of insights
        VerticalLayout leftColumn = new VerticalLayout();
        leftColumn.setPadding(false);
        leftColumn.setSpacing(true);
        leftColumn.setWidth("50%");
        leftColumn.add(new H2("Current Insights"));
        
        VerticalLayout rightColumn = new VerticalLayout();
        rightColumn.setPadding(false);
        rightColumn.setSpacing(true);
        rightColumn.setWidth("50%");
        rightColumn.add(new H2("Predictive Insights"));
        
        // Initialize insights panels
        regularInsights = new InsightsPanel();
        predictiveInsights = new InsightsPanel();
        
        leftColumn.add(regularInsights);
        rightColumn.add(predictiveInsights);
        content.add(leftColumn, rightColumn);

        // Add everything to main layout
        add(header, content);

        // Initial data load
        refreshInsights();
    }

    private void refreshInsights() {
        try {
            // 1. Retrieve regular insights from the existing service.
            List<SpendingInsight> allInsights = insightService.generateInsights();

            // 2. Get ML-based analysis for all accounts.
            List<AdvancedMLService.AccountAnalysis> analyses = mlService.analyzeAccounts();
            List<SpendingInsight> mlInsights = new ArrayList<>();

            // 3. Map ML analysis results to SpendingInsight objects.
            for (AdvancedMLService.AccountAnalysis analysis : analyses) {
                // --- Map anomalies ---
                for (AdvancedMLService.AnomalyDetection anomaly : analysis.getAnomalies()) {
                    if (anomaly.type() == AdvancedMLService.AnomalyType.AMOUNT) {
                        mlInsights.add(new SpendingInsight(
                            SpendingInsightType.UNUSUAL_SPENDING,
                            anomaly.description(),
                            anomaly.severity()  // Use anomaly severity as confidence
                        ));
                    } else if (anomaly.type() == AdvancedMLService.AnomalyType.FREQUENCY) {
                        // Optionally map frequency anomalies to recurring payments as well.
                        mlInsights.add(new SpendingInsight(
                            SpendingInsightType.RECURRING_PAYMENT,
                            anomaly.description(),
                            anomaly.severity()
                        ));
                    }
                }

                // --- Map recurring payments from merchant metrics ---
                analysis.getMerchantMetrics().forEach((merchant, metrics) -> {
                    // If the merchant has a high monthly frequency (e.g., at least one transaction per month)
                    if (metrics.monthlyFrequency() >= 1.0) {
                        mlInsights.add(new SpendingInsight(
                            SpendingInsightType.RECURRING_PAYMENT,
                            "Recurring payment detected at " + merchant + " (monthly frequency: " +
                                String.format("%.1f", metrics.monthlyFrequency()) + ")",
                            Math.min(1.0, metrics.monthlyFrequency() / 5.0)  // Arbitrary normalization
                        ));
                    }
                });

                // --- Map predicted expense from overall spending trend ---
                if (analysis.getVolumeTrend() > 0.2) { // Upward trend threshold (adjust as needed)
                    mlInsights.add(new SpendingInsight(
                        SpendingInsightType.PREDICTED_EXPENSE,
                        "Your spending is trending upward for account " + analysis.getAccount().getName() +
                            ". Consider revising your budget.",
                        0.8  // Example confidence value
                    ));
                }

                // --- Map budget suggestions from envelope metrics ---
                analysis.getEnvelopeMetrics().forEach((envelope, envMetrics) -> {
                    // If the envelope's budget utilization is high (e.g., over 90%)
                    if (envMetrics.budgetUtilization() > 0.9) {
                        // Assuming your Envelope domain object has a getName() method.
                        mlInsights.add(new SpendingInsight(
                            SpendingInsightType.BUDGET_SUGGESTION,
                            "Your envelope " + envelope.getName() + " is at " +
                                String.format("%.0f%%", envMetrics.budgetUtilization() * 100) +
                                " of its budget. Consider adjusting your budget.",
                            envMetrics.budgetUtilization()
                        ));
                    }
                });

                // --- Map seasonal patterns ---
                if (analysis.getVolumeTrend() < -0.2) { // Downward trend threshold (adjust as needed)
                    mlInsights.add(new SpendingInsight(
                        SpendingInsightType.SEASONAL_PATTERN,
                        "Your spending trend indicates a seasonal downturn for account " +
                            analysis.getAccount().getName() + ".",
                        0.75
                    ));
                }

                // --- Map reallocation suggestions from cross-account analysis ---
                AdvancedMLService.CrossAccountMetrics crossMetrics = analysis.getCrossAccountMetrics();
                if (crossMetrics != null && !crossMetrics.sharedMerchants().isEmpty()) {
                    mlInsights.add(new SpendingInsight(
                        SpendingInsightType.REALLOCATION_SUGGESTION,
                        "Your spending patterns share similarities with other accounts. Consider reallocation of funds.",
                        0.75  
                    ));
                }
            }

            // Merge regular insights with ML-based insights.
            allInsights.addAll(mlInsights);

            // 4. Split the insights into two categories: current and predictive.
            List<SpendingInsight> current = allInsights.stream()
                .filter(i -> i.getType() == SpendingInsightType.UNUSUAL_SPENDING ||
                             i.getType() == SpendingInsightType.RECURRING_PAYMENT ||
                             i.getType() == SpendingInsightType.BUDGET_SUGGESTION)
                .collect(Collectors.toList());

            List<SpendingInsight> predictive = allInsights.stream()
                .filter(i -> i.getType() == SpendingInsightType.PREDICTED_EXPENSE ||
                             i.getType() == SpendingInsightType.SEASONAL_PATTERN ||
                             i.getType() == SpendingInsightType.REALLOCATION_SUGGESTION)
                .collect(Collectors.toList());

            // 5. Update the InsightsPanel components.
            regularInsights.setInsights(current);
            predictiveInsights.setInsights(predictive);

        } catch (Exception e) {
            Notification.show(
                "Error loading insights: " + e.getMessage(),
                3000,
                Notification.Position.MIDDLE
            );
        }
    }


}



=== ./src/main/java/org/emblow/envelopify/service/BillReminderService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.scheduling.annotation.Scheduled;
import org.emblow.envelopify.domain.BillReminder;
import org.emblow.envelopify.repositry.BillReminderRepository;
import java.time.LocalDate;
import java.util.List;

@Service
public class BillReminderService {
    private final BillReminderRepository repository;

    public BillReminderService(BillReminderRepository repository) {
        this.repository = repository;
    }

    @Transactional
    public BillReminder create(BillReminder reminder) {
        return repository.save(reminder);
    }

    @Transactional
    public void update(Long id, BillReminder updated) {
        BillReminder existing = repository.findById(id)
            .orElseThrow(() -> new RuntimeException("Bill reminder not found"));
            
        existing.setDescription(updated.getDescription());
        existing.setAmount(updated.getAmount());
        existing.setDueDate(updated.getDueDate());
        existing.setReminderDays(updated.getReminderDays());
        existing.setPaid(updated.isPaid());
        existing.setEnvelope(updated.getEnvelope());
        
        repository.save(existing);
    }

    @Transactional
    public void delete(Long id) {
        repository.deleteById(id);
    }

    @Transactional
    public void markAsPaid(Long id) {
        BillReminder reminder = repository.findById(id)
            .orElseThrow(() -> new RuntimeException("Bill reminder not found"));
        reminder.setPaid(true);
        repository.save(reminder);
    }

    public List<BillReminder> getUpcoming() {
        return repository.findByPaidFalseOrderByDueDateAsc();
    }

    public List<BillReminder> getOverdue() {
        return repository.findByPaidFalseAndDueDateBefore(LocalDate.now());
    }

    public List<BillReminder> getAllForEnvelope(Long envelopeId) {
        return repository.findByEnvelopeId(envelopeId);
    }

    @Scheduled(cron = "0 0 9 * * *") // Run daily at 9 AM
    public void checkReminders() {
        List<BillReminder> reminders = repository.findByPaidFalseOrderByDueDateAsc();
        for (BillReminder reminder : reminders) {
            if (reminder.needsReminder()) {
                // TODO: Send notification
                System.out.println("Reminder needed for: " + reminder.getDescription());
            }
        }
    }
}



=== ./src/main/java/org/emblow/envelopify/service/TransactionService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.InsufficientFundsException;
import org.emblow.envelopify.repositry.TransactionRepository;
import org.emblow.envelopify.repositry.EnvelopeRepository;
import org.emblow.envelopify.repositry.AccountRepository;
import org.emblow.envelopify.service.PatternService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Service
public class TransactionService {

    private final TransactionRepository transactionRepository;
    private final EnvelopeRepository envelopeRepository;
    private final AccountRepository accountRepository;
    private final PatternService patternService;

    public TransactionService(
            TransactionRepository transactionRepository,
            EnvelopeRepository envelopeRepository,
            AccountRepository accountRepository,
            PatternService patternService
    ) {
        this.transactionRepository = transactionRepository;
        this.envelopeRepository = envelopeRepository;
        this.accountRepository = accountRepository;
        this.patternService = patternService;
    }
    public List<Transaction> getRecentTransactions(LocalDateTime start, LocalDateTime end) {
        return transactionRepository.findByDateBetweenOrderByDateDesc(start, end);
    }
    /**
     * Records a new transaction. Depending on the transaction type, the method updates the
     * account and envelope balances accordingly.
     *
     * @param envelopeId  the ID of the envelope to which the transaction applies
     * @param accountId   the ID of the account from which the transaction is recorded
     * @param date        the date/time of the transaction
     * @param description a brief description of the transaction
     * @param amount      the transaction amount (must be positive)
     * @param type        the transaction type (INCOME or EXPENSE)
     * @return the saved Transaction object
     */
    @Transactional
    public Transaction recordTransaction(
            Long envelopeId,
            Long accountId,
            LocalDateTime date,
            String description,
            BigDecimal amount,
            TransactionType type
    ) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }

        Envelope envelope = envelopeRepository.findById(envelopeId)
                .orElseThrow(() -> new RuntimeException("Envelope not found"));
        Account account = accountRepository.findById(accountId)
                .orElseThrow(() -> new RuntimeException("Account not found"));

        // Create a new transaction with the given type.
        Transaction transaction = new Transaction(date, description, amount, envelope, account, type);

        if (type == TransactionType.EXPENSE) {
            // For expenses, if the account is a credit card, the amount is used as is;
            // otherwise, subtract the amount from the account balance.
            BigDecimal accountAmount = account.getType() == Account.AccountType.CREDIT_CARD ?
                    amount : amount.negate();
            // Check sufficient funds for non-credit accounts.
            if (account.getType() != Account.AccountType.CREDIT_CARD &&
                    account.getBalance().subtract(amount).compareTo(BigDecimal.ZERO) < 0) {
                throw new InsufficientFundsException(account.getName(), amount);
            }
            envelope.spend(amount);
            account.debit(accountAmount);
        } else if (type == TransactionType.INCOME) {
            // For income transactions, add funds to both the envelope and the account.
            envelope.allocate(amount);
            account.credit(amount);
        } else {
            throw new IllegalArgumentException("Unsupported transaction type");
        }

        // Save the updated envelope and account.
        envelopeRepository.save(envelope);
        accountRepository.save(account);
        Transaction saved = transactionRepository.save(transaction);

        // Update any pattern learning based on the new transaction.
        updatePatternLearning(saved);

        return saved;
    }

    /**
     * Updates an existing transaction. This method first reverses the effects of the old
     * transaction (based on its type) and then applies the new values and effects.
     *
     * @param id          the ID of the transaction to update
     * @param envelopeId  the new envelope ID
     * @param accountId   the new account ID
     * @param date        the new transaction date/time
     * @param description the new description
     * @param amount      the new amount (must be positive)
     * @param newType     the new transaction type (INCOME or EXPENSE)
     * @return the updated Transaction object
     */
    @Transactional
    public Transaction updateTransaction(
            Long id,
            Long envelopeId,
            Long accountId,
            LocalDateTime date,
            String description,
            BigDecimal amount,
            TransactionType newType
    ) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }

        Transaction transaction = transactionRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Transaction not found"));

        // Save old state for reversal.
        Envelope oldEnvelope = transaction.getEnvelope();
        Account oldAccount = transaction.getAccount();
        BigDecimal oldAmount = transaction.getAmount();
        TransactionType oldType = transaction.getType();

        // Look up the new envelope and account.
        Envelope newEnvelope = envelopeRepository.findById(envelopeId)
                .orElseThrow(() -> new RuntimeException("Envelope not found"));
        Account newAccount = accountRepository.findById(accountId)
                .orElseThrow(() -> new RuntimeException("Account not found"));

        // Reverse the effects of the old transaction.
        if (oldType == TransactionType.EXPENSE) {
            oldEnvelope.unspend(oldAmount);
            BigDecimal oldAccountAmount = oldAccount.getType() == Account.AccountType.CREDIT_CARD ?
                    oldAmount : oldAmount.negate();
            oldAccount.credit(oldAccountAmount);
        } else if (oldType == TransactionType.INCOME) {
            oldEnvelope.unallocate(oldAmount);
            oldAccount.debit(oldAmount);
        }

        // Apply the new transaction effects.
        if (newType == TransactionType.EXPENSE) {
            newEnvelope.spend(amount);
            BigDecimal newAccountAmount = newAccount.getType() == Account.AccountType.CREDIT_CARD ?
                    amount : amount.negate();
            if (newAccount.getType() != Account.AccountType.CREDIT_CARD &&
                    newAccount.getBalance().subtract(amount).compareTo(BigDecimal.ZERO) < 0) {
                throw new InsufficientFundsException(newAccount.getName(), amount);
            }
            newAccount.debit(newAccountAmount);
        } else if (newType == TransactionType.INCOME) {
            newEnvelope.allocate(amount);
            newAccount.credit(amount);
        } else {
            throw new IllegalArgumentException("Unsupported transaction type");
        }

        // Update the transaction details.
        transaction.setDate(date);
        transaction.setDescription(description);
        transaction.setAmount(amount);
        transaction.setEnvelope(newEnvelope);
        transaction.setAccount(newAccount);
        transaction.setType(newType);

        // Save changes to the envelopes and accounts.
        envelopeRepository.save(oldEnvelope);
        if (!oldEnvelope.getId().equals(newEnvelope.getId())) {
            envelopeRepository.save(newEnvelope);
        }
        accountRepository.save(oldAccount);
        if (!oldAccount.getId().equals(newAccount.getId())) {
            accountRepository.save(newAccount);
        }

        Transaction updated = transactionRepository.save(transaction);

        if (!oldEnvelope.getId().equals(newEnvelope.getId())) {
            updatePatternLearning(updated);
        }

        return updated;
    }

    /**
     * Deletes a transaction by reversing its effects on the envelope and account balances,
     * then removing it from the repository.
     *
     * @param id the ID of the transaction to delete
     */
    @Transactional
    public void deleteTransaction(Long id) {
        Transaction transaction = transactionRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Transaction not found"));

        Envelope envelope = transaction.getEnvelope();
        Account account = transaction.getAccount();
        BigDecimal amount = transaction.getAmount();
        TransactionType type = transaction.getType();

        if (type == TransactionType.EXPENSE) {
            envelope.unspend(amount);
            BigDecimal accountAmount = account.getType() == Account.AccountType.CREDIT_CARD ?
                    amount : amount.negate();
            account.credit(accountAmount);
        } else if (type == TransactionType.INCOME) {
            envelope.unallocate(amount);
            account.debit(amount);
        }

        envelopeRepository.save(envelope);
        accountRepository.save(account);
        transactionRepository.delete(transaction);
    }

    /**
     * Helper method to update pattern learning. Exceptions are logged but do not interrupt
     * transaction processing.
     *
     * @param transaction the transaction to use for updating patterns
     */
    private void updatePatternLearning(Transaction transaction) {
        try {
            patternService.suggestEnvelopes(transaction);
        } catch (Exception e) {
            System.err.println("Error updating pattern learning: " + e.getMessage());
        }
    }
}



=== ./src/main/java/org/emblow/envelopify/service/InitializationService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.stereotype.Service;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.emblow.envelopify.repositry.AccountRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class InitializationService {
    private static final Logger log = LoggerFactory.getLogger(InitializationService.class);
    
    private final AccountRepository accountRepository;
    private final TestDataService testDataService;
    
    public InitializationService(
        AccountRepository accountRepository,
        TestDataService testDataService
    ) {
        this.accountRepository = accountRepository;
        this.testDataService = testDataService;
    }
    
    @EventListener(ApplicationReadyEvent.class)
    public void onApplicationReady() {
        initializeTestData();
    }
    
    private void initializeTestData() {
        // Only initialize if no accounts exist
        if (accountRepository.count() == 0) {
            log.info("No existing data found. Initializing test data...");
            try {
                testDataService.createTestData();
                log.info("Test data initialization complete.");
            } catch (Exception e) {
                log.error("Error initializing test data", e);
            }
        } else {
            log.info("Existing data found. Skipping test data initialization.");
        }
    }
}



=== ./src/main/java/org/emblow/envelopify/service/PatternService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.repositry.TransactionRepository;
import org.emblow.envelopify.repositry.EnvelopeRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.time.LocalDateTime;
import java.math.BigDecimal;

@Service
public class PatternService {
    private final TransactionRepository transactionRepository;
    private final EnvelopeRepository envelopeRepository;

    public PatternService(
        TransactionRepository transactionRepository,
        EnvelopeRepository envelopeRepository
    ) {
        this.transactionRepository = transactionRepository;
        this.envelopeRepository = envelopeRepository;
    }

    /**
     * Suggests envelopes for a transaction based on historical patterns.
     * Returns a map of envelopes to confidence scores (0-1).
     */
    public Map<Envelope, Double> suggestEnvelopes(Transaction transaction) {
        Map<Envelope, Double> suggestions = new HashMap<>();
        double totalScore = 0.0;

        // Get all recent transactions
        LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
        List<Transaction> recentTransactions = transactionRepository
            .findByDateBetweenOrderByDateDesc(oneMonthAgo, LocalDateTime.now());

        // Score each envelope based on merchant name matches
        for (Envelope envelope : envelopeRepository.findAll()) {
            double score = scoreEnvelopeMatch(transaction, envelope, recentTransactions);
            if (score > 0) {
                suggestions.put(envelope, score);
                totalScore += score;
            }
        }

        // Normalize scores
        if (totalScore > 0) {
            for (Map.Entry<Envelope, Double> entry : suggestions.entrySet()) {
                entry.setValue(entry.getValue() / totalScore);
            }
        }

        return suggestions;
    }

    private double scoreEnvelopeMatch(
        Transaction newTransaction,
        Envelope envelope,
        List<Transaction> recentTransactions
    ) {
        double score = 0.0;

        // Find similar transactions in this envelope
        List<Transaction> envelopeTransactions = recentTransactions.stream()
            .filter(t -> t.getEnvelope().getId().equals(envelope.getId()))
            .toList();

        for (Transaction past : envelopeTransactions) {
            // Score based on description similarity
            if (isSimilarDescription(newTransaction.getDescription(), past.getDescription())) {
                score += 1.0;
            }

            // Score based on amount similarity
            if (isSimilarAmount(newTransaction.getAmount(), past.getAmount())) {
                score += 0.5;
            }

            // Score based on timing (day of week/month)
            if (isSimilarTiming(newTransaction.getDate(), past.getDate())) {
                score += 0.25;
            }
        }

        return score;
    }

    private boolean isSimilarDescription(String desc1, String desc2) {
        if (desc1 == null || desc2 == null) {
            return false;
        }
        return desc1.toLowerCase().contains(desc2.toLowerCase()) ||
               desc2.toLowerCase().contains(desc1.toLowerCase());
    }

    private boolean isSimilarAmount(BigDecimal amount1, BigDecimal amount2) {
        if (amount1 == null || amount2 == null) {
            return false;
        }
        // Consider amounts within 10% of each other similar
        BigDecimal diff = amount1.subtract(amount2).abs();
        BigDecimal threshold = amount1.multiply(new BigDecimal("0.1"));
        return diff.compareTo(threshold) <= 0;
    }

    private boolean isSimilarTiming(LocalDateTime date1, LocalDateTime date2) {
        if (date1 == null || date2 == null) {
            return false;
        }
        return date1.getDayOfWeek() == date2.getDayOfWeek() ||
               date1.getDayOfMonth() == date2.getDayOfMonth();
    }
}



=== ./src/main/java/org/emblow/envelopify/service/EnvelopeService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Envelope;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.util.List;
import org.emblow.envelopify.domain.InsufficientFundsException;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.repositry.EnvelopeRepository;

@Service
public class EnvelopeService {
    private final EnvelopeRepository envelopeRepository;

    public EnvelopeService(EnvelopeRepository envelopeRepository) {
        this.envelopeRepository = envelopeRepository;
    }

    public List<Envelope> getAllEnvelopes() {
        return envelopeRepository.findAll();
    }

    @Transactional
    public Envelope getEnvelope(Long id) {
        return envelopeRepository.findByIdWithTransactions(id)
            .orElseThrow(() -> new RuntimeException("Envelope not found"));
    }


    @Transactional
    public Envelope createEnvelope(String name, BigDecimal initialAllocation) {
        Envelope envelope = new Envelope(name, initialAllocation);
        return envelopeRepository.save(envelope);
    }

    @Transactional
    public void reallocate(Long sourceId, Long targetId, BigDecimal amount) {
        if (amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
        Envelope source = getEnvelope(sourceId);
        Envelope target = getEnvelope(targetId);
        if (sourceId.equals(targetId)) {
            throw new IllegalArgumentException("Cannot move money to the same envelope");
        }
        // Check if source has enough funds
        if (!source.canSpend(amount)) {
            throw new InsufficientFundsException(
                source.getName(),
                amount
            );
        }
        source.withdraw(amount);
        target.allocate(amount);
        envelopeRepository.save(source);
        envelopeRepository.save(target);
    }

    @Transactional
    public Envelope save(Envelope envelope) {
        return envelopeRepository.save(envelope);
    }

    @Transactional
    public Envelope updateEnvelope(Long id, String name) {
        Envelope envelope = getEnvelope(id);
        envelope.setName(name);
        return envelopeRepository.save(envelope);
    }
    @Transactional
public void flush() {
    envelopeRepository.flush();
}

    @Transactional
    public void deleteEnvelope(Long sourceId, Long targetId) {
        Envelope source = getEnvelope(sourceId);
        Envelope target = getEnvelope(targetId);

        if (sourceId.equals(targetId)) {
            throw new IllegalArgumentException("Cannot transfer to the same envelope");
        }

        // Transfer the total allocation to the target envelope
        target.allocate(source.getAllocated());

        // Add the spent amount to the target envelope via proper business logic
        // We must add the spent amount AFTER allocating or we might trigger insufficient funds checks
        if (source.getSpent().compareTo(BigDecimal.ZERO) > 0) {
            target.spend(source.getSpent());
        }

        // Update all transactions to point to the target envelope
        List<Transaction> transactions = source.getTransactions();
        for (Transaction transaction : transactions) {
            transaction.setEnvelope(target);
        }

        // Save the target envelope with updated allocations and transactions
        envelopeRepository.save(target);

        // Now we can safely delete the source envelope
        envelopeRepository.deleteById(sourceId);
    }
}


=== ./src/main/java/org/emblow/envelopify/service/ml/TransactionNaiveBayes.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */
import java.util.*;
import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.Month;
import java.math.BigDecimal;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.emblow.envelopify.domain.Account;
import java.util.stream.Collectors;

public class TransactionNaiveBayes {
    private static final Logger log = LoggerFactory.getLogger(TransactionNaiveBayes.class);
    
    // Probability tables
    private final Map<String, Double> categoryPriors = new HashMap<>();
    private final Map<String, Map<String, Double>> wordLikelihoods = new HashMap<>();
    private final Map<String, GaussianDistribution> amountDistributions = new HashMap<>();
    private final Map<String, Map<DayOfWeek, Double>> dayOfWeekLikelihoods = new HashMap<>();
    private final Map<String, Map<Month, Double>> monthLikelihoods = new HashMap<>();
    private final Map<String, Map<Account.AccountType, Double>> accountTypeLikelihoods = new HashMap<>();
    private final Map<String, Map<String, Double>> accountNameLikelihoods = new HashMap<>();
    
    // Smoothing parameters
    private static final double ALPHA = 1.0;  // Laplace smoothing
    private static final double MIN_STD_DEV = 0.01;  // Minimum standard deviation
    
    // Feature weights
    private static final double WORD_WEIGHT = 0.4;
    private static final double AMOUNT_WEIGHT = 0.25;
    private static final double TIME_WEIGHT = 0.15;
    private static final double ACCOUNT_TYPE_WEIGHT = 0.1;
    private static final double ACCOUNT_NAME_WEIGHT = 0.1;
    
    private final Set<String> vocabulary = new HashSet<>();
    private final TextPreprocessor textPreprocessor;
    
    public TransactionNaiveBayes() {
        this.textPreprocessor = new TextPreprocessor();
    }
    
    public void train(List<TransactionFeatures> transactions) {
        log.info("Training NBC with {} transactions", transactions.size());
        
        // Clear previous state
        categoryPriors.clear();
        wordLikelihoods.clear();
        amountDistributions.clear();
        dayOfWeekLikelihoods.clear();
        monthLikelihoods.clear();
        accountTypeLikelihoods.clear();
        accountNameLikelihoods.clear();
        vocabulary.clear();
        
        // Count category frequencies
        Map<String, Integer> categoryCounts = new HashMap<>();
        for (TransactionFeatures tx : transactions) {
            categoryCounts.merge(tx.category(), 1, Integer::sum);
        }
        
        // Calculate priors
        int totalTransactions = transactions.size();
        categoryCounts.forEach((category, count) -> 
            categoryPriors.put(category, (count.doubleValue() + ALPHA) / 
                (totalTransactions + ALPHA * categoryCounts.size())));
        
        // Build vocabulary
        transactions.forEach(tx -> 
            vocabulary.addAll(Arrays.asList(textPreprocessor.tokenize(tx.description()))));
        
        // Initialize likelihood tables
        for (String category : categoryCounts.keySet()) {
            wordLikelihoods.put(category, new HashMap<>());
            dayOfWeekLikelihoods.put(category, new HashMap<>());
            monthLikelihoods.put(category, new HashMap<>());
            accountTypeLikelihoods.put(category, new HashMap<>());
            accountNameLikelihoods.put(category, new HashMap<>());
        }
        
        // Calculate all likelihoods
        calculateWordLikelihoods(transactions, categoryCounts);
        calculateAmountDistributions(transactions, categoryCounts);
        calculateTemporalLikelihoods(transactions, categoryCounts);
        calculateAccountLikelihoods(transactions, categoryCounts);
        
        log.info("Training complete. Vocabulary size: {}", vocabulary.size());
    }
    
    public Map<String, Double> predict(TransactionFeatures transaction) {
        Map<String, Double> scores = new HashMap<>();
        double totalScore = 0.0;
        
        // Calculate scores for each category
        for (String category : categoryPriors.keySet()) {
            double score = Math.log(categoryPriors.get(category));
            
            // Word features
            String[] words = textPreprocessor.tokenize(transaction.description());
            double wordScore = 0.0;
            for (String word : words) {
                if (vocabulary.contains(word)) {
                    wordScore += Math.log(wordLikelihoods.get(category)
                        .getOrDefault(word, ALPHA / (vocabulary.size() * ALPHA)));
                }
            }
            
            // Amount feature
            double amountScore = amountDistributions.get(category)
                .logProbability(transaction.amount().doubleValue());
            
            // Temporal features
            double dayScore = Math.log(dayOfWeekLikelihoods.get(category)
                .getOrDefault(transaction.date().getDayOfWeek(), 
                    ALPHA / (7 * ALPHA)));
            double monthScore = Math.log(monthLikelihoods.get(category)
                .getOrDefault(transaction.date().getMonth(), 
                    ALPHA / (12 * ALPHA)));
                    
            // Account features
            double accountTypeScore = Math.log(accountTypeLikelihoods.get(category)
                .getOrDefault(transaction.accountType(), 
                    ALPHA / (Account.AccountType.values().length * ALPHA)));
                    
            double accountNameScore = Math.log(accountNameLikelihoods.get(category)
                .getOrDefault(transaction.accountName(), 
                    ALPHA / accountNameLikelihoods.size()));
            
            // Combine scores with weights
            score += WORD_WEIGHT * wordScore +
                    AMOUNT_WEIGHT * amountScore +
                    TIME_WEIGHT * (dayScore + monthScore) +
                    ACCOUNT_TYPE_WEIGHT * accountTypeScore +
                    ACCOUNT_NAME_WEIGHT * accountNameScore;
            
            scores.put(category, Math.exp(score));
            totalScore += Math.exp(score);
        }
        
        // Normalize probabilities
        Map<String, Double> normalizedScores = new HashMap<>();
        for (Map.Entry<String, Double> entry : scores.entrySet()) {
            normalizedScores.put(entry.getKey(), entry.getValue() / totalScore);
        }
        
        return normalizedScores;
    }
    
    private void calculateWordLikelihoods(
        List<TransactionFeatures> transactions,
        Map<String, Integer> categoryCounts
    ) {
        // Count word occurrences per category
        Map<String, Map<String, Integer>> wordCounts = new HashMap<>();
        categoryCounts.keySet().forEach(category -> 
            wordCounts.put(category, new HashMap<>()));
        
        for (TransactionFeatures tx : transactions) {
            String[] words = textPreprocessor.tokenize(tx.description());
            for (String word : words) {
                wordCounts.get(tx.category()).merge(word, 1, Integer::sum);
            }
        }
        
        // Calculate likelihoods with Laplace smoothing
        for (String category : categoryCounts.keySet()) {
            int totalWords = wordCounts.get(category).values().stream()
                .mapToInt(Integer::intValue).sum();
            
            for (String word : vocabulary) {
                int count = wordCounts.get(category).getOrDefault(word, 0);
                double likelihood = (count + ALPHA) / 
                    (totalWords + ALPHA * vocabulary.size());
                wordLikelihoods.get(category).put(word, likelihood);
            }
        }
    }
    
    private void calculateAccountLikelihoods(
        List<TransactionFeatures> transactions,
        Map<String, Integer> categoryCounts
    ) {
        // Count account patterns per category
        Map<String, Map<Account.AccountType, Integer>> typeCountsByCategory = new HashMap<>();
        Map<String, Map<String, Integer>> nameCountsByCategory = new HashMap<>();
        
        for (TransactionFeatures tx : transactions) {
            // Account type counts
            typeCountsByCategory
                .computeIfAbsent(tx.category(), k -> new HashMap<>())
                .merge(tx.accountType(), 1, Integer::sum);
                
            // Account name counts
            nameCountsByCategory
                .computeIfAbsent(tx.category(), k -> new HashMap<>())
                .merge(tx.accountName(), 1, Integer::sum);
        }
        
        // Calculate likelihoods with smoothing
        for (String category : categoryCounts.keySet()) {
            int totalTx = categoryCounts.get(category);
            
            // Account type likelihoods
            for (Account.AccountType type : Account.AccountType.values()) {
                int count = typeCountsByCategory
                    .getOrDefault(category, Map.of())
                    .getOrDefault(type, 0);
                    
                double likelihood = (count + ALPHA) / 
                    (totalTx + ALPHA * Account.AccountType.values().length);
                    
                accountTypeLikelihoods.get(category).put(type, likelihood);
            }
            
            // Account name likelihoods
            Set<String> allAccountNames = nameCountsByCategory.values().stream()
                .flatMap(m -> m.keySet().stream())
                .collect(Collectors.toSet());
                
            for (String name : allAccountNames) {
                int count = nameCountsByCategory
                    .getOrDefault(category, Map.of())
                    .getOrDefault(name, 0);
                    
                double likelihood = (count + ALPHA) / 
                    (totalTx + ALPHA * allAccountNames.size());
                    
                accountNameLikelihoods.get(category).put(name, likelihood);
            }
        }
    }
    
    private void calculateAmountDistributions(
        List<TransactionFeatures> transactions,
        Map<String, Integer> categoryCounts
    ) {
        // Group amounts by category
        Map<String, List<Double>> amountsByCategory = new HashMap<>();
        categoryCounts.keySet().forEach(category -> 
            amountsByCategory.put(category, new ArrayList<>()));
        
        transactions.forEach(tx -> 
            amountsByCategory.get(tx.category())
                .add(tx.amount().doubleValue()));
        
        // Calculate distributions
        amountsByCategory.forEach((category, amounts) -> {
            double mean = amounts.stream()
                .mapToDouble(Double::doubleValue)
                .average()
                .orElse(0.0);
            
            double variance = amounts.stream()
                .mapToDouble(a -> Math.pow(a - mean, 2))
                .average()
                .orElse(MIN_STD_DEV);
            
            amountDistributions.put(category, 
                new GaussianDistribution(mean, Math.sqrt(variance)));
        });
    }
    
    private void calculateTemporalLikelihoods(
        List<TransactionFeatures> transactions,
        Map<String, Integer> categoryCounts
    ) {
        // Count temporal patterns
        Map<String, Map<DayOfWeek, Integer>> dayCountsByCategory = new HashMap<>();
        Map<String, Map<Month, Integer>> monthCountsByCategory = new HashMap<>();
        
        categoryCounts.keySet().forEach(category -> {
            dayCountsByCategory.put(category, new HashMap<>());
            monthCountsByCategory.put(category, new HashMap<>());
        });
        
        for (TransactionFeatures tx : transactions) {
            dayCountsByCategory.get(tx.category())
                .merge(tx.date().getDayOfWeek(), 1, Integer::sum);
            monthCountsByCategory.get(tx.category())
                .merge(tx.date().getMonth(), 1, Integer::sum);
        }
        
        // Calculate likelihoods with Laplace smoothing
        for (String category : categoryCounts.keySet()) {
            // Days of week
            int totalDays = dayCountsByCategory.get(category).values().stream()
                .mapToInt(Integer::intValue).sum();
            
            for (DayOfWeek day : DayOfWeek.values()) {
                int count = dayCountsByCategory.get(category)
                    .getOrDefault(day, 0);
                double likelihood = (count + ALPHA) / (totalDays + 7 * ALPHA);
                dayOfWeekLikelihoods.get(category).put(day, likelihood);
            }
            
            // Months
            int totalMonths = monthCountsByCategory.get(category).values().stream()
                .mapToInt(Integer::intValue).sum();
            
            for (Month month : Month.values()) {
                int count = monthCountsByCategory.get(category)
                    .getOrDefault(month, 0);
                double likelihood = (count + ALPHA) / (totalMonths + 12 * ALPHA);
                monthLikelihoods.get(category).put(month, likelihood);
            }
        }
    }
    
    // Helper class for Gaussian distribution calculations
    private static class GaussianDistribution {
        private final double mean;
        private final double stdDev;
        
        public GaussianDistribution(double mean, double stdDev) {
            this.mean = mean;
            this.stdDev = Math.max(stdDev, MIN_STD_DEV);
        }
        
        public double logProbability(double x) {
            double zScore = (x - mean) / stdDev;
            return -0.5 * (Math.log(2 * Math.PI) + 
                2 * Math.log(stdDev) + zScore * zScore);
        }
    }
    
    // Helper class for text preprocessing
    private static class TextPreprocessor {
        public String[] tokenize(String text) {
            return text.toLowerCase()
                .replaceAll("[^a-z0-9\\s]", "")
                .split("\\s+");
        }
    }

    // Feature record
    public record TransactionFeatures(
        String description,
        BigDecimal amount,
        LocalDateTime date,
        String category,
        Account.AccountType accountType,
        String accountName
    ) {
        public static TransactionFeatures fromTransaction(
            org.emblow.envelopify.domain.Transaction tx
        ) {
            return new TransactionFeatures(
                tx.getDescription(),
                tx.getAmount(),
                tx.getDate(),
                tx.getEnvelope().getName(),
                tx.getAccount().getType(),
                tx.getAccount().getName()
            );
        }
    }
}


=== ./src/main/java/org/emblow/envelopify/service/ml/SpendingInsight.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */
public class SpendingInsight {
    private final SpendingInsightType type;
    private final String message;
    private final double confidence;

    public SpendingInsight(SpendingInsightType type, String message, double confidence) {
        this.type = type;
        this.message = message;
        this.confidence = confidence;
    }

    public SpendingInsightType getType() {
        return type;
    }

    public String getMessage() {
        return message;
    }

    public double getConfidence() {
        return confidence;
    }
}


=== ./src/main/java/org/emblow/envelopify/service/ml/SpendingInsightType.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */
public enum SpendingInsightType {
    RECURRING_PAYMENT,
    UNUSUAL_SPENDING,
    PREDICTED_EXPENSE,
    BUDGET_SUGGESTION,
    SEASONAL_PATTERN,
    REALLOCATION_SUGGESTION
}




=== ./src/main/java/org/emblow/envelopify/service/ml/TransactionClassifier.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.stereotype.Service;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.repositry.TransactionRepository;
import org.emblow.envelopify.repositry.EnvelopeRepository;
import org.emblow.envelopify.service.ml.TransactionNaiveBayes.TransactionFeatures;

import java.time.*;
import java.util.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.math.BigDecimal;

@Service
public class TransactionClassifier {
    private static final Logger log = LoggerFactory.getLogger(TransactionClassifier.class);
    
    private final TransactionRepository transactionRepository;
    private final EnvelopeRepository envelopeRepository;
    private final TransactionNaiveBayes classifier;
    
    // Cache of account-specific models
    private final Map<Account.AccountType, TransactionNaiveBayes> accountTypeModels = new HashMap<>();
    private final Map<String, TransactionNaiveBayes> accountSpecificModels = new HashMap<>();

    public TransactionClassifier(
        TransactionRepository transactionRepository,
        EnvelopeRepository envelopeRepository
    ) {
        this.transactionRepository = transactionRepository;
        this.envelopeRepository = envelopeRepository;
        this.classifier = new TransactionNaiveBayes();
    }

    public void trainModel() {
        List<Transaction> transactions = transactionRepository.findAll();
        if (transactions.isEmpty()) {
            log.warn("No transactions available for training");
            return;
        }

        // Train main classifier
        List<TransactionFeatures> features = transactions.stream()
            .map(TransactionFeatures::fromTransaction)
            .toList();
        classifier.train(features);
        
        // Train account type specific models
        for (Account.AccountType accountType : Account.AccountType.values()) {
            List<Transaction> accountTypeTransactions = transactions.stream()
                .filter(tx -> tx.getAccount().getType() == accountType)
                .toList();
                
            if (!accountTypeTransactions.isEmpty()) {
                TransactionNaiveBayes typeModel = new TransactionNaiveBayes();
                typeModel.train(accountTypeTransactions.stream()
                    .map(TransactionFeatures::fromTransaction)
                    .toList());
                accountTypeModels.put(accountType, typeModel);
            }
        }
        
        // Train account-specific models
        Set<String> accountNames = transactions.stream()
            .map(tx -> tx.getAccount().getName())
            .collect(java.util.stream.Collectors.toSet());
            
        for (String accountName : accountNames) {
            List<Transaction> accountTransactions = transactions.stream()
                .filter(tx -> tx.getAccount().getName().equals(accountName))
                .toList();
                
            if (accountTransactions.size() >= 50) { // Only train if enough data
                TransactionNaiveBayes accountModel = new TransactionNaiveBayes();
                accountModel.train(accountTransactions.stream()
                    .map(TransactionFeatures::fromTransaction)
                    .toList());
                accountSpecificModels.put(accountName, accountModel);
            }
        }
        
        log.info("Model trained with {} transactions", transactions.size());
    }

    public Map<Envelope, Double> predictCategory(Transaction transaction) {
        TransactionFeatures features = TransactionFeatures.fromTransaction(transaction);
        
        // Get predictions from different models
        Map<String, Double> generalPredictions = classifier.predict(features);
        Map<String, Double> typeSpecificPredictions = accountTypeModels
            .getOrDefault(transaction.getAccount().getType(), classifier)
            .predict(features);
        Map<String, Double> accountSpecificPredictions = accountSpecificModels
            .getOrDefault(transaction.getAccount().getName(), classifier)
            .predict(features);
            
        // Weighted combination of predictions
        Map<String, Double> combinedPredictions = new HashMap<>();
        Set<String> allCategories = new HashSet<>();
        allCategories.addAll(generalPredictions.keySet());
        allCategories.addAll(typeSpecificPredictions.keySet());
        allCategories.addAll(accountSpecificPredictions.keySet());
        
        for (String category : allCategories) {
            double generalWeight = 0.4;
            double typeWeight = 0.3;
            double accountWeight = 0.3;
            
            double combinedScore = 
                generalWeight * generalPredictions.getOrDefault(category, 0.0) +
                typeWeight * typeSpecificPredictions.getOrDefault(category, 0.0) +
                accountWeight * accountSpecificPredictions.getOrDefault(category, 0.0);
                
            combinedPredictions.put(category, combinedScore);
        }
        
        // Normalize combined scores
        double totalScore = combinedPredictions.values().stream()
            .mapToDouble(Double::doubleValue)
            .sum();
            
        Map<String, Double> normalizedPredictions = new HashMap<>();
        combinedPredictions.forEach((category, score) -> 
            normalizedPredictions.put(category, score / totalScore));
        
        // Convert category names to envelopes
        Map<Envelope, Double> predictions = new HashMap<>();
        normalizedPredictions.forEach((categoryName, probability) -> {
            if (probability > 0.05) { // Only include non-trivial probabilities
                transactionRepository.findByEnvelopeName(categoryName)
                    .stream()
                    .findFirst()
                    .ifPresent(tx -> predictions.put(tx.getEnvelope(), probability));
            }
        });
        
        return predictions;
    }

    public Map<Envelope, Double> suggestEnvelopesForAccount(Account account) {
        // Get recent transactions for this account
        LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
        List<Transaction> accountTransactions = transactionRepository.findAll().stream()
            .filter(tx -> tx.getAccount().getId().equals(account.getId()))
            .filter(tx -> tx.getDate().isAfter(oneMonthAgo))
            .toList();
            
        if (accountTransactions.isEmpty()) {
            return Map.of();
        }
        
        // Calculate envelope usage frequencies
        Map<Envelope, Integer> envelopeCounts = new HashMap<>();
        Map<Envelope, BigDecimal> envelopeAmounts = new HashMap<>();
        
        for (Transaction tx : accountTransactions) {
            envelopeCounts.merge(tx.getEnvelope(), 1, Integer::sum);
            envelopeAmounts.merge(tx.getEnvelope(), tx.getAmount(), BigDecimal::add);
        }
        
        // Calculate scores based on both frequency and amount
        Map<Envelope, Double> scores = new HashMap<>();
        double totalTransactions = accountTransactions.size();
        BigDecimal totalAmount = envelopeAmounts.values().stream()
            .reduce(BigDecimal.ZERO, BigDecimal::add);
            
        envelopeCounts.forEach((envelope, count) -> {
            double frequencyScore = count / totalTransactions;
            double amountScore = envelopeAmounts.get(envelope)
                .divide(totalAmount, 2, java.math.RoundingMode.HALF_UP)
                .doubleValue();
            scores.put(envelope, 0.5 * frequencyScore + 0.5 * amountScore);
        });
        
        return scores;
    }

    public void retrain() {
        accountTypeModels.clear();
        accountSpecificModels.clear();
        trainModel();
    }
}


=== ./src/main/java/org/emblow/envelopify/service/ml/SpendingInsightService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.stereotype.Service;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.repositry.TransactionRepository;
import org.emblow.envelopify.repositry.AccountRepository;

import java.time.*;
import java.util.*;
import java.util.stream.Collectors;
import java.math.BigDecimal;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class SpendingInsightService {
    private static final Logger log = LoggerFactory.getLogger(SpendingInsightService.class);
    
    private final TransactionRepository transactionRepository;
    private final AccountRepository accountRepository;
    private final TransactionClassifier classifier;

    public SpendingInsightService(
        TransactionRepository transactionRepository,
        AccountRepository accountRepository,
        TransactionClassifier classifier
    ) {
        this.transactionRepository = transactionRepository;
        this.accountRepository = accountRepository;
        this.classifier = classifier;
    }

    public List<SpendingInsight> generateInsights() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        try {
            // Add different types of insights
            insights.addAll(detectRecurringPayments());
            insights.addAll(detectUnusualSpending());
            insights.addAll(predictUpcomingExpenses());
            insights.addAll(generateBudgetSuggestions());
            insights.addAll(generateAccountSpecificInsights());
            insights.addAll(detectCrossAccountPatterns());
            
            log.debug("Generated {} insights", insights.size());
        } catch (Exception e) {
            log.error("Error generating insights", e);
        }
        
        return insights;
    }

    private List<SpendingInsight> detectRecurringPayments() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get last 6 months of transactions
        LocalDateTime sixMonthsAgo = LocalDateTime.now().minusMonths(6);
        List<Transaction> transactions = transactionRepository
            .findByDateAfterOrderByDateDesc(sixMonthsAgo);

        // Group by account and envelope
        Map<Account, Map<Envelope, List<Transaction>>> groupedTransactions = transactions.stream()
            .collect(Collectors.groupingBy(
                Transaction::getAccount,
                Collectors.groupingBy(Transaction::getEnvelope)
            ));

        // Analyze each account's envelopes
        for (Map.Entry<Account, Map<Envelope, List<Transaction>>> accountEntry : 
             groupedTransactions.entrySet()) {
            
            Account account = accountEntry.getKey();
            
            for (Map.Entry<Envelope, List<Transaction>> envEntry : 
                 accountEntry.getValue().entrySet()) {
                
                Envelope envelope = envEntry.getKey();
                List<Transaction> envTransactions = envEntry.getValue();
                
                // Look for regular patterns in amounts and timing
                Map<BigDecimal, List<Transaction>> byAmount = envTransactions.stream()
                    .collect(Collectors.groupingBy(Transaction::getAmount));

                // Analyze each amount group for timing patterns
                for (Map.Entry<BigDecimal, List<Transaction>> amountGroup : 
                     byAmount.entrySet()) {
                    
                    if (amountGroup.getValue().size() >= 3) {
                        OptionalDouble avgDays = calculateAverageDaysBetween(
                            amountGroup.getValue()
                        );
                        
                        if (avgDays.isPresent()) {
                            double stdDev = calculateStdDev(
                                amountGroup.getValue(), 
                                avgDays.getAsDouble()
                            );
                            
                            if (stdDev < 5.0) {
                                insights.add(new SpendingInsight(
                                    SpendingInsightType.RECURRING_PAYMENT,
                                    String.format(
                                        "Recurring payment detected in %s using %s: $%.2f every %.1f days",
                                        envelope.getName(),
                                        account.getName(),
                                        amountGroup.getKey(),
                                        avgDays.getAsDouble()
                                    ),
                                    0.9
                                ));
                            }
                        }
                    }
                }
            }
        }

        return insights;
    }

    private List<SpendingInsight> detectUnusualSpending() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get historical spending patterns
        LocalDateTime threeMonthsAgo = LocalDateTime.now().minusMonths(3);
        List<Transaction> recentTransactions = transactionRepository
            .findByDateAfterOrderByDateDesc(threeMonthsAgo);

        // Group by account and envelope
        Map<Account, Map<Envelope, List<Transaction>>> groupedTransactions = recentTransactions.stream()
            .collect(Collectors.groupingBy(
                Transaction::getAccount,
                Collectors.groupingBy(Transaction::getEnvelope)
            ));

        // Analyze each account's envelopes
        for (Map.Entry<Account, Map<Envelope, List<Transaction>>> accountEntry : 
             groupedTransactions.entrySet()) {
            
            Account account = accountEntry.getKey();
            
            for (Map.Entry<Envelope, List<Transaction>> envEntry : 
                 accountEntry.getValue().entrySet()) {
                
                Envelope envelope = envEntry.getKey();
                List<Transaction> envTransactions = envEntry.getValue();
                
                // Calculate average and standard deviation of amounts
                double[] amounts = envTransactions.stream()
                    .mapToDouble(tx -> tx.getAmount().doubleValue())
                    .toArray();
                    
                DoubleSummaryStatistics stats = Arrays.stream(amounts)
                    .summaryStatistics();
                double mean = stats.getAverage();
                double stdDev = calculateStdDev(amounts, mean);
                
                // Look for amounts > 2 standard deviations from mean
                envTransactions.stream()
                    .filter(tx -> tx.getDate().isAfter(LocalDateTime.now().minusWeeks(2)))
                    .forEach(tx -> {
                        double zscore = (tx.getAmount().doubleValue() - mean) / stdDev;
                        if (zscore > 2.0) {
                            insights.add(new SpendingInsight(
                                SpendingInsightType.UNUSUAL_SPENDING,
                                String.format(
                                    "Unusual spending detected in %s using %s: $%.2f " +
                                    "(%.1fx higher than average)",
                                    envelope.getName(),
                                    account.getName(),
                                    tx.getAmount(),
                                    tx.getAmount().doubleValue() / mean
                                ),
                                0.8
                            ));
                        }
                    });
            }
        }

        return insights;
    }

    private List<SpendingInsight> predictUpcomingExpenses() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get historical transactions
        LocalDateTime sixMonthsAgo = LocalDateTime.now().minusMonths(6);
        List<Transaction> transactions = transactionRepository
            .findByDateAfterOrderByDateDesc(sixMonthsAgo);

        // Group by account and envelope
        Map<Account, Map<Envelope, List<Transaction>>> groupedTransactions = transactions.stream()
            .collect(Collectors.groupingBy(
                Transaction::getAccount,
                Collectors.groupingBy(Transaction::getEnvelope)
            ));

        // Analyze each account's envelopes
        for (Map.Entry<Account, Map<Envelope, List<Transaction>>> accountEntry : 
             groupedTransactions.entrySet()) {
            
            Account account = accountEntry.getKey();
            
            for (Map.Entry<Envelope, List<Transaction>> envEntry : 
                 accountEntry.getValue().entrySet()) {
                
                Envelope envelope = envEntry.getKey();
                List<Transaction> envTransactions = envEntry.getValue();
                
                if (envTransactions.size() >= 3) {
                    // Calculate monthly totals
                    Map<YearMonth, BigDecimal> monthlyTotals = envTransactions.stream()
                        .collect(Collectors.groupingBy(
                            tx -> YearMonth.from(tx.getDate()),
                            Collectors.reducing(
                                BigDecimal.ZERO,
                                Transaction::getAmount,
                                BigDecimal::add
                            )
                        ));

                    // Calculate trend
                    double[] totals = monthlyTotals.values().stream()
                        .mapToDouble(BigDecimal::doubleValue)
                        .toArray();
                        
                    double trend = calculateTrend(totals);
                    double currentAvg = Arrays.stream(totals).average().orElse(0.0);
                    double predictedNext = currentAvg * (1 + trend);

                    if (Math.abs(trend) > 0.1) {
                        insights.add(new SpendingInsight(
                            SpendingInsightType.PREDICTED_EXPENSE,
                            String.format(
                                "Predicted %s spending next month using %s: $%.2f " +
                                "(%.1f%% %s than average)",
                                envelope.getName(),
                                account.getName(),
                                predictedNext,
                                Math.abs(trend * 100),
                                trend > 0 ? "higher" : "lower"
                            ),
                            0.7
                        ));
                    }
                }
            }
        }

        return insights;
    }

    private List<SpendingInsight> generateBudgetSuggestions() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get last 6 months of transactions
        LocalDateTime sixMonthsAgo = LocalDateTime.now().minusMonths(6);
        List<Transaction> transactions = transactionRepository
            .findByDateAfterOrderByDateDesc(sixMonthsAgo);

        // Group by account and envelope
        Map<Account, Map<Envelope, List<Transaction>>> groupedTransactions = transactions.stream()
            .collect(Collectors.groupingBy(
                Transaction::getAccount,
                Collectors.groupingBy(Transaction::getEnvelope)
            ));

        // Analyze each account's envelopes
        for (Map.Entry<Account, Map<Envelope, List<Transaction>>> accountEntry : 
             groupedTransactions.entrySet()) {
            
            Account account = accountEntry.getKey();
            
            for (Map.Entry<Envelope, List<Transaction>> envEntry : 
                 accountEntry.getValue().entrySet()) {
                
                Envelope envelope = envEntry.getKey();
                List<Transaction> envTransactions = envEntry.getValue();
                
                // Calculate monthly statistics
                Map<YearMonth, BigDecimal> monthlyTotals = envTransactions.stream()
                    .collect(Collectors.groupingBy(
                        tx -> YearMonth.from(tx.getDate()),
                        Collectors.reducing(
                            BigDecimal.ZERO,
                            Transaction::getAmount,
                            BigDecimal::add
                        )
                    ));

                // Calculate average monthly spending
                double avgMonthlySpend = monthlyTotals.values().stream()
                    .mapToDouble(BigDecimal::doubleValue)
                    .average()
                    .orElse(0.0);

                // Compare with current allocation
                double currentAllocation = envelope.getAllocated().doubleValue();
                double spendRatio = avgMonthlySpend / currentAllocation;

                if (spendRatio > 0.95) {
                    insights.add(new SpendingInsight(
                        SpendingInsightType.BUDGET_SUGGESTION,
                        String.format(
                            "Consider increasing %s budget for %s by %.0f%%. " +
                            "Current allocation of $%.2f is frequently depleted.",
                            envelope.getName(),
                            account.getName(),
                            Math.min((spendRatio - 1) * 100 + 10, 30),
                            currentAllocation
                        ),
                        0.8
                    ));
                } else if (spendRatio < 0.7 && monthlyTotals.size() >= 3) {
                    insights.add(new SpendingInsight(
                        SpendingInsightType.BUDGET_SUGGESTION,
                        String.format(
                            "Consider decreasing %s budget for %s by %.0f%%. " +
                            "Average monthly spending ($%.2f) is well below " +
                            "allocation ($%.2f).",
                            envelope.getName(),
                            account.getName(),
                            Math.min((1 - spendRatio) * 100, 20),
                            avgMonthlySpend,
                            currentAllocation
                        ),
                        0.7
                    ));
                }

                // Check for seasonal patterns
                Map<Month, List<BigDecimal>> monthlySpending = monthlyTotals.entrySet()
                    .stream()
                    .collect(Collectors.groupingBy(
                        e -> e.getKey().getMonth(),
                        Collectors.mapping(
                            Map.Entry::getValue,
                            Collectors.toList()
                        )
                    ));

                monthlySpending.forEach((month, amounts) -> {
                    if (amounts.size() >= 2) {
                        double monthAvg = amounts.stream()
                            .mapToDouble(BigDecimal::doubleValue)
                            .average()
                            .getAsDouble();
                            
                        if (monthAvg > avgMonthlySpend * 1.3) {
                            insights.add(new SpendingInsight(
                                SpendingInsightType.SEASONAL_PATTERN,
                                String.format(
                                    "%s typically needs %.0f%% more budget in %s " +
                                    "for %s. Consider temporary allocation increase.",
                                    envelope.getName(),
                                    ((monthAvg / avgMonthlySpend) - 1) * 100,
                                    month.toString(),
                                    account.getName()
                                ),
                                0.75
                            ));
                        }
                    }
                });
            }
        }

        return insights;
    }

    private List<SpendingInsight> generateAccountSpecificInsights() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get all accounts
        List<Account> accounts = accountRepository.findAll();
        
        for (Account account : accounts) {
            // Get account transactions
            List<Transaction> accountTransactions = transactionRepository
                .findByDateAfterOrderByDateDesc(LocalDateTime.now().minusMonths(3))
                .stream()
                .filter(tx -> tx.getAccount().getId().equals(account.getId()))
                .collect(Collectors.toList());
                
            if (accountTransactions.isEmpty()) continue;
            
            // Add account type specific insights
            if (account.getType() == Account.AccountType.CREDIT_CARD) {
                // Check credit utilization
                BigDecimal balance = account.getBalance();
                // Assuming a standard credit limit, in practice this would come from the account
                BigDecimal estimatedLimit = BigDecimal.valueOf(5000.00);
                double utilizationRate = balance.doubleValue() / estimatedLimit.doubleValue();
                
                if (utilizationRate > 0.7) {
                    insights.add(new SpendingInsight(
                        SpendingInsightType.UNUSUAL_SPENDING,
                        String.format(
                            "High credit utilization (%.0f%%) detected on %s. Consider reducing usage or requesting a limit increase.",
                            utilizationRate * 100,
                            account.getName()
                        ),
                        0.9
                    ));
                }
            } else if (account.getType() == Account.AccountType.CHECKING) {
                // Check for low balance trends
                BigDecimal balance = account.getBalance();
                BigDecimal avgMonthlySpend = accountTransactions.stream()
                    .map(Transaction::getAmount)
                    .reduce(BigDecimal.ZERO, BigDecimal::add)
                    .divide(BigDecimal.valueOf(3), 2, java.math.RoundingMode.HALF_UP);
                
                if (balance.compareTo(avgMonthlySpend) < 0) {
                    insights.add(new SpendingInsight(
                        SpendingInsightType.BUDGET_SUGGESTION,
                        String.format(
                            "Current balance ($%.2f) in %s is below average monthly spending ($%.2f). Consider maintaining higher balance.",
                            balance,
                            account.getName(),
                            avgMonthlySpend
                        ),
                        0.85
                    ));
                }
            }

            // Analyze transaction patterns
            Map<String, List<Transaction>> merchantPatterns = accountTransactions.stream()
                .collect(Collectors.groupingBy(Transaction::getDescription));
            
            // Look for frequent merchants and spending patterns
            merchantPatterns.forEach((merchant, transactions) -> {
                if (transactions.size() >= 3) {
                    OptionalDouble avgDays = calculateAverageDaysBetween(transactions);
                    if (avgDays.isPresent() && avgDays.getAsDouble() < 35) {
                        double avgAmount = transactions.stream()
                            .mapToDouble(tx -> tx.getAmount().doubleValue())
                            .average()
                            .orElse(0.0);
                            
                        insights.add(new SpendingInsight(
                            SpendingInsightType.RECURRING_PAYMENT,
                            String.format(
                                "Regular payments of $%.2f to %s detected on %s (every %.1f days)",
                                avgAmount,
                                merchant,
                                account.getName(),
                                avgDays.getAsDouble()
                            ),
                            0.85
                        ));
                    }
                }
            });
        }
        
        return insights;
    }

    private List<SpendingInsight> detectCrossAccountPatterns() {
        List<SpendingInsight> insights = new ArrayList<>();
        
        // Get recent transactions across all accounts
        LocalDateTime threeMonthsAgo = LocalDateTime.now().minusMonths(3);
        List<Transaction> recentTransactions = transactionRepository
            .findByDateAfterOrderByDateDesc(threeMonthsAgo);
            
        // Group by merchant across accounts
        Map<String, Map<Account, List<Transaction>>> merchantAccountPatterns = 
            recentTransactions.stream()
                .collect(Collectors.groupingBy(
                    Transaction::getDescription,
                    Collectors.groupingBy(Transaction::getAccount)
                ));
                
        // Look for merchants used across multiple accounts
        merchantAccountPatterns.forEach((merchant, accountTransactions) -> {
            if (accountTransactions.size() > 1) {
                // Calculate total spent per account
                Map<Account, BigDecimal> accountTotals = new HashMap<>();
                accountTransactions.forEach((account, transactions) -> {
                    BigDecimal total = transactions.stream()
                        .map(Transaction::getAmount)
                        .reduce(BigDecimal.ZERO, BigDecimal::add);
                    accountTotals.put(account, total);
                });
                
                // If significant spending across accounts, suggest consolidation
                if (accountTotals.size() > 1) {
                    String accountsList = accountTotals.entrySet().stream()
                        .map(e -> String.format("%s ($%.2f)", 
                            e.getKey().getName(), 
                            e.getValue()))
                        .collect(Collectors.joining(", "));
                        
                    insights.add(new SpendingInsight(
                        SpendingInsightType.REALLOCATION_SUGGESTION,
                        String.format(
                            "Multiple accounts used for %s: %s. Consider consolidating to one account for better tracking.",
                            merchant,
                            accountsList
                        ),
                        0.7
                    ));
                }
            }
        });
        
        return insights;
    }

    // Helper methods
    private OptionalDouble calculateAverageDaysBetween(List<Transaction> transactions) {
        if (transactions.size() < 2) {
            return OptionalDouble.empty();
        }

        List<Transaction> sorted = transactions.stream()
            .sorted(Comparator.comparing(Transaction::getDate))
            .collect(Collectors.toList());

        double totalDays = 0;
        int count = 0;

        for (int i = 1; i < sorted.size(); i++) {
            Duration duration = Duration.between(
                sorted.get(i-1).getDate(),
                sorted.get(i).getDate()
            );
            totalDays += duration.toDays();
            count++;
        }

        return count > 0 ? 
            OptionalDouble.of(totalDays / count) : 
            OptionalDouble.empty();
    }

    private double calculateStdDev(double[] values, double mean) {
        return Math.sqrt(
            Arrays.stream(values)
                .map(v -> Math.pow(v - mean, 2))
                .average()
                .orElse(0.0)
        );
    }

    private double calculateStdDev(List<Transaction> transactions, double avgDays) {
        if (transactions.size() < 2) {
            return Double.MAX_VALUE;
        }

        List<Transaction> sorted = transactions.stream()
            .sorted(Comparator.comparing(Transaction::getDate))
            .collect(Collectors.toList());

        double sumSquaredDiff = 0;
        int count = 0;

        for (int i = 1; i < sorted.size(); i++) {
            double days = Duration.between(
                sorted.get(i-1).getDate(),
                sorted.get(i).getDate()
            ).toDays();
            sumSquaredDiff += Math.pow(days - avgDays, 2);
            count++;
        }

        return count > 0 ? 
            Math.sqrt(sumSquaredDiff / count) : 
            Double.MAX_VALUE;
    }

    private double calculateTrend(double[] values) {
        if (values.length < 2) {
            return 0.0;
        }

        // Simple linear regression to calculate trend
        int n = values.length;
        double sumX = 0;
        double sumY = 0;
        double sumXY = 0;
        double sumXX = 0;

        for (int i = 0; i < n; i++) {
            sumX += i;
            sumY += values[i];
            sumXY += i * values[i];
            sumXX += i * i;
        }

        double slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        double meanY = sumY / n;

        // Return normalized trend (as percentage change)
        return slope / meanY;
    }
}


=== ./src/main/java/org/emblow/envelopify/service/ml/AdvancedMLService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.ml;

/**
 *
 * @author Nicholas J Emblow
 */

import org.springframework.stereotype.Service;
import org.springframework.scheduling.annotation.Scheduled;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.repositry.TransactionRepository;
import org.emblow.envelopify.repositry.EnvelopeRepository;
import org.emblow.envelopify.repositry.AccountRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.*;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.math.BigDecimal;
import java.util.stream.Collectors;

@Service
public class AdvancedMLService {
    private static final Logger log = LoggerFactory.getLogger(AdvancedMLService.class);
    
    private final TransactionRepository transactionRepository;
    private final EnvelopeRepository envelopeRepository;
    private final AccountRepository accountRepository;
    private final TransactionClassifier classifier;
    
    public AdvancedMLService(
        TransactionRepository transactionRepository,
        EnvelopeRepository envelopeRepository,
        AccountRepository accountRepository,
        TransactionClassifier classifier
    ) {
        this.transactionRepository = transactionRepository;
        this.envelopeRepository = envelopeRepository;
        this.accountRepository = accountRepository;
        this.classifier = classifier;
    }
    
    @Scheduled(cron = "0 0 2 * * *") // Run at 2 AM daily
    public void retrainModels() {
        log.info("Starting daily model retraining");
        classifier.retrain();
    }
    
    public List<AccountAnalysis> analyzeAccounts() {
        List<AccountAnalysis> analyses = new ArrayList<>();
        
        try {
            // Get all accounts
            List<Account> accounts = accountRepository.findAll();
            
            for (Account account : accounts) {
                analyses.add(analyzeAccount(account));
            }
            
            // Add cross-account analysis if we have multiple accounts
            if (accounts.size() > 1) {
                addCrossAccountAnalysis(analyses);
            }
            
        } catch (Exception e) {
            log.error("Error analyzing accounts", e);
        }
        
        return analyses;
    }
    
    private AccountAnalysis analyzeAccount(Account account) {
        // Get recent transactions
        LocalDateTime sixMonthsAgo = LocalDateTime.now().minusMonths(6);
        List<Transaction> accountTransactions = transactionRepository
            .findByDateAfterOrderByDateDesc(sixMonthsAgo)
            .stream()
            .filter(tx -> tx.getAccount().getId().equals(account.getId()))
            .collect(Collectors.toList());
            
        // Calculate key metrics
        Map<YearMonth, BigDecimal> monthlyVolumes = accountTransactions.stream()
            .collect(Collectors.groupingBy(
                tx -> YearMonth.from(tx.getDate()),
                Collectors.reducing(
                    BigDecimal.ZERO,
                    Transaction::getAmount,
                    BigDecimal::add
                )
            ));
            
        // Monthly statistics
        DoubleSummaryStatistics volumeStats = monthlyVolumes.values().stream()
            .mapToDouble(BigDecimal::doubleValue)
            .summaryStatistics();
            
        // Merchant analysis
        Map<String, MerchantMetrics> merchantMetrics = analyzeMerchants(accountTransactions);
        
        // Envelope usage patterns
        Map<Envelope, EnvelopeMetrics> envelopeMetrics = analyzeEnvelopes(accountTransactions);
        
        // Anomaly detection
        List<AnomalyDetection> anomalies = detectAnomaliesForAccount(accountTransactions);
        
        // Weekly patterns
        Map<DayOfWeek, Double> dayOfWeekPatterns = analyzeDayOfWeekPatterns(accountTransactions);
        
        // Balance trends
        BalanceTrends balanceTrends = analyzeBalanceTrends(account, accountTransactions);
        
        return new AccountAnalysis(
            account,
            volumeStats.getAverage(),
            calculateTrend(new ArrayList<>(monthlyVolumes.values())),
            new ArrayList<>(merchantMetrics.entrySet().stream()
                .sorted((e1, e2) -> Double.compare(e2.getValue().totalSpent, e1.getValue().totalSpent))
                .limit(5)
                .map(Map.Entry::getKey)
                .toList()),
            anomalies,
            merchantMetrics,
            envelopeMetrics,
            dayOfWeekPatterns,
            balanceTrends
        );
    }
    
    private Map<String, MerchantMetrics> analyzeMerchants(List<Transaction> transactions) {
        Map<String, MerchantMetrics> metrics = new HashMap<>();
        
        // Group transactions by merchant
        Map<String, List<Transaction>> byMerchant = transactions.stream()
            .collect(Collectors.groupingBy(Transaction::getDescription));
            
        byMerchant.forEach((merchant, merchantTxs) -> {
            double totalSpent = merchantTxs.stream()
                .mapToDouble(tx -> tx.getAmount().doubleValue())
                .sum();
                
            double avgAmount = merchantTxs.stream()
                .mapToDouble(tx -> tx.getAmount().doubleValue())
                .average()
                .orElse(0.0);
                
            OptionalDouble avgDaysBetween = calculateAverageDaysBetween(merchantTxs);
            
            double frequency = (double) merchantTxs.size() / 
                ChronoUnit.MONTHS.between(
                    merchantTxs.get(merchantTxs.size() - 1).getDate(),
                    merchantTxs.get(0).getDate()
                );
                
            Map<Envelope, Integer> envelopeUsage = merchantTxs.stream()
                .collect(Collectors.groupingBy(
                    Transaction::getEnvelope,
                    Collectors.collectingAndThen(Collectors.counting(), Long::intValue)
                ));
                
            metrics.put(merchant, new MerchantMetrics(
                totalSpent,
                avgAmount,
                frequency,
                avgDaysBetween.orElse(0.0),
                envelopeUsage
            ));
        });
        
        return metrics;
    }
    
    private Map<Envelope, EnvelopeMetrics> analyzeEnvelopes(List<Transaction> transactions) {
        Map<Envelope, EnvelopeMetrics> metrics = new HashMap<>();
        
        // Group transactions by envelope
        Map<Envelope, List<Transaction>> byEnvelope = transactions.stream()
            .collect(Collectors.groupingBy(Transaction::getEnvelope));
            
        byEnvelope.forEach((envelope, envTxs) -> {
            double totalSpent = envTxs.stream()
                .mapToDouble(tx -> tx.getAmount().doubleValue())
                .sum();
                
            Map<YearMonth, Double> monthlySpending = envTxs.stream()
                .collect(Collectors.groupingBy(
                    tx -> YearMonth.from(tx.getDate()),
                    Collectors.summingDouble(tx -> tx.getAmount().doubleValue())
                ));
                
            double trend = calculateTrend(monthlySpending.values().stream()
                .mapToDouble(Double::doubleValue)
                .toArray());
                
            metrics.put(envelope, new EnvelopeMetrics(
                totalSpent,
                monthlySpending,
                trend,
                envelope.getBudgetUtilization()
            ));
        });
        
        return metrics;
    }
    
    private Map<DayOfWeek, Double> analyzeDayOfWeekPatterns(List<Transaction> transactions) {
        return transactions.stream()
            .collect(Collectors.groupingBy(
                tx -> tx.getDate().getDayOfWeek(),
                Collectors.averagingDouble(tx -> tx.getAmount().doubleValue())
            ));
    }
    
    private BalanceTrends analyzeBalanceTrends(Account account, List<Transaction> transactions) {
        if (transactions.isEmpty()) {
            return new BalanceTrends(0.0, 0.0, 0.0, Collections.emptyMap());
        }
        
        // Calculate daily balances
        TreeMap<LocalDate, Double> dailyBalances = new TreeMap<>();
        double runningBalance = account.getBalance().doubleValue();
        
        // Work backwards from current balance
        for (Transaction tx : transactions) {
            LocalDate date = tx.getDate().toLocalDate();
            runningBalance -= tx.getAmount().doubleValue();
            dailyBalances.merge(date, runningBalance, Double::sum);
        }
        
        // Calculate metrics
        DoubleSummaryStatistics stats = dailyBalances.values().stream()
            .mapToDouble(Double::doubleValue)
            .summaryStatistics();
            
        double volatility = Math.sqrt(dailyBalances.values().stream()
            .mapToDouble(balance -> Math.pow(balance - stats.getAverage(), 2))
            .average()
            .orElse(0.0));
            
        return new BalanceTrends(
            stats.getAverage(),
            volatility,
            calculateTrend(dailyBalances.values().stream()
                .mapToDouble(Double::doubleValue)
                .toArray()),
            dailyBalances
        );
    }
    
    private void addCrossAccountAnalysis(List<AccountAnalysis> analyses) {
        // Find common merchants across accounts
        Map<String, Set<Account>> merchantAccounts = new HashMap<>();
        
        for (AccountAnalysis analysis : analyses) {
            for (String merchant : analysis.getMerchantMetrics().keySet()) {
                merchantAccounts.computeIfAbsent(merchant, k -> new HashSet<>())
                    .add(analysis.getAccount());
            }
        }
        
        // Add cross-account insights to each analysis
        for (AccountAnalysis analysis : analyses) {
            List<String> sharedMerchants = merchantAccounts.entrySet().stream()
                .filter(e -> e.getValue().size() > 1 && 
                            e.getValue().contains(analysis.getAccount()))
                .map(Map.Entry::getKey)
                .toList();
                
            analysis.setCrossAccountMetrics(new CrossAccountMetrics(
                sharedMerchants,
                analyses.stream()
                    .filter(a -> !a.equals(analysis))
                    .collect(Collectors.toMap(
                        a -> a.getAccount(),
                        a -> calculateAccountSimilarity(analysis, a)
                    ))
            ));
        }
    }
    
    private double calculateAccountSimilarity(AccountAnalysis a1, AccountAnalysis a2) {
        Set<String> merchants1 = a1.getMerchantMetrics().keySet();
        Set<String> merchants2 = a2.getMerchantMetrics().keySet();
        
        // Jaccard similarity of merchant sets
        Set<String> intersection = new HashSet<>(merchants1);
        intersection.retainAll(merchants2);
        
        Set<String> union = new HashSet<>(merchants1);
        union.addAll(merchants2);
        
        return union.isEmpty() ? 0.0 : 
            (double) intersection.size() / union.size();
    }
    
    public List<AnomalyDetection> detectAnomaliesForAccount(List<Transaction> transactions) {
        List<AnomalyDetection> anomalies = new ArrayList<>();
        
        if (transactions.isEmpty()) return anomalies;
        
        // Calculate statistical measures
        DoubleSummaryStatistics stats = transactions.stream()
            .mapToDouble(tx -> tx.getAmount().doubleValue())
            .summaryStatistics();
            
        double mean = stats.getAverage();
        double stdDev = calculateStdDev(transactions, mean);
        
        // Check recent transactions for anomalies
        transactions.stream()
            .filter(tx -> tx.getDate().isAfter(LocalDateTime.now().minusWeeks(2)))
            .forEach(tx -> {
                double zscore = (tx.getAmount().doubleValue() - mean) / stdDev;
                if (Math.abs(zscore) > 2.5) {
                    anomalies.add(new AnomalyDetection(
                        tx,
                        AnomalyType.AMOUNT,
                        Math.abs(zscore),
                        String.format(
                            "Unusual transaction amount for %s: $%.2f",
                            tx.getAccount().getName(),
                            tx.getAmount()
                        )
                    ));
                }
            });
            
        // Check for unusual frequency
        Map<LocalDate, Long> dailyCounts = transactions.stream()
            .collect(Collectors.groupingBy(
                tx -> tx.getDate().toLocalDate(),
                Collectors.counting()
            ));
            
        DoubleSummaryStatistics freqStats = dailyCounts.values().stream()
            .mapToDouble(Long::doubleValue)
            .summaryStatistics();
            
        double freqMean = freqStats.getAverage();
        double freqStdDev = calculateStdDev(
            dailyCounts.values().stream()
                .mapToDouble(Long::doubleValue)
                .toArray(),
            freqMean
        );
        
        dailyCounts.forEach((date, count) -> {
            if (date.isAfter(LocalDate.now().minusWeeks(2))) {
                double zscore = (count - freqMean) / freqStdDev;
                if (zscore > 2.5) {
                    anomalies.add(new AnomalyDetection(
                        null,
                        AnomalyType.FREQUENCY,
                        zscore,
                        String.format(
                            "Unusual number of transactions (%d) on %s",
                            count,
                            date
                        )
                    ));
                }
            }
        });
        
        return anomalies;
    }
    
    // Helper classes for analysis results
    public record MerchantMetrics(
        double totalSpent,
        double averageAmount,
        double monthlyFrequency,
        double averageDaysBetween,
        Map<Envelope, Integer> envelopeUsage
    ) {}
    
    public record EnvelopeMetrics(
        double totalSpent,
        Map<YearMonth, Double> monthlySpending,
        double spendingTrend,
        double budgetUtilization
    ) {}
    
    public record BalanceTrends(
        double averageBalance,
        double balanceVolatility,
        double balanceTrend,
        Map<LocalDate, Double> dailyBalances
    ) {}
    
    public record CrossAccountMetrics(
        List<String> sharedMerchants,
        Map<Account, Double> accountSimilarities
    ) {}
    
    // Main analysis result class
    public static class AccountAnalysis {
        private final Account account;
        private final double averageMonthlyVolume;
        private final double volumeTrend;
        private final List<String> topMerchants;
        private final List<AnomalyDetection> anomalies;
        private final Map<String, MerchantMetrics> merchantMetrics;
        private final Map<Envelope, EnvelopeMetrics> envelopeMetrics;
        private final Map<DayOfWeek, Double> dayOfWeekPatterns;
        private final BalanceTrends balanceTrends;
        private CrossAccountMetrics crossAccountMetrics;

        public AccountAnalysis(
            Account account,
            double averageMonthlyVolume,
            double volumeTrend,
            List<String> topMerchants,
            List<AnomalyDetection> anomalies,
            Map<String, MerchantMetrics> merchantMetrics,
            Map<Envelope, EnvelopeMetrics> envelopeMetrics,
            Map<DayOfWeek, Double> dayOfWeekPatterns,
            BalanceTrends balanceTrends
        ) {
            this.account = account;
            this.averageMonthlyVolume = averageMonthlyVolume;
            this.volumeTrend = volumeTrend;
            this.topMerchants = topMerchants;
            this.anomalies = anomalies;
            this.merchantMetrics = merchantMetrics;
            this.envelopeMetrics = envelopeMetrics;
            this.dayOfWeekPatterns = dayOfWeekPatterns;
            this.balanceTrends = balanceTrends;
            this.crossAccountMetrics = null;
        }

        public void setCrossAccountMetrics(CrossAccountMetrics metrics) {
            this.crossAccountMetrics = metrics;
        }

        // Getters
        public Account getAccount() { return account; }
        public double getAverageMonthlyVolume() { return averageMonthlyVolume; }
        public double getVolumeTrend() { return volumeTrend; }
        public List<String> getTopMerchants() { return topMerchants; }
        public List<AnomalyDetection> getAnomalies() { return anomalies; }
        public Map<String, MerchantMetrics> getMerchantMetrics() { return merchantMetrics; }
        public Map<Envelope, EnvelopeMetrics> getEnvelopeMetrics() { return envelopeMetrics; }
        public Map<DayOfWeek, Double> getDayOfWeekPatterns() { return dayOfWeekPatterns; }
        public BalanceTrends getBalanceTrends() { return balanceTrends; }
        public CrossAccountMetrics getCrossAccountMetrics() { return crossAccountMetrics; }
    }

    public enum AnomalyType {
        AMOUNT,
        FREQUENCY,
        PATTERN
    }

    public record AnomalyDetection(
        Transaction transaction,
        AnomalyType type,
        double severity,
        String description
    ) {}

    // Helper methods
    private OptionalDouble calculateAverageDaysBetween(List<Transaction> transactions) {
        if (transactions.size() < 2) {
            return OptionalDouble.empty();
        }

        List<Transaction> sorted = transactions.stream()
            .sorted(Comparator.comparing(Transaction::getDate))
            .collect(Collectors.toList());

        double totalDays = 0;
        int count = 0;

        for (int i = 1; i < sorted.size(); i++) {
            Duration duration = Duration.between(
                sorted.get(i-1).getDate(),
                sorted.get(i).getDate()
            );
            totalDays += duration.toDays();
            count++;
        }

        return count > 0 ? 
            OptionalDouble.of(totalDays / count) : 
            OptionalDouble.empty();
    }

    private double calculateStdDev(List<Transaction> transactions, double mean) {
        return Math.sqrt(
            transactions.stream()
                .mapToDouble(tx -> Math.pow(tx.getAmount().doubleValue() - mean, 2))
                .average()
                .orElse(0.0)
        );
    }

    private double calculateStdDev(double[] values, double mean) {
        return Math.sqrt(
            Arrays.stream(values)
                .map(v -> Math.pow(v - mean, 2))
                .average()
                .orElse(0.0)
        );
    }

    private double calculateTrend(double[] values) {
        if (values.length < 2) {
            return 0.0;
        }

        // Simple linear regression
        int n = values.length;
        double sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;

        for (int i = 0; i < n; i++) {
            sumX += i;
            sumY += values[i];
            sumXY += i * values[i];
            sumXX += i * i;
        }

        double slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        double meanY = sumY / n;

        return slope / meanY; // Return normalized trend
    }

    private double calculateTrend(List<BigDecimal> values) {
        return calculateTrend(values.stream()
            .mapToDouble(BigDecimal::doubleValue)
            .toArray());
    }
}


=== ./src/main/java/org/emblow/envelopify/service/CSVImportService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.repositry.TransactionRepository;
import org.emblow.envelopify.repositry.EnvelopeRepository;
import org.emblow.envelopify.repositry.AccountRepository;
import org.emblow.envelopify.service.PatternService;

import java.io.BufferedReader;
import java.io.StringReader;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import org.emblow.envelopify.repositry.AccountRepository;

@Service
public class CSVImportService {
    private final TransactionRepository transactionRepository;
    private final EnvelopeRepository envelopeRepository;
    private final AccountRepository accountRepository;
    private final PatternService patternService;
    private final TransactionService transactionService;

    public CSVImportService(
        TransactionRepository transactionRepository,
        EnvelopeRepository envelopeRepository,
        AccountRepository accountRepository,
        PatternService patternService,
        TransactionService transactionService
    ) {
        this.transactionRepository = transactionRepository;
        this.envelopeRepository = envelopeRepository;
        this.accountRepository = accountRepository;
        this.patternService = patternService;
        this.transactionService = transactionService;
    }

    @Transactional
    public ImportResult importTransactions(
        String csvContent,
        CSVMapping mapping,
        Long defaultEnvelopeId,
        Long accountId
    ) {
        ImportResult result = new ImportResult();
        
        Envelope defaultEnvelope = envelopeRepository.findById(defaultEnvelopeId)
            .orElseThrow(() -> new RuntimeException("Default envelope not found"));
            
        Account account = accountRepository.findById(accountId)
            .orElseThrow(() -> new RuntimeException("Account not found"));

        try (BufferedReader reader = new BufferedReader(new StringReader(csvContent))) {
            // Skip header row if specified
            if (mapping.hasHeader()) {
                reader.readLine();
            }

            String line;
            while ((line = reader.readLine()) != null) {
                try {
                    String[] fields = line.split(mapping.delimiter());
                    
                    // Parse fields using mapping
                    LocalDateTime date = parseDate(
                        fields[mapping.dateColumnIndex()],
                        mapping.dateFormat()
                    );
                    
                    String description = fields[mapping.descriptionColumnIndex()].trim();
                    
                    // Determine the transaction type based on the multiplier:
                    // if negative => INCOME, otherwise EXPENSE.
                    TransactionType txType = mapping.amountMultiplier() < 0 ? 
                        TransactionType.INCOME : TransactionType.EXPENSE;
                    // Parse the amount using the absolute multiplier.
                    BigDecimal amount = parseAmount(
                        fields[mapping.amountColumnIndex()],
                        Math.abs(mapping.amountMultiplier())
                    );

                    // Find best envelope match using pattern service.
                    Transaction temp = new Transaction();
                    temp.setDate(date);
                    temp.setDescription(description);
                    temp.setAmount(amount);
                    temp.setAccount(account);
                    
                    Map<Envelope, Double> suggestions = patternService.suggestEnvelopes(temp);
                    
                    // Use highest confidence suggestion or default envelope.
                    Envelope targetEnvelope = suggestions.entrySet().stream()
                        .max(Map.Entry.comparingByValue())
                        .filter(e -> e.getValue() > 0.7) // Minimum confidence threshold
                        .map(Map.Entry::getKey)
                        .orElse(defaultEnvelope);

                    // Instead of manually constructing and saving the transaction,
                    // call recordTransaction to let it update balances appropriately.
                    transactionService.recordTransaction(
                        targetEnvelope.getId(),
                        account.getId(),
                        date,
                        description,
                        amount,
                        txType
                    );
                    
                    result.incrementSuccessful();
                    
                } catch (Exception e) {
                    result.addError("Error processing line: " + line + " - " + e.getMessage());
                    result.incrementFailed();
                }
            }
        } catch (Exception e) {
            throw new RuntimeException("Error processing CSV file: " + e.getMessage(), e);
        }

        return result;
    }

    private LocalDateTime parseDate(String value, String format) {
        return LocalDateTime.parse(value, DateTimeFormatter.ofPattern(format));
    }

    private BigDecimal parseAmount(String value, double multiplier) {
        // Remove currency symbols and spaces.
        String cleaned = value.replaceAll("[^\\d.-]", "");
        return new BigDecimal(cleaned).multiply(BigDecimal.valueOf(multiplier));
    }

    // Record to define CSV column mapping.
    public record CSVMapping(
        boolean hasHeader,
        String delimiter,
        int dateColumnIndex,
        String dateFormat,
        int descriptionColumnIndex,
        int amountColumnIndex,
        double amountMultiplier
    ) {
        // Predefined mappings for common bank formats.
        public static CSVMapping CHASE = new CSVMapping(
            true, ",", 0, "MM/dd/yyyy", 2, 3, 1.0
        );
        
        public static CSVMapping BANK_OF_AMERICA = new CSVMapping(
            true, ",", 0, "MM/dd/yyyy", 1, 2, 1.0
        );
        
        // Add more presets as needed.
    }

    // Class to hold import results.
    public static class ImportResult {
        private int successful = 0;
        private int failed = 0;
        private List<String> errors = new ArrayList<>();

        public void incrementSuccessful() { successful++; }
        public void incrementFailed() { failed++; }
        public void addError(String error) { errors.add(error); }

        public int getSuccessful() { return successful; }
        public int getFailed() { return failed; }
        public List<String> getErrors() { return errors; }
    }
}



=== ./src/main/java/org/emblow/envelopify/service/llm/ChatGPTService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.llm;

/**
 * NB To use, you will need add in your api keys etc:
 * openai.api.key=sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 * openai.chat.endpoint=https://api.openai.com/v1/chat/completions
 * 
 * @author Nicholas J Emblow
 */
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.PatternService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.ml.SpendingInsight;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class ChatGPTService implements LLMService {

    // OpenAI Chat API endpoint.
    private final String CHATGPT_URL = "https://api.openai.com/v1/chat/completions";
    
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    
    // Financial context dependencies.
    private final TransactionService transactionService;
    private final EnvelopeService envelopeService;
    private final SpendingInsightService insightService;
    private final PatternService patternService;
    
    // API key injected via configuration.
    @Value("${openai.api.key}")
    private String openaiApiKey;

    public ChatGPTService(TransactionService transactionService,
                          EnvelopeService envelopeService,
                          SpendingInsightService insightService,
                          PatternService patternService) {
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
        this.transactionService = transactionService;
        this.envelopeService = envelopeService;
        this.insightService = insightService;
        this.patternService = patternService;
    }
    
    /**
     * Processes the user query by building a financial context, assembling a prompt, and then sending
     * the request to ChatGPT for a response.
     *
     * @param userQuery The user's question.
     * @return The response text from ChatGPT.
     */
    public String processUserQuery(String userQuery) {
        try {
            String context = buildFinancialContext();
            String fullPrompt = buildPrompt(userQuery, context);
            
            // Build the JSON request body following OpenAI's Chat API format.
            ObjectNode requestBody = objectMapper.createObjectNode();
            requestBody.put("model", "gpt-3.5-turbo");
            requestBody.put("temperature", 0.0);
            requestBody.put("stream", false);
            
            // Construct the messages array.
            ArrayNode messages = objectMapper.createArrayNode();
            
            // System message to set the assistant's role.
            ObjectNode systemMessage = objectMapper.createObjectNode();
            systemMessage.put("role", "system");
            systemMessage.put("content", "You are a financial analysis assistant with direct access to the user's financial data.");
            messages.add(systemMessage);
            
            // User message with the combined prompt.
            ObjectNode userMessage = objectMapper.createObjectNode();
            userMessage.put("role", "user");
            userMessage.put("content", fullPrompt);
            messages.add(userMessage);
            
            requestBody.set("messages", messages);
            
            // Set up HTTP headers with content type and authorization.
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.setBearerAuth(openaiApiKey);
            
            HttpEntity<String> entity = new HttpEntity<>(requestBody.toString(), headers);
            ResponseEntity<String> response = restTemplate.postForEntity(CHATGPT_URL, entity, String.class);
            
            // Parse the response to extract the message content.
            JsonNode root = objectMapper.readTree(response.getBody());
            if (root.has("choices") && root.get("choices").isArray() && root.get("choices").size() > 0) {
                return root.get("choices").get(0).get("message").get("content").asText();
            }
            return "No response received from ChatGPT.";
        } catch (Exception e) {
            throw new RuntimeException("Error during ChatGPT inference: " + e.getMessage(), e);
        }
    }
    
    /**
     * Builds the financial context string by collecting current envelope info, recent transactions,
     * insights, overall status, and spending patterns.
     *
     * @return A string representing the current financial context.
     */
    private String buildFinancialContext() {
        StringBuilder context = new StringBuilder();
        
        // Current envelope information.
        List<Envelope> envelopes = envelopeService.getAllEnvelopes();
        context.append("Current Envelopes:\n");
        for (Envelope env : envelopes) {
            context.append(String.format("- %s: Budget $%.2f, Available $%.2f\n",
                    env.getName(),
                    env.getMonthlyBudget(),
                    env.getAvailable()));
        }
        
        // Recent transactions.
        LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
        List<Transaction> recentTransactions = transactionService.getRecentTransactions(oneMonthAgo, LocalDateTime.now());
        context.append("\nRecent Transactions:\n");
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");
        for (Transaction tx : recentTransactions.stream().limit(10).collect(Collectors.toList())) {
            context.append(String.format("- %s: $%.2f in %s (%s)\n",
                    tx.getDate().format(formatter),
                    tx.getAmount(),
                    tx.getEnvelope().getName(),
                    tx.getDescription()));
        }
        
        // Financial insights.
        List<SpendingInsight> regularInsights = insightService.generateInsights();
        context.append("\nFinancial Insights:\n");
        for (SpendingInsight insight : regularInsights) {
            context.append("- ").append(insight.getMessage()).append("\n");
        }
        
        // Overall financial status.
        BigDecimal totalBudget = envelopes.stream()
                .map(Envelope::getMonthlyBudget)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        BigDecimal totalAvailable = envelopes.stream()
                .map(Envelope::getAvailable)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        context.append(String.format("\nOverall Status:\n- Total Budget: $%.2f\n- Total Available: $%.2f\n",
                totalBudget, totalAvailable));
        
        // Spending patterns.
        if (!recentTransactions.isEmpty()) {
            context.append("\nSpending Patterns:\n");
            for (Transaction tx : recentTransactions.stream().limit(5).collect(Collectors.toList())) {
                Map<Envelope, Double> suggestions = patternService.suggestEnvelopes(tx);
                if (!suggestions.isEmpty()) {
                    context.append(String.format("- Transaction '%s' matches patterns from: ", tx.getDescription()));
                    context.append(suggestions.entrySet().stream()
                            .sorted((e1, e2) -> e2.getValue().compareTo(e1.getValue()))
                            .limit(2)
                            .map(e -> String.format("%s (%.0f%% confidence)",
                                    e.getKey().getName(),
                                    e.getValue() * 100))
                            .collect(Collectors.joining(", ")))
                            .append("\n");
                }
            }
        }
        return context.toString();
    }
    
    /**
     * Builds the prompt by combining the financial context and the user's query.
     *
     * @param userQuery The user's question.
     * @param context   The financial context string.
     * @return The full prompt to be sent to ChatGPT.
     */
    private String buildPrompt(String userQuery, String context) {
        return String.format("""
                Role: You are a financial analysis assistant with direct access to the user's financial data.
                Task: Analyze the provided financial data and answer the user's question with specific, data-driven insights.
                
                Available Data:
                %s
                
                Functions Available:
                - Calculate spending trends across envelopes
                - Compare current spending to budget allocations
                - Identify unusual transactions or patterns
                - Project future expenses based on historical data
                
                User Question: %s
                
                Instructions:
                1. Focus on specific numbers and data points from the provided context.
                2. Show brief calculations when relevant.
                3. Reference specific transactions or patterns.
                4. Provide actionable recommendations based on the data.
                5. Keep responses clear and direct.
                
                Response Format:
                - Start with a direct answer to the question.
                - Include relevant data points and calculations.
                - End with a specific, actionable recommendation if applicable.
                """, context, userQuery);
    }
}





=== ./src/main/java/org/emblow/envelopify/service/llm/LLMService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.llm;

import org.springframework.stereotype.Service;

/**
 *
 * @author Nicholas J Emblow
 */
@Service
public interface LLMService {

    /**
     * Processes the user query by building financial context, assembling a prompt, and then generating
     * a response using the JLama inference engine.
     * @param userQuery
     * @return
     */
    String processUserQuery(String userQuery);
    
}



=== ./src/main/java/org/emblow/envelopify/service/llm/OllamaService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.llm;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.*;
import org.emblow.envelopify.service.*;
import org.emblow.envelopify.domain.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import org.emblow.envelopify.service.ml.SpendingInsight;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.emblow.envelopify.service.ml.SpendingInsightType;
import org.emblow.envelopify.service.ml.AdvancedMLService;
import org.springframework.web.client.RestClientException;

@Service
public class OllamaService implements LLMService{
    private final String OLLAMA_URL = "http://localhost:11434/api/generate";
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    
    private final TransactionService transactionService;
    private final EnvelopeService envelopeService;
    private final SpendingInsightService insightService;
    private final PatternService patternService;
    private final AdvancedMLService advancedMLService;  // New dependency

    public OllamaService(
        TransactionService transactionService,
        EnvelopeService envelopeService,
        SpendingInsightService insightService,
        PatternService patternService,
        AdvancedMLService advancedMLService   // Inject the AdvancedMLService
    ) {
        this.restTemplate = new RestTemplate();
        this.objectMapper = new ObjectMapper();
        this.transactionService = transactionService;
        this.envelopeService = envelopeService;
        this.insightService = insightService;
        this.patternService = patternService;
        this.advancedMLService = advancedMLService;
    }

    @Override
    public String processUserQuery(String userQuery) {
        try {
            String context = buildFinancialContext();
            String fullPrompt = buildPrompt(userQuery, context);

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);

            ObjectNode requestBody = objectMapper.createObjectNode();
            requestBody.put("model", "nemotron-mini");
            requestBody.put("prompt", fullPrompt);
            requestBody.put("stream", false);

            HttpEntity<String> request = new HttpEntity<>(requestBody.toString(), headers);
            ResponseEntity<String> response = restTemplate.postForEntity(OLLAMA_URL, request, String.class);
            
            // Parse the JSON response
            ObjectNode responseJson = (ObjectNode) objectMapper.readTree(response.getBody());
            return responseJson.get("response").asText();
        } catch (JsonProcessingException | RestClientException e) {
            throw new RuntimeException("Error communicating with Ollama: " + e.getMessage(), e);
        }
    }

    private String buildFinancialContext() {
        StringBuilder context = new StringBuilder();
        
        // Get current envelope information
        List<Envelope> envelopes = envelopeService.getAllEnvelopes();
        context.append("Current Envelopes:\n");
        for (Envelope env : envelopes) {
            context.append(String.format("- %s: Budget $%.2f, Available $%.2f\n",
                env.getName(),
                env.getMonthlyBudget(),
                env.getAvailable()));
        }

        // Get recent transactions
        LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
        List<Transaction> recentTransactions = transactionService.getRecentTransactions(
            oneMonthAgo,
            LocalDateTime.now()
        );
        
        context.append("\nRecent Transactions:\n");
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");
        for (Transaction tx : recentTransactions.stream().limit(10).collect(Collectors.toList())) {
            context.append(String.format("- %s: $%.2f in %s (%s)\n",
                tx.getDate().format(formatter),
                tx.getAmount(),
                tx.getEnvelope().getName(),
                tx.getDescription()));
        }

        // Merge regular insights with advanced ML insights
        List<SpendingInsight> regularInsights = insightService.generateInsights();
        List<SpendingInsight> advancedInsights = getAdvancedMLInsights();
        List<SpendingInsight> allInsights = new ArrayList<>();
        allInsights.addAll(regularInsights);
        allInsights.addAll(advancedInsights);
        
        context.append("\nFinancial Insights:\n");
        for (SpendingInsight insight : allInsights) {
            context.append("- ").append(insight.getMessage()).append("\n");
        }

        // Calculate overall financial status
        BigDecimal totalBudget = envelopes.stream()
            .map(Envelope::getMonthlyBudget)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
            
        BigDecimal totalAvailable = envelopes.stream()
            .map(Envelope::getAvailable)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
            
        context.append(String.format("\nOverall Status:\n- Total Budget: $%.2f\n- Total Available: $%.2f\n",
            totalBudget, totalAvailable));

        // Add spending patterns for recent transactions
        if (!recentTransactions.isEmpty()) {
            context.append("\nSpending Patterns:\n");
            for (Transaction tx : recentTransactions.stream().limit(5).collect(Collectors.toList())) {
                Map<Envelope, Double> suggestions = patternService.suggestEnvelopes(tx);
                if (!suggestions.isEmpty()) {
                    context.append(String.format("- Transaction '%s' matches patterns from: ", tx.getDescription()));
                    context.append(suggestions.entrySet().stream()
                        .sorted((e1, e2) -> e2.getValue().compareTo(e1.getValue()))
                        .limit(2)
                        .map(e -> String.format("%s (%.0f%% confidence)", 
                            e.getKey().getName(), 
                            e.getValue() * 100))
                        .collect(Collectors.joining(", ")))
                        .append("\n");
                }
            }
        }

        return context.toString();
    }

    private String buildPrompt(String userQuery, String context) {
        return String.format("""
            Role: You are a financial analysis assistant with direct access to the user's financial data.
            Task: Analyze the provided financial data and answer the user's question with specific, data-driven insights.
            
            Available Data:
            %s
            
            Functions Available:
            - Calculate spending trends across envelopes
            - Compare current spending to budget allocations
            - Identify unusual transactions or patterns
            - Project future expenses based on historical data
            
            User Question: %s
            
            Instructions:
            1. Focus on specific numbers and data points from the provided context
            2. Show brief calculations when relevant
            3. Reference specific transactions or patterns
            4. Provide actionable recommendations based on the data
            5. Keep responses clear and direct
            
            Response Format:
            - Start with a direct answer to the question
            - Include relevant data points and calculations
            - End with a specific, actionable recommendation if applicable
            """, context, userQuery);
    }
    
    /**
     * Helper method that retrieves advanced ML analysis and maps it into SpendingInsight objects.
     */
    private List<SpendingInsight> getAdvancedMLInsights() {
        List<AdvancedMLService.AccountAnalysis> analyses = advancedMLService.analyzeAccounts();
        List<SpendingInsight> mlInsights = new ArrayList<>();
        
        for (AdvancedMLService.AccountAnalysis analysis : analyses) {
            // --- Map anomalies ---
            for (AdvancedMLService.AnomalyDetection anomaly : analysis.getAnomalies()) {
                if (anomaly.type() == AdvancedMLService.AnomalyType.AMOUNT) {
                    mlInsights.add(new SpendingInsight(
                        SpendingInsightType.UNUSUAL_SPENDING,
                        anomaly.description(),
                        anomaly.severity()  // Use anomaly severity as confidence
                    ));
                } else if (anomaly.type() == AdvancedMLService.AnomalyType.FREQUENCY) {
                    mlInsights.add(new SpendingInsight(
                        SpendingInsightType.RECURRING_PAYMENT,
                        anomaly.description(),
                        anomaly.severity()
                    ));
                }
            }
            
            // --- Map recurring payments from merchant metrics ---
            analysis.getMerchantMetrics().forEach((merchant, metrics) -> {
                if (metrics.monthlyFrequency() >= 1.0) { // Arbitrary threshold; adjust as needed.
                    mlInsights.add(new SpendingInsight(
                        SpendingInsightType.RECURRING_PAYMENT,
                        "Recurring payment detected at " + merchant + " (monthly frequency: " +
                            String.format("%.1f", metrics.monthlyFrequency()) + ")",
                        Math.min(1.0, metrics.monthlyFrequency() / 5.0)
                    ));
                }
            });
            
            // --- Map predicted expense from overall spending trend ---
            if (analysis.getVolumeTrend() > 0.2) {
                mlInsights.add(new SpendingInsight(
                    SpendingInsightType.PREDICTED_EXPENSE,
                    "Your spending is trending upward for account " + analysis.getAccount().getName() +
                        ". Consider revising your budget.",
                    0.8
                ));
            }
            
            // --- Map budget suggestions from envelope metrics ---
            analysis.getEnvelopeMetrics().forEach((envelope, envMetrics) -> {
                if (envMetrics.budgetUtilization() > 0.9) {
                    mlInsights.add(new SpendingInsight(
                        SpendingInsightType.BUDGET_SUGGESTION,
                        "Your envelope " + envelope.getName() + " is at " +
                            String.format("%.0f%%", envMetrics.budgetUtilization() * 100) +
                            " of its budget. Consider adjusting your budget.",
                        envMetrics.budgetUtilization()
                    ));
                }
            });
            
            // --- Map seasonal patterns ---
            if (analysis.getVolumeTrend() < -0.2) {
                mlInsights.add(new SpendingInsight(
                    SpendingInsightType.SEASONAL_PATTERN,
                    "Your spending trend indicates a seasonal downturn for account " +
                        analysis.getAccount().getName() + ".",
                    0.7
                ));
            }
            
            // --- Map reallocation suggestions from cross-account analysis ---
            AdvancedMLService.CrossAccountMetrics crossMetrics = analysis.getCrossAccountMetrics();
            if (crossMetrics != null && !crossMetrics.sharedMerchants().isEmpty()) {
                mlInsights.add(new SpendingInsight(
                    SpendingInsightType.REALLOCATION_SUGGESTION,
                    "Your spending patterns share similarities with other accounts. Consider reallocation of funds.",
                    0.75
                ));
            }
        }
        return mlInsights;
    }
}



=== ./src/main/java/org/emblow/envelopify/service/llm/JllamaService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service.llm;

/**
 *
 * @author Nicholas J Emblow
 */
import com.github.tjake.jlama.model.AbstractModel;
import com.github.tjake.jlama.model.ModelSupport;
import com.github.tjake.jlama.model.functions.Generator;
import com.github.tjake.jlama.safetensors.DType;
import com.github.tjake.jlama.safetensors.prompt.PromptContext;
import com.github.tjake.jlama.util.Downloader;
import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.service.EnvelopeService;
import org.emblow.envelopify.service.PatternService;
import org.emblow.envelopify.service.TransactionService;
import org.emblow.envelopify.service.ml.SpendingInsight;
import org.emblow.envelopify.service.ml.SpendingInsightService;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClientException;

import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class JllamaService implements LLMService {

    // Financial services used to build context remain unchanged.
    private final TransactionService transactionService;
    private final EnvelopeService envelopeService;
    private final SpendingInsightService insightService;
    private final PatternService patternService;

    // JLama model field – lazily loaded
    private AbstractModel model;
    
    @Autowired
    public JllamaService(
            TransactionService transactionService,
            EnvelopeService envelopeService,
            SpendingInsightService insightService,
            PatternService patternService
    ) {
        this.transactionService = transactionService;
        this.envelopeService = envelopeService;
        this.insightService = insightService;
        this.patternService = patternService;
    }

    /**
     * Processes the user query by building financial context, assembling a prompt, and then generating
     * a response using the JLama inference engine.
     * @param userQuery
     * @return 
     */
    @Override
    public String processUserQuery(String userQuery) {
        try {
            String context = buildFinancialContext();
            String fullPrompt = buildPrompt(userQuery, context);

            // Ensure the model is loaded
            AbstractModel localModel = getModel();

            // Build a prompt context. If the model supports chat prompts,
            // add a system message and the user prompt.
            PromptContext ctx;
            if (localModel.promptSupport().isPresent()) {
                ctx = localModel.promptSupport()
                        .get()
                        .builder()
                        .addSystemMessage("You are a financial analysis assistant with direct access to the user's financial data.")
                        .addUserMessage(fullPrompt)
                        .build();
            } else {
                ctx = PromptContext.of(fullPrompt);
            }

            // Generate a response using JLama
            Generator.Response response = localModel.generateBuilder()
                    .session(UUID.randomUUID())
                    .promptContext(ctx)
                    .ntokens(8096)
                    .temperature(0.2f)
                    .onTokenWithTimings((token, timing) -> {
                        // Optionally, process streaming tokens here.
                    })
                    .generate();

            return response.responseText;
        } catch (IOException | RestClientException e) {
            throw new RuntimeException("Error during JLama inference: " + e.getMessage(), e);
        }
    }

    /**
     * Lazily loads the JLama model. This method downloads the model (if needed) and loads it
     * using JLama's ModelSupport API.
     */
    private synchronized AbstractModel getModel() throws IOException {
        if (model == null) {
            // Define your model and working directory.
            String modelName = "tjake/Llama-3.2-1B-Instruct-JQ4";
            String workingDirectory = "./models";

            // Download the model (or get the local path if already downloaded)
            File localModelPath = new Downloader(workingDirectory, modelName).huggingFaceModel();

            // Load the model. Here we choose to load with F32 for working memory and I8 for quantized memory.
            model = ModelSupport.loadModel(localModelPath, DType.F32, DType.I8);
        }
        return model;
    }

    /**
     * Builds a financial context string that includes current envelope information,
     * recent transactions, financial insights, overall status, and spending patterns.
     */
    private String buildFinancialContext() {
        StringBuilder context = new StringBuilder();

        // Current envelope information.
        List<Envelope> envelopes = envelopeService.getAllEnvelopes();
        context.append("Current Envelopes:\n");
        for (Envelope env : envelopes) {
            context.append(String.format("- %s: Budget $%.2f, Available $%.2f\n",
                    env.getName(),
                    env.getMonthlyBudget(),
                    env.getAvailable()));
        }

        // Recent transactions.
        LocalDateTime oneMonthAgo = LocalDateTime.now().minusMonths(1);
        List<Transaction> recentTransactions = transactionService.getRecentTransactions(
                oneMonthAgo,
                LocalDateTime.now()
        );
        context.append("\nRecent Transactions:\n");
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy");
        for (Transaction tx : recentTransactions.stream().limit(10).collect(Collectors.toList())) {
            context.append(String.format("- %s: $%.2f in %s (%s)\n",
                    tx.getDate().format(formatter),
                    tx.getAmount(),
                    tx.getEnvelope().getName(),
                    tx.getDescription()));
        }

        // Merge regular and advanced insights.
        List<SpendingInsight> regularInsights = insightService.generateInsights();
        // (Optionally, you might merge in advanced insights from another source if needed.)
        List<SpendingInsight> allInsights = new ArrayList<>(regularInsights);
        context.append("\nFinancial Insights:\n");
        for (SpendingInsight insight : allInsights) {
            context.append("- ").append(insight.getMessage()).append("\n");
        }

        // Overall financial status.
        BigDecimal totalBudget = envelopes.stream()
                .map(Envelope::getMonthlyBudget)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        BigDecimal totalAvailable = envelopes.stream()
                .map(Envelope::getAvailable)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        context.append(String.format("\nOverall Status:\n- Total Budget: $%.2f\n- Total Available: $%.2f\n",
                totalBudget, totalAvailable));

        // Spending patterns from recent transactions.
        if (!recentTransactions.isEmpty()) {
            context.append("\nSpending Patterns:\n");
            for (Transaction tx : recentTransactions.stream().limit(5).collect(Collectors.toList())) {
                Map<Envelope, Double> suggestions = patternService.suggestEnvelopes(tx);
                if (!suggestions.isEmpty()) {
                    context.append(String.format("- Transaction '%s' matches patterns from: ", tx.getDescription()));
                    context.append(suggestions.entrySet().stream()
                            .sorted((e1, e2) -> e2.getValue().compareTo(e1.getValue()))
                            .limit(2)
                            .map(e -> String.format("%s (%.0f%% confidence)",
                                    e.getKey().getName(),
                                    e.getValue() * 100))
                            .collect(Collectors.joining(", ")))
                            .append("\n");
                }
            }
        }

        return context.toString();
    }

    /**
     * Builds the prompt to be sent to the LLM by combining the financial context with the user's query.
     */
    private String buildPrompt(String userQuery, String context) {
        return String.format("""
                Role: You are a financial analysis assistant with direct access to the user's financial data.
                Task: Analyze the provided financial data and answer the user's question with specific, data-driven insights.
                
                Available Data:
                %s
                
                Functions Available:
                - Calculate spending trends across envelopes
                - Compare current spending to budget allocations
                - Identify unusual transactions or patterns
                - Project future expenses based on historical data
                
                User Question: %s
                
                Instructions:
                1. Focus on specific numbers and data points from the provided context
                2. Show brief calculations when relevant
                3. Reference specific transactions or patterns
                4. Provide actionable recommendations based on the data
                5. Keep responses clear and direct
                
                Response Format:
                - Start with a direct answer to the question
                - Include relevant data points and calculations
                - End with a specific, actionable recommendation if applicable
                """, context, userQuery);
    }
}




=== ./src/main/java/org/emblow/envelopify/service/RecurringTransactionService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.scheduling.annotation.Scheduled;
import org.emblow.envelopify.domain.RecurringTransaction;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.repositry.RecurringTransactionRepository;
import org.emblow.envelopify.repositry.AccountRepository;
import java.time.LocalDateTime;
import java.util.List;

@Service
public class RecurringTransactionService {
    private final RecurringTransactionRepository repository;
    private final TransactionService transactionService;
    private final AccountRepository accountRepository;

    public RecurringTransactionService(
        RecurringTransactionRepository repository,
        TransactionService transactionService,
        AccountRepository accountRepository
    ) {
        this.repository = repository;
        this.transactionService = transactionService;
        this.accountRepository = accountRepository;
    }

    @Transactional
    public RecurringTransaction create(RecurringTransaction recurring, Long accountId) {
        Account account = accountRepository.findById(accountId)
            .orElseThrow(() -> new RuntimeException("Account not found"));
        recurring.setAccount(account);
        recurring.setNextDueDate(recurring.calculateNextDueDate());
        return repository.save(recurring);
    }

    @Transactional
    public void update(Long id, RecurringTransaction updated, Long accountId) {
        RecurringTransaction existing = repository.findById(id)
            .orElseThrow(() -> new RuntimeException("Recurring transaction not found"));
            
        Account account = accountRepository.findById(accountId)
            .orElseThrow(() -> new RuntimeException("Account not found"));
            
        existing.setDescription(updated.getDescription());
        existing.setAmount(updated.getAmount());
        existing.setPattern(updated.getPattern());
        existing.setEnvelope(updated.getEnvelope());
        existing.setAccount(account);
        // Propagate the updated transaction type (e.g., INCOME or EXPENSE)
        existing.setType(updated.getType());
        
        repository.save(existing);
    }

    @Transactional
    public void delete(Long id) {
        repository.deleteById(id);
    }

    public List<RecurringTransaction> getAllForEnvelope(Long envelopeId) {
        return repository.findByEnvelopeId(envelopeId);
    }

    @Scheduled(cron = "0 0 * * * *") // Run every hour
    @Transactional
    public void processRecurringTransactions() {
        LocalDateTime now = LocalDateTime.now();
        List<RecurringTransaction> due = repository.findByNextDueDateBefore(now);
        
        for (RecurringTransaction recurring : due) {
            try {
                // Create the actual transaction using the recurring transaction's type.
                // This smartly uses the type stored on the recurring transaction.
                transactionService.recordTransaction(
                    recurring.getEnvelope().getId(),
                    recurring.getAccount().getId(),
                    recurring.getNextDueDate(),
                    recurring.getDescription(),
                    recurring.getAmount(),
                    recurring.getType()
                );
                
                // Update the recurring transaction: mark it as processed and calculate the next due date.
                recurring.setLastProcessed(recurring.getNextDueDate());
                recurring.setNextDueDate(recurring.calculateNextDueDate());
                repository.save(recurring);
                
            } catch (Exception e) {
                // Log the error but continue processing other recurring transactions.
                System.err.println("Error processing recurring transaction: " + e.getMessage());
            }
        }
    }
}



=== ./src/main/java/org/emblow/envelopify/service/AccountService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.repositry.AccountRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.math.BigDecimal;
import java.util.List;

@Service
public class AccountService {
    private final AccountRepository accountRepository;

    public AccountService(AccountRepository accountRepository) {
        this.accountRepository = accountRepository;
    }

    public List<Account> getAllAccounts() {
        return accountRepository.findAll();
    }

    public Account getAccount(Long id) {
        return accountRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Account not found"));
    }

    @Transactional
    public Account createAccount(String name, Account.AccountType type, 
                               String institution, String accountNumber) {
        Account account = new Account(name, type, institution);
        account.setAccountNumber(accountNumber);
        return accountRepository.save(account);
    }

    @Transactional
    public void updateBalance(Long accountId, BigDecimal amount, boolean isCredit) {
        Account account = getAccount(accountId);
        if (isCredit) {
            account.credit(amount);
        } else {
            account.debit(amount);
        }
        accountRepository.save(account);
    }

    @Transactional
    public void transferBetweenAccounts(Long sourceId, Long targetId, BigDecimal amount) {
        Account source = getAccount(sourceId);
        Account target = getAccount(targetId);
        
        source.debit(amount);
        target.credit(amount);
        
        accountRepository.save(source);
        accountRepository.save(target);
    }

    @Transactional
    public Account save(Account account) {
        return accountRepository.save(account);
    }

    @Transactional
    public void deleteAccount(Long id) {
        Account account = getAccount(id);
        if (!account.getTransactions().isEmpty()) {
            throw new IllegalStateException(
                "Cannot delete account that has transactions. " +
                "Transfer or delete transactions first."
            );
        }
        accountRepository.delete(account);
    }
}



=== ./src/main/java/org/emblow/envelopify/service/TestDataService.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.service;

import org.emblow.envelopify.domain.Envelope;
import org.emblow.envelopify.domain.Account;
import org.emblow.envelopify.domain.Transaction;
import org.emblow.envelopify.domain.TransactionType;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.annotation.Propagation;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Random;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class TestDataService {
    private static final Logger log = LoggerFactory.getLogger(TestDataService.class);
    
    private final EnvelopeService envelopeService;
    private final AccountService accountService;
    private final TransactionService transactionService;
    private final Random random = new Random();

    public TestDataService(
        EnvelopeService envelopeService,
        AccountService accountService,
        TransactionService transactionService
    ) {
        this.envelopeService = envelopeService;
        this.accountService = accountService;
        this.transactionService = transactionService;
    }

    /**
     * Creates test data in several steps:
     * 
     * 1. Create the accounts.
     * 2. Create the envelopes (for expense categories) with an initial allocation of zero.
     * 3. For each month in the past 6 months, simulate a transfer from the checking account
     *    into each envelope (i.e. the monthly allocation) and then record expense transactions
     *    against the envelopes.
     * 4. Record a few unusual one‑off transactions.
     */
    @Transactional
    public void createTestData() {
        // --- Step 1: Create accounts ---
        Account checking = accountService.createAccount(
            "Main Checking",
            Account.AccountType.CHECKING,
            "Chase Bank",
            "1234"
        );
        
        Account savings = accountService.createAccount(
            "Emergency Fund",
            Account.AccountType.SAVINGS,
            "Ally Bank",
            "5678"
        );
        
        Account creditCard = accountService.createAccount(
            "Rewards Card",
            Account.AccountType.CREDIT_CARD,
            "Capital One",
            "9012"
        );
        
        // --- Step 2: Create envelopes for expense categories.
        // (We create them with 0 initial funds; funds will be added monthly.)
        Envelope rent = envelopeService.createEnvelope("Rent", BigDecimal.ZERO);
        Envelope utilities = envelopeService.createEnvelope("Utilities", BigDecimal.ZERO);
        Envelope groceries = envelopeService.createEnvelope("Groceries", BigDecimal.ZERO);
        Envelope entertainment = envelopeService.createEnvelope("Entertainment", BigDecimal.ZERO);
        Envelope transport = envelopeService.createEnvelope("Transport", BigDecimal.ZERO);
        envelopeService.flush();
        
        // --- Step 3: For each of the past 6 months, simulate monthly transfers and expense transactions.
        LocalDateTime now = LocalDateTime.now();
        // Define monthly allocation amounts for each envelope.
        BigDecimal rentAllocation = new BigDecimal("2000.00");
        BigDecimal utilitiesAllocation = new BigDecimal("300.00");
        BigDecimal groceriesAllocation = new BigDecimal("600.00");
        BigDecimal entertainmentAllocation = new BigDecimal("200.00");
        BigDecimal transportAllocation = new BigDecimal("150.00");
        
        // Loop over the past 6 months (month = 5 is the oldest, month = 0 is the current month)
        for (int month = 5; month >= 0; month--) {
            // Determine a transfer date for this month (e.g., the first day)
            LocalDateTime transferDate = now.minusMonths(month).withDayOfMonth(1);
            
            // Simulate a transfer into each envelope from the checking account.
            createTransaction(rent.getId(), checking.getId(), transferDate,
                "Monthly Rent Transfer", rentAllocation, TransactionType.INCOME);
            createTransaction(utilities.getId(), checking.getId(), transferDate,
                "Monthly Utilities Transfer", utilitiesAllocation, TransactionType.INCOME);
            createTransaction(groceries.getId(), checking.getId(), transferDate,
                "Monthly Groceries Transfer", groceriesAllocation, TransactionType.INCOME);
            createTransaction(entertainment.getId(), checking.getId(), transferDate,
                "Monthly Entertainment Transfer", entertainmentAllocation, TransactionType.INCOME);
            createTransaction(transport.getId(), checking.getId(), transferDate,
                "Monthly Transport Transfer", transportAllocation, TransactionType.INCOME);
            envelopeService.flush();
            
            // Now record expense transactions for this month.
            // Rent: one expense on the transfer date.
            createTransaction(rent.getId(), checking.getId(), transferDate,
                "Monthly Rent Payment", new BigDecimal("1800.00"), TransactionType.EXPENSE);
            
            // Utilities: expense on the 15th of the month.
            LocalDateTime utilitiesExpenseDate = now.minusMonths(month).withDayOfMonth(15);
            int monthValue = utilitiesExpenseDate.getMonthValue();
            BigDecimal utilitiesExpense = (monthValue <= 3 || monthValue >= 11)
                ? new BigDecimal("280.00")
                : new BigDecimal("180.00");
            createTransaction(utilities.getId(), checking.getId(), utilitiesExpenseDate,
                "Power and Water Bill", utilitiesExpense, TransactionType.EXPENSE);
            
            // Groceries: simulate roughly 4 weekly expenses per month.
            for (int week = 0; week < 4; week++) {
                LocalDateTime weekDate = transferDate.plusDays(week * 7);
                // Randomly choose between checking and credit card.
                Account selectedAccount = random.nextBoolean() ? checking : creditCard;
                createTransaction(groceries.getId(), selectedAccount.getId(), weekDate,
                    "Weekly Groceries", randomAmount(120, 160), TransactionType.EXPENSE);
            }
            
            // Entertainment: simulate 1 to 3 random expense events within the month on the credit card.
            int entertainmentCount = random.nextInt(3) + 1;
            for (int j = 0; j < entertainmentCount; j++) {
                LocalDateTime entDate = transferDate.plusDays(random.nextInt(28));
                createTransaction(entertainment.getId(), creditCard.getId(), entDate,
                    randomEntertainmentDescription(), randomAmount(20, 80), TransactionType.EXPENSE);
            }
            
            // Transport: simulate a monthly bus pass expense and a couple of rideshare expenses.
            createTransaction(transport.getId(), checking.getId(), transferDate,
                "Monthly Bus Pass", new BigDecimal("60.00"), TransactionType.EXPENSE);
            for (int j = 0; j < 2; j++) {
                LocalDateTime rideDate = transferDate.plusDays(random.nextInt(28));
                createTransaction(transport.getId(), creditCard.getId(), rideDate,
                    "Uber Ride", randomAmount(15, 35), TransactionType.EXPENSE);
            }
            
            envelopeService.flush();
        }
        
        // --- Step 4: Record a few unusual one‑off expense transactions.
        createTransaction(groceries.getId(), creditCard.getId(), now.minusDays(5),
            "Big Party Shopping", new BigDecimal("450.00"), TransactionType.EXPENSE);
        createTransaction(entertainment.getId(), creditCard.getId(), now.minusDays(10),
            "Concert Tickets", new BigDecimal("180.00"), TransactionType.EXPENSE);
        envelopeService.flush();
    }
    
    /**
     * Creates a transaction in its own transaction boundary.
     * For expense transactions, it verifies that the envelope has sufficient funds and deducts the amount;
     * for income transactions, it increases the envelope’s allocation.
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    private boolean createTransaction(
        Long envelopeId,
        Long accountId,
        LocalDateTime date,
        String description,
        BigDecimal amount,
        TransactionType type
    ) {
        Envelope envelope;
        try {
            envelope = envelopeService.getEnvelope(envelopeId);
        } catch (RuntimeException ex) {
            log.error("Failed to retrieve envelope with id " + envelopeId, ex);
            envelope = null;
        }
        if (envelope == null) {
            log.error("Failed to create test transaction '{}': Envelope not found", description);
            return false;
        }
        
        if (type == TransactionType.EXPENSE) {
            if (!envelope.canSpend(amount)) {
                log.error("Failed to create test transaction '{}': Insufficient funds in envelope '{}' for amount: {}",
                    description, envelope.getName(), amount);
                return false;
            }
            envelope.spend(amount);
        } else if (type == TransactionType.INCOME) {
            envelope.allocate(amount);
        }
        
        try {
            transactionService.recordTransaction(envelopeId, accountId, date, description, amount, type);
            log.debug("Created test transaction: {} for ${}", description, amount);
            return true;
        } catch (Exception e) {
            log.warn("Failed to create test transaction: {} - {}", description, e.getMessage());
            return false;
        }
    }
    
    private BigDecimal randomAmount(double min, double max) {
        double amt = min + (random.nextDouble() * (max - min));
        return BigDecimal.valueOf(amt).setScale(2, BigDecimal.ROUND_HALF_UP);
    }
    
    private String randomEntertainmentDescription() {
        String[] options = {
            "Movie Tickets",
            "Restaurant Dinner",
            "Bowling Night",
            "Board Game Cafe",
            "Bar Tab",
            "Coffee and Dessert",
            "Arcade Games",
            "Mini Golf"
        };
        return options[random.nextInt(options.length)];
    }
}



=== ./src/main/java/org/emblow/envelopify/config/LLMConfig.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.config;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.service.llm.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.emblow.envelopify.service.*;
import org.emblow.envelopify.service.ml.AdvancedMLService;
import org.emblow.envelopify.service.ml.SpendingInsightService;

@Configuration
public class LLMConfig {
    
    @Value("${llm.service.type:jllama}")  // Default to jllama if not specified
    private String llmServiceType;
    
    @Bean
    @Primary
    public LLMService llmService(
        TransactionService transactionService,
        EnvelopeService envelopeService,
        SpendingInsightService insightService,
        PatternService patternService,
        AdvancedMLService advancedMLService
    ) {
        return switch (llmServiceType.toLowerCase().trim()) {
            
            case "chatgpt" -> new ChatGPTService(
                transactionService, 
                envelopeService, 
                insightService, 
                patternService
            );
            case "jllama" -> new JllamaService(
                transactionService, 
                envelopeService, 
                insightService, 
                patternService
            );
            case "ollama" -> new OllamaService(
                transactionService, 
                envelopeService, 
                insightService, 
                patternService,
                advancedMLService
            );
            default -> throw new IllegalArgumentException(
                "Unknown LLM service type: " + llmServiceType
            );
        };
    }
}


=== ./src/main/java/org/emblow/envelopify/config/SecurityConfig.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.config;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.spring.security.VaadinWebSecurity;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

@EnableWebSecurity
@Configuration
public class SecurityConfig extends VaadinWebSecurity {
     
    @Bean
    public SecurityFilterChain configureHttpSecurity(HttpSecurity http) throws Exception {
        // Configure your application's security
        http.authorizeHttpRequests((auth) -> auth
            .requestMatchers(
                new AntPathRequestMatcher("/images/**"),
                new AntPathRequestMatcher("/h2-console/**"),
                new AntPathRequestMatcher("/frontend/**"),
                new AntPathRequestMatcher("/VAADIN/**")
            ).permitAll()
        );
        
        // Configure H2 console
        http.headers(headers -> headers.frameOptions(frame -> frame.sameOrigin()));
        
        // Call parent configuration
        super.configure(http);
        
        // Return the built configuration
        return http.build();
    }
}





=== ./src/main/java/org/emblow/envelopify/config/DatabaseConfig.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.config;

/**
 *
 * @author Nicholas J Emblow
 */
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableJpaAuditing
@EnableTransactionManagement
public class DatabaseConfig {
    // Additional database configuration if needed
}


=== ./src/main/java/org/emblow/envelopify/EnvelopifyApplication.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify;

/**
 *
 * @author Nicholas J Emblow
 */
import com.vaadin.flow.component.page.AppShellConfigurator;
import com.vaadin.flow.component.page.Push;
import com.vaadin.flow.theme.Theme;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@Theme(value = "envelopify")
@Push
public class EnvelopifyApplication implements AppShellConfigurator {
    public static void main(String[] args) {
        
        SpringApplication.run(EnvelopifyApplication.class, args);
    }
}





=== ./src/main/java/org/emblow/envelopify/domain/Account.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Entity
public class Account {
    @Id 
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String name;
    
    @NotNull
    private AccountType type;
    
    @NotNull
    private BigDecimal balance = BigDecimal.ZERO;
    
    private String accountNumber; // Last 4 digits for reference
    private String institution;
     @OneToMany(mappedBy = "account")
    private List<RecurringTransaction> recurringTransactions = new ArrayList<>();   
    @OneToMany(mappedBy = "account")
    private List<Transaction> transactions = new ArrayList<>();
    
    public enum AccountType {
        CHECKING("Checking"),
        SAVINGS("Savings"),
        CREDIT_CARD("Credit Card"),
        CASH("Cash"),
        INVESTMENT("Investment");
        
        private final String displayName;
        
        AccountType(String displayName) {
            this.displayName = displayName;
        }
        
        public String getDisplayName() {
            return displayName;
        }
    }

    // Constructors
    public Account() {}
    
    public Account(String name, AccountType type, String institution) {
        this.name = name;
        this.type = type;
        this.institution = institution;
    }
    
    // Balance management methods
    public void credit(BigDecimal amount) {
        this.balance = this.balance.add(amount);
    }
    
    public void debit(BigDecimal amount) {
        this.balance = this.balance.subtract(amount);
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public AccountType getType() { return type; }
    public void setType(AccountType type) { this.type = type; }
    
    public BigDecimal getBalance() { return balance; }
    public void setBalance(BigDecimal balance) { this.balance = balance; }
    
    public String getAccountNumber() { return accountNumber; }
    public void setAccountNumber(String accountNumber) { this.accountNumber = accountNumber; }
    
    public String getInstitution() { return institution; }
    public void setInstitution(String institution) { this.institution = institution; }
    
    public List<Transaction> getTransactions() { return transactions; }
    public void setTransactions(List<Transaction> transactions) { this.transactions = transactions; }
}



=== ./src/main/java/org/emblow/envelopify/domain/RecurringTransaction.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import org.emblow.envelopify.domain.TransactionType;  

@Entity
public class RecurringTransaction {
    @Id 
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String description;
    
    @NotNull
    private BigDecimal amount;
    
    @NotNull
    @ManyToOne
    private Envelope envelope;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    private RecurrencePattern pattern;
    
    private LocalDateTime nextDueDate;
    private LocalDateTime lastProcessed;
    
    @NotNull
    @ManyToOne
    private Account account;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    private TransactionType type;  // New field for classification (e.g., INCOME or EXPENSE)
    
    public enum RecurrencePattern {
        DAILY,
        WEEKLY,
        BIWEEKLY,
        MONTHLY,
        YEARLY
    }
    
    // Default constructor
    public RecurringTransaction() {}
    
    // Full constructor updated to include transaction type
    public RecurringTransaction(
        String description,
        BigDecimal amount,
        Envelope envelope,
        Account account,
        RecurrencePattern pattern,
        TransactionType type
    ) {
        this.description = description;
        this.amount = amount;
        this.envelope = envelope;
        this.account = account;
        this.pattern = pattern;
        this.type = type;
        this.nextDueDate = calculateNextDueDate();
    }
    
    public LocalDateTime calculateNextDueDate() {
        LocalDateTime base = (lastProcessed != null) ? lastProcessed : LocalDateTime.now();
        return switch (pattern) {
            case DAILY -> base.plusDays(1);
            case WEEKLY -> base.plusWeeks(1);
            case BIWEEKLY -> base.plusWeeks(2);
            case MONTHLY -> base.plusMonths(1);
            case YEARLY -> base.plusYears(1);
        };
    }
    
    // Getters and Setters
    
    public Long getId() { 
        return id; 
    }
    
    public void setId(Long id) { 
        this.id = id; 
    }
    
    public String getDescription() { 
        return description; 
    }
    
    public void setDescription(String description) { 
        this.description = description; 
    }
    
    public BigDecimal getAmount() { 
        return amount; 
    }
    
    public void setAmount(BigDecimal amount) { 
        this.amount = amount; 
    }
    
    public Envelope getEnvelope() { 
        return envelope; 
    }
    
    public void setEnvelope(Envelope envelope) { 
        this.envelope = envelope; 
    }
    
    public RecurrencePattern getPattern() { 
        return pattern; 
    }
    
    public void setPattern(RecurrencePattern pattern) { 
        this.pattern = pattern; 
    }
    
    public LocalDateTime getNextDueDate() { 
        return nextDueDate; 
    }
    
    public void setNextDueDate(LocalDateTime nextDueDate) { 
        this.nextDueDate = nextDueDate; 
    }
    
    public LocalDateTime getLastProcessed() { 
        return lastProcessed; 
    }
    
    public void setLastProcessed(LocalDateTime lastProcessed) { 
        this.lastProcessed = lastProcessed; 
    }
    
    public Account getAccount() { 
        return account; 
    }
    
    public void setAccount(Account account) { 
        this.account = account; 
    }
    
    public TransactionType getType() { 
        return type; 
    }
    
    public void setType(TransactionType type) { 
        this.type = type; 
    }
}



=== ./src/main/java/org/emblow/envelopify/domain/Category.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import java.util.List;

@Entity
public class Category {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String name;
    
    @NotNull
    private String description;
    
    @OneToMany(mappedBy = "category")
    private List<Pattern> patterns;
    
    // Constructors
    public Category() {}
    
    public Category(String name, String description) {
        this.name = name;
        this.description = description;
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public List<Pattern> getPatterns() { return patterns; }
    public void setPatterns(List<Pattern> patterns) { this.patterns = patterns; }
}




=== ./src/main/java/org/emblow/envelopify/domain/TransactionType.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
public enum TransactionType {
    INCOME, EXPENSE;
}


=== ./src/main/java/org/emblow/envelopify/domain/BillReminder.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
public class BillReminder {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String description;
    
    @NotNull
    private BigDecimal amount;
    
    @NotNull
    @ManyToOne
    private Envelope envelope;
    
    @NotNull
    @ManyToOne
    private Account account;
    
    @NotNull
    private LocalDate dueDate;
    
    private int reminderDays = 7;
    private boolean paid = false;
    
    // Default constructor
    public BillReminder() {}
    
    // Full constructor
    public BillReminder(
        String description,
        BigDecimal amount,
        Envelope envelope,
        Account account,
        LocalDate dueDate,
        int reminderDays
    ) {
        this.description = description;
        this.amount = amount;
        this.envelope = envelope;
        this.account = account;
        this.dueDate = dueDate;
        this.reminderDays = reminderDays;
    }
    
    // Add account getter/setter
    public Account getAccount() { return account; }
    public void setAccount(Account account) { this.account = account; }
    
    // Existing methods...
    public boolean isOverdue() {
        return !paid && LocalDate.now().isAfter(dueDate);
    }
    
    public boolean needsReminder() {
        if (paid) return false;
        LocalDate reminderDate = dueDate.minusDays(reminderDays);
        return LocalDate.now().isAfter(reminderDate) && !isOverdue();
    }
    
    // Rest of existing getters/setters...
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public BigDecimal getAmount() { return amount; }
    public void setAmount(BigDecimal amount) { this.amount = amount; }
    
    public Envelope getEnvelope() { return envelope; }
    public void setEnvelope(Envelope envelope) { this.envelope = envelope; }
    
    public LocalDate getDueDate() { return dueDate; }
    public void setDueDate(LocalDate dueDate) { this.dueDate = dueDate; }
    
    public int getReminderDays() { return reminderDays; }
    public void setReminderDays(int reminderDays) { this.reminderDays = reminderDays; }
    
    public boolean isPaid() { return paid; }
    public void setPaid(boolean paid) { this.paid = paid; }
}


=== ./src/main/java/org/emblow/envelopify/domain/InsufficientFundsException.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import java.math.BigDecimal;

public class InsufficientFundsException extends RuntimeException {
    public InsufficientFundsException(String envelopeName, BigDecimal amount) {
        super("Insufficient funds in envelope '" + envelopeName + 
              "' for amount: " + amount);
    }
}


=== ./src/main/java/org/emblow/envelopify/domain/Transaction.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
public class Transaction {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotNull
    private LocalDateTime date;

    @NotNull
    private String description;

    @NotNull
    private BigDecimal amount;

    @ManyToOne
    @NotNull
    private Envelope envelope;

    @ManyToOne
    @NotNull
    private Account account;
 
    @NotNull
    @Enumerated(EnumType.STRING)
    private TransactionType type;
    
    // Default constructor for JPA
    public Transaction() {}

   public Transaction(LocalDateTime date, String description, BigDecimal amount, 
                       Envelope envelope, Account account, TransactionType type) {
        this.date = date;
        this.description = description;
        this.amount = amount;
        this.envelope = envelope;
        this.account = account;
        this.type = type;
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public LocalDateTime getDate() { return date; }
    public void setDate(LocalDateTime date) { this.date = date; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public BigDecimal getAmount() { return amount; }
    public void setAmount(BigDecimal amount) { this.amount = amount; }

    public Envelope getEnvelope() { return envelope; }
    public void setEnvelope(Envelope envelope) { this.envelope = envelope; }

    // Helper method to get the category name (which is the envelope name)
    public String getCategory() {
        return envelope != null ? envelope.getName() : null;
    }
    public Account getAccount() { return account; }
    public void setAccount(Account account) { this.account = account; }
    public TransactionType getType() {
        return type;
    }
    public void setType(TransactionType type) {
        this.type = type;
    }

    @Override
    public String toString() {
        return "Transaction{" +
                "id=" + id +
                ", type="+type +
                ", date=" + date +
                ", description='" + description + '\'' +
                ", amount=" + amount +
                ", envelope=" + (envelope != null ? envelope.getName() : "null") +
                '}';
    }
}


=== ./src/main/java/org/emblow/envelopify/domain/Envelope.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

/**
 *
 * @author Nicholas J Emblow
 */
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
public class Envelope {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String name;
    
    @NotNull
    private BigDecimal allocated = BigDecimal.ZERO;
    
    @NotNull
    private BigDecimal spent = BigDecimal.ZERO;
    
    @OneToMany(mappedBy = "envelope")
    private List<Transaction> transactions;

    
    @NotNull
    private BigDecimal monthlyBudget = BigDecimal.ZERO;
    
    private LocalDate budgetResetDate = LocalDate.now().withDayOfMonth(1);
    
    @OneToMany(mappedBy = "envelope", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<RecurringTransaction> recurringTransactions = new ArrayList<>();
    
    @OneToMany(mappedBy = "envelope", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<BillReminder> billReminders = new ArrayList<>();
    
    // Constructors
    public Envelope() {}
    
    public Envelope(String name, BigDecimal allocated) {
        this.name = name;
        this.allocated = allocated;
    }
    
    // Smart methods
    public boolean canSpend(BigDecimal amount) {
        return getAvailable().compareTo(amount) >= 0;
    }
    
    
    public BigDecimal getAvailable() {
        return allocated.subtract(spent);
    }
    
    public void spend(BigDecimal amount) {
        if (!canSpend(amount)) {
            throw new InsufficientFundsException(name, amount);
        }
        spent = spent.add(amount);
    }
    
    public void unspend(BigDecimal amount) {
        if (!canSpend(amount)) {
            throw new InsufficientFundsException(name, amount);
        }
        spent = spent.subtract(amount);
    }
    
    public void unallocate(BigDecimal amount) {
        this.allocated = this.allocated.subtract(amount);
    }
    
    public void allocate(BigDecimal amount) {
        this.allocated = this.allocated.add(amount);
    }
    
    public void withdraw(BigDecimal amount) {
        if (amount.compareTo(getAvailable()) > 0) {
            throw new InsufficientFundsException(name, amount);
        }
        this.allocated = this.allocated.subtract(amount);
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public BigDecimal getAllocated() { return allocated; }
    public BigDecimal getSpent() { return spent; }
    public List<Transaction> getTransactions() { return transactions; }
    public void setTransactions(List<Transaction> transactions) { 
        this.transactions = transactions; 
    }
    
    public double getSpentPercentage() {
        if (allocated.compareTo(BigDecimal.ZERO) == 0) return 0.0;
        return spent.divide(allocated, 4, BigDecimal.ROUND_HALF_UP)
                   .multiply(BigDecimal.valueOf(100))
                   .doubleValue();
    }
    
    public void setMonthlyBudget(BigDecimal amount) {
        this.monthlyBudget = amount;
    }
    
    public BigDecimal getMonthlyBudget() {
        return monthlyBudget;
    }
    
    public double getBudgetUtilization() {
        if (monthlyBudget.compareTo(BigDecimal.ZERO) == 0) return 0.0;
        return getCurrentMonthSpent()
            .divide(monthlyBudget, 4, RoundingMode.HALF_UP)
            .doubleValue();
    }
    
    public BigDecimal getCurrentMonthSpent() {
        return transactions.stream()
            .filter(tx -> tx.getDate().isAfter(budgetResetDate.atStartOfDay()))
            .map(Transaction::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    public BigDecimal getRemainingBudget() {
        return monthlyBudget.subtract(getCurrentMonthSpent());
    }    
}


=== ./src/main/java/org/emblow/envelopify/domain/Pattern.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import jakarta.validation.constraints.NotNull;

/**
 *
 * @author Nicholas J Emblow
 */
@Entity
public class Pattern {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    private String pattern;
    
    @NotNull
    private PatternType type;
    
    @ManyToOne
    private Category category;
    
    private Double confidence;
    
    public enum PatternType {
        MERCHANT,
        TEMPORAL,
        AMOUNT
    }
    
    // Constructors
    public Pattern() {}
    
    public Pattern(String pattern, PatternType type, Category category) {
        this.pattern = pattern;
        this.type = type;
        this.category = category;
        this.confidence = 1.0;
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getPattern() { return pattern; }
    public void setPattern(String pattern) { this.pattern = pattern; }
    public PatternType getType() { return type; }
    public void setType(PatternType type) { this.type = type; }
    public Category getCategory() { return category; }
    public void setCategory(Category category) { this.category = category; }
    public Double getConfidence() { return confidence; }
    public void setConfidence(Double confidence) { this.confidence = confidence; }
}


=== ./src/main/java/org/emblow/envelopify/repositry/AccountRepository.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repositry;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Account;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
    List<Account> findByType(Account.AccountType type);
    List<Account> findByInstitution(String institution);
}




=== ./src/main/java/org/emblow/envelopify/repositry/RecurringTransactionRepository.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repositry;

import org.emblow.envelopify.domain.RecurringTransaction;
import org.emblow.envelopify.domain.TransactionType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.time.LocalDateTime;
import java.util.List;
import org.emblow.envelopify.domain.TransactionType;

@Repository
public interface RecurringTransactionRepository extends JpaRepository<RecurringTransaction, Long> {
    List<RecurringTransaction> findByNextDueDateBefore(LocalDateTime date);
    List<RecurringTransaction> findByEnvelopeId(Long envelopeId);
    List<RecurringTransaction> findByAccountId(Long accountId);
    List<RecurringTransaction> findByType(TransactionType type);
    List<RecurringTransaction> findByAccountIdAndType(Long accountId, TransactionType type);
}



=== ./src/main/java/org/emblow/envelopify/repositry/EnvelopeRepository.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repositry;

/**
 *
 * @author Nicholas J Emblow
 */
import java.util.Optional;
import org.emblow.envelopify.domain.Envelope;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface EnvelopeRepository extends JpaRepository<Envelope, Long> {
@Query("SELECT e FROM Envelope e LEFT JOIN FETCH e.transactions WHERE e.id = :id")
Optional<Envelope> findByIdWithTransactions(@Param("id") Long id);

}



=== ./src/main/java/org/emblow/envelopify/repositry/TransactionRepository.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repositry;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Transaction;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    List<Transaction> findByDateBetweenOrderByDateDesc(LocalDateTime start, LocalDateTime end);
    
    // New methods
    List<Transaction> findByDateAfterOrderByDateDesc(LocalDateTime date);
    
    @Query("SELECT t FROM Transaction t WHERE t.envelope.name = :envelopeName")
    List<Transaction> findByEnvelopeName(String envelopeName);
}




=== ./src/main/java/org/emblow/envelopify/repositry/BillReminderRepository.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repositry;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.BillReminder;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;

@Repository
public interface BillReminderRepository extends JpaRepository<BillReminder, Long> {
    List<BillReminder> findByPaidFalseAndDueDateBefore(LocalDate date);
    List<BillReminder> findByEnvelopeId(Long envelopeId);
    List<BillReminder> findByPaidFalseOrderByDueDateAsc();
}



=== ./src/main/java/org/emblow/envelopify/repositry/PatternRepository.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repositry;

import java.util.List;
import java.util.Optional;
import org.emblow.envelopify.domain.Category;
import org.emblow.envelopify.domain.Pattern;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

/**
 *
 * @author Nicholas J Emblow
 */
@Repository
public interface PatternRepository extends JpaRepository<Pattern, Long> {
    List<Pattern> findByCategory(Category category);
    List<Pattern> findByType(Pattern.PatternType type);
    Optional<Pattern> findByPatternAndType(String pattern, Pattern.PatternType type);
}



=== ./src/main/java/org/emblow/envelopify/repositry/CategoryRepository.java ===
/*
 * Copyright (C) 2025 Nicholas J Emblow
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.emblow.envelopify.repositry;

/**
 *
 * @author Nicholas J Emblow
 */
import org.emblow.envelopify.domain.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
    Optional<Category> findByName(String name);
}




